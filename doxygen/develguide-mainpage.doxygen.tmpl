/** @page develguide Developer's Guide

    @section develguidecontents Overview of Content of the Qorus Developer's Guide

    - @subpage develintro
      - @ref devintro_use_cases
      - @ref devintro_overview
      - @ref devintro_languages
      - @ref devintro_no_code_for_coders
      - @ref devintro_high_level_design
    - @subpage designimplworkflows
      - @ref workflowdesign
      - @ref wf_recoverability
      - @ref wfdeffile
      - @ref stepdefs
    - @subpage implementingservices
      - @ref svcimplintro
      - @ref servicedesc
      - @ref service_methods
      - @ref servicehttp
      - @ref serviceftp
    - @subpage implementingjobs
      - @ref jobimplintro
      - @ref jobdeffile
    - @subpage finite_state_machines
      - @ref fsm_overview
      - @ref fsm_transitions
      - @ref fsm_data_processing
      - @ref fsm_states
      - @ref fsm_transitions
    - @subpage data_pipelines
      - @ref data_pipeline_intro
      - @ref data_pipeline_processors
      - @ref data_pipeline_bulk_processing
    - @subpage other_objects
      - @ref class_objects
      - @ref library_objects
      - @ref queue_objects
      - @ref group_objects
      - @ref wf_sync_event_objects
    - @subpage definingconnections
      - @ref connectionfiles
    - @subpage mapper-devel
      - @ref mapper-devel-overview
      - @ref mapper-devel-files
    - @subpage typedefs
      - @ref typedef_intro
      - @ref typedef_paths
      - @ref typedef_ide
    - @subpage valuemap-devel
      - @ref value-map-api
      - @ref value-map-exceptions
      - @ref value-map-oload
        - @ref value-map-oload-attrs
    - @subpage implementingqorusobjectsusingyaml
      - @ref yamldefinitionfiles
      - @ref yaml_formatted_data
    - @subpage python_development
      - @ref python_development_intro
      - @ref python_development_module_path
      - @ref python_development_thread_stacks
      - @ref python_development_workflows
      - @ref python_development_services
      - @ref python_development_jobs
      - @ref python_development_restrictions
      - @ref python_development_qore_refs
      - @ref python_development_client
      - @ref python_development_testing
    - @subpage javadevelopment
      - @ref javadevelopment_intro
      - @ref javadevelopment_classpath
      - @ref javadevelopment_workflows
      - @ref javadevelopment_services
      - @ref javadevelopment_jobs
      - @ref javadevelopment_restrictions
      - @ref javadevelopment_qore_refs
      - @ref javadevelopment_testing
      - @ref javadevelopment_client
      - @ref javadevelopment_qore_from_java
    - @subpage devel-sqlcache
      - @ref devel-sqlcache-intro
      - @ref sql-cache-functions
    - @subpage schemamanagement
      - @ref schemamanagementintro
      - @ref schemamodulefile
    - @subpage customqscripts
      - @ref customqscriptsintro
      - @ref qscriptfile
    - @subpage ci_cd
      - @ref qorus_releases
      - @ref qorus_testing
    - @subpage managed_by_operations
    - @subpage debugging
    - @subpage commontasks
    - @subpage commonserverapi
    - @subpage qorusinterfacetest_module
    - @subpage develmodules
      - @ref develmodules_workflow_modules
      - @ref develmodules_service_modules
      - @ref develmodules_job_modules
    - Qorus Data Provider Modules
      - @subpage qorusalldataproviders_module
      - @subpage qorusapidataproviderintro_module
      - @subpage qorusconnectionprovider_module
      - @subpage qorusdataproviders_module
      - @subpage qorusdatasourceprovider_module
      - @subpage qorusremoteconnectiondataprovider_module
      - @subpage qorusremotedataprovider_module
      - @subpage remoteapiprovider_module
      - @subpage remotedbdataprovider_module
      - @subpage remotedbprovider_module
    - Qorus Client Modules
      - @subpage qorusqscriptutil_module
      - @subpage qorusinterfacetest_module
      - @subpage qorusclientbase_module
*/

/** @page develintro Introduction

    @tableofcontents

    @ref develguide "Back to the Developer's Guide Table of Contents"

    @section devintro_use_cases Use Cases for Qorus

    Qorus can be used for the following use cases:
    - Stateful IT process automation: Qorus @ref designimplworkflows "workflows" were designed to handle high-volume
      IT process automation with the automatic detection and recovery from technical IT errors (ex: database down, API
      listener temporarily not reachable, network unreliable, etc), and includes
      @ref sensitive_data "APIs for handling sensitive data" as well as @ref sla_tracking "SLA tracking and reporting"
      and more.
    - Data integration / ETL challenges: Qorus supports @ref data_pipelines "data pipelines",
      @ref mapper-devel "mappers", @ref implementingjobs "jobs" for scheduled tasks with an audit trail,
      @ref implementingservices "services" for event- and API-driven integration and much more to enable data
      integration challenges to be solved in less time, with less effort and lower risk than other solutions
    - @ref ci_cd "CI/CD": Qorus supports CI/CD through
      @ref qorus_releases "automating release packaging and deployments" and through facilitating
      @ref qorus_testing "testing" to ensure high-quality releases
    - Data migrations, @ref service_api_manager "API handlers", @ref service_stateless "microservices", and more can
      additionally be handled with ease using Qorus

    @section devintro_overview Overview

    This documentation describes how to develop integration as well as AI/ML/Data Science solutions with Qorus
    Integration Engine&trade;.

    Qorus is designed to support no-code/low-code solutions by combining configurable building blocks in end-to-end
    solutions to solve simple and complex IT integration and automation challenges.

    Building blocks are generally defined as @ref class_objects "class objects", which are a combination of code and
    configuration that make the code generically useful in as many use cases as possible.

    Code in Qorus can be defined in any of the following programming languages:
    - @ref python_development "Python" (standard CPython)
    - @ref javadevelopment "Java" (OpenJDK JVM)
    - <a href="../qore/lang/html/index.html">Qore</a> (designed for Qorus)

    The concept of using a dynamically-typed language such as %Python in an IT data and process
    orchestration / automation solution, embedded in a rigid framework to provide interface reliability, error
    recoverability, and  operational traceability such as with Qorus Integration Engine&trade;, results in extremely
    fast and flexible development and very high operational reliability.  This leads directly to lower development and
    operational costs, greater business flexibility, and higher process quality.

    Java is a compiled language bringing enterprise capabilities to Qorus and can be used as the primary language for
    building-block development, or it can be mixed with %Python and %Qore code or with no-code building-blocks
    regardless or the language as needed.

    The %Qore language is an enabling technology that provides the infrastructure necessary to allow Java and %Python
    to be seamlessly integrated, allowing %Python-based AI and data science functionality to interface directly with
    enterprise systems, data, and protocols through Java APIs.

    Qorus code can use APIs in any supported programming language equally; dynamic imports of APIs in other languages
    are supported in each language; %Python can dynamically import Java and %Qore APIs, and Java also can dynamically
    import %Python and %Qore APIs in the same way using standard \c import statements in each language.

    This low-level language integration is one way that Qorus enables powerful AI/ML/Data Science solutions to easily
    integrate with enterprise data sources as well as to power fault-tolerant process orchestration.

    Another important aspect of Qorus is the
    <a href="https://marketplace.visualstudio.com/items?itemName=qoretechnologies.qorus-vscode">Visual-Studio-Code-based
    IDE</a>, which enables non-expert users to put together and configure end-to-end solutions without coding using
    building blocks, as well as permitting expert users to build and extend reusable and generic functionality
    combining code and metadata in building blocks, empowering operations and non-technical users as well as experts
    to deliver complex end-to-end IT integration and automation solutions on Qorus in less time and with less risk
    than with alternative solutions.

    @section devintro_languages Programming Languages

    Qorus supports @ref python_development "Python", @ref javadevelopment "Java", and
    <a href="../qore/lang/html/index.html">Qore</a> for coding, and each language has its own advantages and
    disadvantages, however due to the fact that %Qore provides the glue that links @ref python_development "Python"
    and @ref javadevelopment "Java" together, all three languages can import and use APIs from the other two.

    <b>Qorus Language Table</b>
    |!Attribute|!%Python|!Java|!%Qore
    |<b>Threading</b>|Poor|Excellent|Excellent
    |<b>Memory Footprint</b>|Large|Large|Small
    |<b>Sandboxing</b>|Poor|Possible|Excellent

    @note Qorus provides complete and transparent API interoperability between the three supported languages; import
    Java APIs in %Python or vice-versa using standard \c import statements; when importing %Qore or %Python APIs into
    Java, wrapper classes for the imported APIs are generated automatically using Qorus's dynamic bytecode generation,
    for example.

    @see
    - @ref python_development
    - @ref javadevelopment

    @section devintro_no_code_for_coders No-Code Platform for Coders

    Qorus is a "no-code platform for coders", because it supports coding and also wrapping code into reusable objects
    driven by configuration as well.   This allows developers to prototype solutions and then deliver solutions as
    reusable, self-documenting components to reduce time, risk, and cost of solving similar problems in the future, as
    well as reducing the time, risk, and cost of software maintenance of such solutions.

    In addition to configuring existing integration objects, all Qorus integration objects backed by code can be
    implemented, extended, or customized with the
    <a href="https://marketplace.visualstudio.com/items?itemName=qoretechnologies.qorus-vscode">Qorus IDE</a>.

    <b>No-Code / Low-Code Objects</b>
    |!No-Code / Low-Code Object|!Description|!Code|!Description
    |@ref class_objects "Class"|Fundamental logic element of Qorus|<b>Yes</b>|@ref class_objects "Classes" allow \
        logic to be encapsulated and made generic by declaring @ref class_config_items "configuration" and other \
        attributes that enable classes to be self-documenting, to work in generic contexts, and to be deployed and \
        used by non-expert users
    |@ref devintro_no_code_connections "Class Connections"|Linear logic flow for interfaces|<b>Yes</b>|Each element \
        in a class connection is either a @ref class_connectors "class connector" or a @ref mapper-devel "mapper", \
        each of which can be supported by code (in the case of @ref class_connectors "class connectors", there is \
        always code)
    |@ref definingconnections "Connection"|Connection to an external system or data|No|\
        @ref definingconnections "Connections" are made up of configuration data and do not contain any code
    |@ref class_connectors "Connector"|Simple linear logic element in a @ref class_objects "class"|<b>Yes</b>|\
        @ref class_connectors "Connectors" are special methods in a @ref class_objects "classes" that can be used \
        along with @ref mapper-devel "mappers" in class connections to be executed as linear logic on a certain event
    |@ref data_pipelines "Data Pipeline"|Data processing pipelines|<b>Yes</b>|\
        @ref data_pipeline_processors "Data pipeline processors" are backed by code at the implementation level; \
        @ref mapper-devel "mappers" are mostly configuration, but can be customized with code as well
    |@ref finite_state_machines "Flows / Finite State Machines"|Graphically-created logic flows that can be used in \
        place of code anywhere in Qorus|<b>Yes</b>|@ref finite_state_machines "Finite state machines" are made up of \
        @ref fsm_states "states", some of which (ex: @ref class_connectors "class connector states") are backed by \
        code (@ref class_objects "classes") at the implementation level
    |@ref group_objects "Group"|Interface groups|No|@ref group_objects "Groups" are made up of pure configuration
    |@ref implementingjobs "Job"|Scheduled tasks with an audit trail|<b>Yes</b>|@ref implementingjobs "Jobs" are \
        backed by code at the lowest level
    |@ref mapper-devel "Mapper"|Data transformation objects|<b>Yes</b>|@ref mapper-devel "Mappers" are mostly made \
        up of configuration but can be customized with code as well
    |@ref queue_objects "Queue"|Asynchronous queues|No|@ref queue_objects "Queues" are made up of pure configuration \
        and data
    |@ref implementingservices "Service"|APIs, protocol handlers, data cache, event listeners, etc|<b>Yes</b>|\
        @ref implementingservices "Services" and @ref service_methods "service methods" are backed by code at the \
        implementation level
    |@ref stepdefs "Step"|An atomic logic element in a @ref designimplworkflows "workflow"|<b>Yes</b>|\
        @ref stepdefs "Steps" are implemented with @ref class_objects "classes", \
        @ref finite_state_machines "finite state machines", or with @ref class_connectors "class connectors", all of \
        which are backed by code at the implementation level
    |@ref typedefs "Type"|Data type definitions|No|@ref typedefs "Types" describe data types to ensure type-safe \
        data transfers and internal and external communications with Qorus
    |@ref valuemap-devel "Value Map"|Lookup tables|No|@ref valuemap-devel "Value maps" are made up of pure \
        configuration and data and do not contain any code
    |@ref designimplworkflows "Workflow"|Stateful IT process orchestration|<b>Yes</b>|@ref stepdefs "Steps" and \
        @ref designimplworkflows "workflow" methods are backed by code at the implementation level
    |@ref wf_sync_event_objects "Workflow Synchronization Event"|Used to synchronize workflow processing|No|\
        @ref wf_sync_event_objects "Workflow synchronization events" are made up of pure configuration and data and \
        do not contain any code

    @subsection devintro_no_code_config_items Config Items: Code to No-Code Runtime Configuration for Your Code

    The primary way to package code in a reusable, self-documenting object in Qorus is to implement the code in an
    object that supports config items, therefore config items are one of the main vehicles for enabling developers to
    package their code as self-documenting no-code objects.

    Config items are provided as metadata in supported objects and allow users to control the behavior of the object's
    code at runtime.  Because objects that support config items also support builtin documentation in the form of
    markdown description fields, this enables objects supporting a combination of code and config items to be reusable
    and self-documenting.

    Here is a view of the IDE where config items can be created or edited:

    @image html Qorus-IDE-4-Config-Item-Editor.png "Creating / Editing Config Items in the IDE" width=75%

    Config items have the properties given in the following table.

    <b>Config Item Properties</b>
    |!Property|!Type|!Description
    |\c allowed_values|list|A list of discrete allowed values for the config item; if set then the user will have to \
        choose from a value in this list to set the config item's value
    |\c config_group|\c string|The name of the configuration group; used to separate config items logically in UIs
    |\c default_value|\c any|Any default value for the config item
    |\c description|\c string|The markdown description of the config item and how its value affects the behavior of \
        the code at runtime
    |\c name|\c string|The string value that is used with API calls to use the config item at runtime
    |\c strictly_local|\b bool|If \c true then the config item only takes local values and cannot be set with a \
        global config item value
    |\c type|\c string|The data type of the config item

    Then config items can be used at runtime with API calls to
    @ref OMQ::UserApi::UserApi::getConfigItemValue() "UserApi::getConfigItemValue()" in the code as in the following
    examples.

    @par %Python Config Item Code Example
    @code{.py}
    def processInputFromConfig(self, input):
        input['result'] = self.processInput(input[UserApi.getConfigItemValue("text-analysis-input", {
            "input": input,
        })])
        return input
    @endcode

    @par Java Config Item Code Example
    @code{.java}
String topic_array[] = (String[])UserApi.getConfigItemValue("kafka-topics");
UserApi.logInfo("subscribing to: %y", (Object)topic_array);
cons.subscribe(Arrays.asList(topic_array));
    @endcode

    @par %Qore Config Item Code Example
    @code{.py}
class SalesforceStreamBase inherits QorusService, private AbstractSalesforceEventStreamer {
    constructor() : AbstractSalesforceEventStreamer(ServiceApi::getConfigItemValue("sf-stream-options")) {
    }

    init() {
        setConnectionAndChannels(ServiceApi::getConfigItemValue("sf-stream-connection-name"),
            ServiceApi::getConfigItemValue("sf-stream-channel-names"));
        initImpl();
        start();
    }
}
    @endcode

    Config item values can be set from the IDE as in the following graphic.

    @image html Qorus-IDE-4-Config-Item-List.png "" width=75%

    Config item values can also be set from the UI as in the following graphic.
    @htmlonly
    <div class="image">
      <img src="Qorus-UI-Config-Item-View.png" alt="Setting Config Item Values in the UI" style="width:75%;">
      <div class="caption">Setting Config Item Values in the UI</div>
    </div>
    @endhtmlonly

    Config item values can also be set from the command line - ex:
    @verbatim
prompt$ qrest put jobs/my-job/config/my-config-item value=100
    @endverbatim

    The following objects support config items in Qorus:
    - @ref class_config_items
    - @ref job_config_items
    - @ref service_config_items
    - @ref step_config_items

    @subsection devintro_no_code_logic Flows / Finite State Machines: Build No-Code Logic Graphically

    @ref finite_state_machines "Flows / finite state machines" allow developers to implement logic graphically.

    This makes the implementation clear and self-documenting, which, combined with a full set of
    @ref qorus_tests "tests" for a release, results in reduced time and risk for subsequent changes and inevitable
    future software maintenance.

    Qorus finite state machines allow for building blocks, data provider actions, data transformations (with
    @ref mapper-devel "mappers"), logical loops and variables, API calls, and more to be implemented with a graphical,
    self-documenting approach.

    Finite state machines can be reused and nested as needed as well, just like real code.

    Finite state machines can be used as:
    - @ref implementingjobs "Jobs" can use a finite state machine to execute the run action
    - @ref implementingservices "Services" can use a finite state machine to execute any method as well as for
      handling @ref service_api_manager "API endpoints"
    - @ref stepdefs "Steps" can use finite state machines to implement step actions such as the
      @ref primarystepcode "primary step logic", the @ref validationcode "validation logic",
      @ref arraycode "array logic" (for @ref arraysteps "array steps"), and more

    @image html Qorus-IDE-4-FSM.png "Example Flow in the IDE" width=1000

    @note Finite state machines are executed on the server side from the configuration; no code is generated for
    finite state machines; this differs from @ref devintro_no_code_connections "class connections", which are executed
    based on code generated directly in the IDE.

    @see @ref finite_state_machines for more information

    @subsection devintro_no_code_connections Class Connections: Build Simple Linear No-Code Actions

    Class connections can be used as a simpler alternative to @ref finite_state_machines "finite state machines".  A
    class connection is a linear set of @ref class_connectors "class connectors" and/or @ref mapper-devel "mappers",
    where each element in the connection list is executed after the last, and the output of each element is passed to
    the next element for processing.

    Class connections can be used as:
    - @ref implementingjobs "Jobs" can use a class connection to execute the run action
    - @ref implementingservices "Services" can use a class connection to execute any method
    - @ref stepdefs "Steps" can use class connections to implement step actions such as the
      @ref primarystepcode "primary step logic", the @ref validationcode "validation logic",
      @ref arraycode "array logic" (for @ref arraysteps "array steps"), and more

    See the following graphic for an example of class connections in the IDE.

    @image html Qorus-IDE-4-Class-Connections.png "Class Connection List in the IDE" width=850

    @note Class connections are executed from code generated in the IDE based on their configuration; this differs
    from @ref devintro_no_code_logic "finite state machines", which are executed on the server side directly from
    their configuration; no code is generated for @ref @ref devintro_no_code_logic "finite state machines".

    @section devintro_high_level_design High-Level Interface Design

    The three main integration objects in Qorus are:
    - @ref designimplworkflows "Workflows": for stateful IT process automation, process data (an
      @ref staticdata "order") to a @ref OMQ::StatComplete "COMPLETE" status, recover automatically from technical
      errors
    - @ref implementingjobs "Jobs": tasks run on a specific schedule
    - @ref implementingservices "Services": APIs, protocol handlers, data caches, event listeners, or miscellaneous
      functionality not linked to specific order data like a @ref designimplworkflows "workflow" or run on a schedule
      like a @ref implementingjobs "job"

    @subsection devintro_hld_workflows Workflow Design

    Workflow are all about order data.  If you have order data that must be processed, and the order data should
    complete processing despite technical errors, then a @ref designimplworkflows "workflow" should be used.

    @htmlonly
    <div class="image">
      <img src="Qorus-UI-Workflow-Order-Status.png" alt="Workflow Order Data Status in the UI" style="width:75%;">
      <div class="caption">Workflow Order Data Status in the UI</div>
    </div>
    @endhtmlonly

    Conversely, if you don't have any order data, then as a rule of thumb, you should not create a workflow order
    until the order has been acquired (with a @ref implementingjobs "job" or a @ref implementingservices "service").
    The uniqueness of workflow orders can be guaranteed with unique @ref wf_keylist "order keys" in the action or API
    used to create the order.

    @ref designimplworkflows "Qorus workflows" automatically track @ref staticdata "order" execution time as a
    configurable @ref wf_sla_threshold "SLA" and are very good for tasks that include
    @ref asyncsteps "asynchrononous coordination" with internal and external events as well.

    Workflows can also handle hierarchical order processing using @ref subworkflowsteps "subworkflow steps", which are
    also used for logical branching in workflows, since Qorus workflows have otherwise a fixed structure.

    Workflows are made up of atomic @ref steps "steps" that represent the bulk of the processing logic to be applied
    to @ref staticdata "order data"; when all steps in a workflow order get a
    @ref OMQ::StatComplete "COMPLETE" status, the workflow order itself is also @ref OMQ::StatComplete "COMPLETE".

    Steps are defined by subclassing the appropriate @ref step_source "step class" in any supported language (using
    dynamic imports in %Python and Java, for example) and can be built with a no-code, low-code, or an "only code"
    approach in Qorus.

    Workflows and steps are versioned; new versions of steps and workflows can be deployed to a running system while
    the workflow itself is running, however workflows and steps can each have multiple versions of the same workflow
    and step active at the same time, and please note that workflow and step versioning affects processing and
    specifically recovery processing; see @ref wf_recoverability and @ref wfrecoverycompatibility for more
    information.

    @note
    - @ref finite_state_machines "Finite State Machines" have a flexible logical structure but are not stateful
      like workflows; the main advantage of using a Qorus workflow to automate a task is that a properly designed
      workflow can detect and recover from technical errors automatically, allowing your IT orchestration task to
      successfully complete potentially complex processing of order data in an unreliable IT integration environment.
    - @ref sla_tracking "SLAs" can be tracked anywhere in Qorus also manually using the
      @ref OMQ::UserApi::UserApi::postSlaEventSuccess() "UserApi::postSlaEventSuccess()" and
      @ref OMQ::UserApi::UserApi::postSlaEventError() "UserApi::postSlaEventError()" APIs from any supported language.

    @see @ref designimplworkflows

    @subsection devintro_hld_jobs Job Design

    @ref implementingjobs "Qorus jobs" are for tasks that run on a @ref job_schedule "schedule".  Each execution of
    the job results in a record (with a @ref OMQ::JS_Complete "COMPLETE" or @ref OMQ::JS_Error "ERROR" status, plus
    optional free-form data) which is searchable / retrievable from the @ref rest_api_page_latest "REST API" and
    visible in the system UI.

    @htmlonly
    <div class="image">
      <img src="Qorus-UI-Job-Result-List.png" alt="Job Result List in the UI" style="width:75%;">
      <div class="caption">Job Result List in the UI</div>
    </div>
    @endhtmlonly

    Jobs are suitable for polling tasks and more generally for activity that runs on a schedule.

    Jobs are defined by subclassing the @ref OMQ::UserApi::Job::QorusJob "QorusJob" class in any supported language
    (using dynamic imports in %Python and Java, for example) and can be built with a no-code, low-code, or an
    "only code" approach in Qorus.

    Only one version of a job can be active in Qorus at any other time.  A new version of a job can be deployed to a
    running Qorus instance at any time, however the old version of the job will be replaced by the new version.

    @see @ref implementingjobs

    @subsection devintro_hld_services Service Design

    @ref implementingservices "Qorus services" are a powerful and flexible integration object that can perform many
    tasks; services can implement server-side @ref OMQ::AbstractServiceRestHandler "REST",
    @ref OMQ::AbstractServiceSoapHandler "SOAP", @ref servicehttp "HTTP",
    @ref OMQ::AbstractServiceWebSocketHandler "WebSocket",
    @ref OMQ::AbstractServiceStream "stream handlers", or other protocol handlers; they can implement a data cache,
    event listeners, and more; services are the only Qorus integration object that can start its own
    @ref OMQ::UserApi::ServiceApi::startThread() "threads" as well.

    @htmlonly
    <div class="image">
      <img src="Qorus-UI-Service-Info.png" alt="Service Info in the UI" style="width:75%;">
      <div class="caption">Service Info in the UI</div>
    </div>
    @endhtmlonly

    Services are defined by subclassing the @ref OMQ::UserApi::Service::QorusService "QorusService" class in any
    supported language (using dynamic imports in %Python and Java, for example) and can be built with a no-code,
    low-code, or an "only code" approach in Qorus.

    Only one version of a service can be active in Qorus at any other time.  A new version of a service can be
    deployed to a running Qorus instance at any time, however the old version of the service will be replaced by the
    new version.

    @see @ref implementingservices
*/

/** @page develmodules Qore-Language Development Extension Modules

    @tableofcontents

    @ref develguide "Back to the Developer's Guide Table of Contents"

    %Qore-language Development extension modules can be made to support multiple interface types in the same module;
    so, for example, a single development extension module can support @ref develmodules_workflow_modules "workflows",
    @ref develmodules_service_modules "services", and develmodules_job_modules "jobs".

    In such cases, injected system APIs for other interface types are non-functional; so for example if a development
    extension module supports all interface types and is used in a workflow, in that case any access to injected job
    or service APIs will result in undefined behavior.

    @note Do not access non-contextual injected interface APIs; only use APIs according to the current interface
    context.

    @section develmodules_workflow_modules Qore-Language Workflow Extension Modules

    The @ref wf_modules "workflow modules" workflow option allows user modules to provide new base classes for
    @ref step_source "step classes" to allow reusable base classes for steps to be delivered along
    with Qorus.

    Workflow modules have the class-based workflow API injected into them when loaded in order to allow them to extend
    these classes and provide reusable high-level functionality to Qorus workflows.

    To use base classes provided by a workflow module as the base class of a @ref step_source "step class",
    use the @ref wf_modules "workflow modules" option in your workflow definition.

    The following is an example workflow module providing a subclass for the
    @ref OMQ::UserApi::Workflow::QorusNormalStep "QorusNormalStep" class:

    @par Workflow Module Example
    @code{.py}
# -*- mode: qore; indent-tabs-mode: nil -*-
# @file ExampleWorkflowModule.qm Qorus Integration Engine(R) example workflow module

%requires qore >= 1.12

%new-style
%require-types
%strict-args
%enable-all-warnings

module ExampleWorkflowModule {
    version = "1.0";
    desc = "workflow dev extension example module";
    author = "Qore Technologies <info@qoretechnologies.com>";
    url = "https://www.qoretechnologies.com";
}

public namespace ExampleWorkflowModule {
    # this class defines a primary() method and requires subclasses to define a primaryImpl() method
    public class ExampleNormalStep inherits QorusNormalStep {
        final primary() {
            logInfo("running %s::primary()", self.className());
            primaryImpl();
        }

        abstract primaryImpl();
    }
}
    @endcode

    @section develmodules_service_modules Qore-Language Service Extension Modules

    The @ref service_modules "service-modules" option allows user modules to provide new base classes for
    @ref service_source "service classes" to allow reusable base classes for services to be delivered along
    with Qorus.

    Service modules have the class-based service API injected into them when loaded in order to allow them to extend
    these classes and provide reusable high-level functionality to Qorus services.

    To use base classes provided by a service module as the base class of a
    @ref service_source "service class", use the @ref service_modules "service-modules" option in your service
    definition.

    The following is an example service module:

    @par Service Module Example
    @code{.py}
# -*- mode: qore; indent-tabs-mode: nil -*-
# @file ExampleServiceModule.qm Qorus Integration Engine example module

%requires qore >= 1.12

%new-style
%require-types
%strict-args
%enable-all-warnings

module ExampleServiceModule {
    version = "1.0";
    desc = "service dev extension example module";
    author = "Qore Technologies <info@qoretechnologies.com>";
    url = "https://www.qoretechnologies.com";
}

public namespace ExampleServiceModule {
    public class ExampleServiceModule inherits QorusService {
        # name: example
        # desc: method defined in the ExampleServiceModule module
        string example() {
            return exampleImpl();
        }

        # this method must be defined in child classes
        abstract string exampleImpl();
    }
}
    @endcode

    @section develmodules_job_modules Qore-Language Job Extension Modules

    The @ref job_modules option allows user modules to provide new base classes for
    @ref job_source "the job logic" to allow reusable base classes for jobs to be delivered along with Qorus.

    Job modules have the class-based job API injected into them when loaded in order to allow them to extend
    these classes and provide reusable high-level functionality to Qorus jobs.

    To use base classes provided by a job module as the base class of a
    @ref job_source "job class", use the @ref job_modules option in your job
    definition.

    The following is an example job module:

    @par Job Module Example
    @code{.py}
# -*- mode: qore; indent-tabs-mode: nil -*-
# @file ExampleJobModule.qm Qorus Integration Engine example module

%requires qore >= 1.12

%new-style
%require-types
%strict-args
%enable-all-warnings

module ExampleJobModule {
    version = "1.0";
    desc = "Job dev extension example module";
    author = "Qore Technologies <info@qoretechnologies.com>";
    url = "https://www.qoretechnologies.com";
}

public namespace ExampleJobModule {
    public class ExampleJobModule inherits QorusJob {
        final run() {
            logInfo("run method here");
            runImpl();
        }

        # this method must be defined in child classes
        abstract runImpl();
    }
}
    @endcode
*/

/** @page python_development Developing in Python

    @tableofcontents

    @ref develguide "Back to the Developer's Guide Table of Contents"

    @section python_development_intro Introduction to Python Development in Qorus

    Qorus supports native %Python development where code attributes of objects can be defined with code in %Python in
    addition to Java and %Qore.

    %Python integration with %Qore is implemented using the @ref pythonintro "python" module, which provides tight
    integration with both languages, including bi-directional dynamic and transparent imports of code and data
    between %Qore and Java and %Python as well.

    All Qorus APIs are available in %Python code in Qorus, however some APIs are automatically imported into %Python
    programs.  The main Qorus %Python APIs imported into %Python program containers as given in the following table.

    <b>%Python Module Names for Qorus APIs</b>
    |!Type|!%Python Module|!Description
    |module|@ref OMQ::UserApi::Job "job"|The Qorus job module as imported from the main Qorus %Qore-language job namespace
    |module|@ref OMQ "OMQ"|The main \c OMQ namespace for Qorus
    |module|@ref OMQ::UserApi::Service "svc"|The Qorus service module as imported from the main Qorus %Qore-language service namespace
    |module|@ref OMQ::UserApi::Workflow "wf"|The Qorus workflow module as imported from the main Qorus %Qore-language workflow namespace

    <b>%Python Interface API Class Names</b>
    |!Type|!%Python Class|!Description
    |class|@ref OMQ::UserApi::Job::JobApi "jobapi"|The %Python job API class based on the %Qore API
    |class|@ref OMQ::UserApi::Service::ServiceApi "svcapi"|The %Python service API class based on the %Qore API
    |class|@ref OMQ::UserApi::UserApi "UserApi"|The main %Python user API class based on the %Qore API
    |class|@ref OMQ::UserApi::Workflow::WorkflowApi "wfapi"|The %Python workflow API class based on the %Qore API

    @see
    - @ref python_qore_import
    - @ref python_java_import

    The %Python module path can be specified using the \c module_path tag in a @ref class_objects "class object"; see
    @ref python_development_module_path for more information and examples.

    @note Because Qorus's %Python integration uses the
    <a href="https://en.wikipedia.org/wiki/CPython">cpython implementation</a> which employs a Global Interpreter Lock
    (GIL) to serialize access to the %Python runtime, it's recommended to deploy CPU-intensive %Python-based interface
    code in interfaces running in separate processes; to do this, ensure that the \c remote flag in your interface is
    \c True; see:
    - @ref wf_remote
    - @ref service_remote
    - @ref job_remote
    .
    for more information

    @section python_development_module_path Python Module Handling in Qorus

    Generally, the %Python module path is set with the tag \c module_path when defining %Python code in Qorus.
    Furthermore, the recommended storage location for %Python modules is in <tt>$OMQ_DIR/user/python</tt>.

    The \c module_path tag accepts environment variables, and each element in the module path should be separated by a
    colon (\c ":"); see the following examples for more information.

    In @ref class_objects "class definitions" or any other object with %Python code, the %Python module_path is set
    with the YAML metadata tag \c module_path as in the following example:

    @par Example Module Path Tag Value
    @verbatim module_path: $OMQ_DIR/user/my-project/python:$OMQ_DIR/user/my-other-project/python @endverbatim

    @subsection python_development_default_module_path Python Default Module Path

    The following directories are automatically added to the %Python module path in Qorus:
    - <tt>$OMQ_DIR/user/python/site-packages</tt>
    - <tt>$OMQ_DIR/user/python/lib/python<i>&lt;ver&gt;</i>/site-packages</tt>

    In the last path above, <tt><i>&lt;ver&gt;</i></tt> is the %Python major and minor version; ex:
    <tt>$OMQ_DIR/user/python/lib/python3.8/site-packages</tt>

    @note Some python modules can only be initialized once in a process (ex: tensorflow); solutions depending on such
    modules must always run a separate process,

    @subsection python_development_module_packaging Python Module Dependency Packaging

    If a release should also package one or more %Python modules, the following options to
    @ref make-release "make-release" will be needed:
    - <tt>-a=</tt><i>ARG</i>: this provides the source %Python module directory that you want in the release
    - <tt>-b=</tt><i>ARG</i>: this provides the target directory name the files packaged with \c -a to be installed
      under <tt>$OMQ_DIR</tt> on the target server; the default location without this option is
      <tt>$OMQ_DIR/user/python/lib/python</tt><i>&lt;version&gt;</i><tt>/site-packages</tt>
      where <i>&lt;version&gt;</i> is the major and minor version of %Python used (ex: \c 3.8)

    @note %Python modules often contain OS- and CPU-specific shared libraries; take care that such Qorus packages are
    only installed on compatible target systems.

    @subsection python_development_module_conflicts Python Module Conflicts

    Some %Python modules do not support multiple interpreters in the same process; %Python code requiring these modules
    should always run in a separate process (see @ref wf_remote, @ref service_remote, and @ref job_remote).

    %The %Python error looks as follows:
    @verbatim
builtins.ImportError: Interpreter change detected - this module can only be loaded into one interpreter per process.
    @endverbatim

    @subsection python_development_qore_apis Accessing Qore APIs from Python

    Any %Qore module can be imported into %Python code using the special \c qore package provided by the
    @ref python_qoreloader_module "qoreloader module", which is used to dynamically load %Qore modules and make them
    available to the %Python import system on demand.

    An equivalent %Python module is created based on the main namespace detected for the loaded %Qore module.

    Aside from the %Qore modules and classses listed in the above section, any %Qore code available in an interface
    or imported from a %Qore module outside the main namespace can be automatically imported and accessed in %Python
    code using the special \c qore.__root__ module.

    The \c qore.__root__ module provides access to the root %Qore namespace and therefore all accessible declarations
    in %Qore.

    For example, if a %Qore class declared outside of any namespace (therefore finding itself in the root namespace)
    named \c MyClass is imported in a %Python interface, it can be accessed as follows:

    @par Example:
    @code{.py}
from qore.__root__ import MyClass

myclass = MyClass()
    @endcode

    The following is an example from a %Python test:
    @par Test Example:
    @code{.py}
from job import QorusJob
from qore.__root__ import QoreTest as qt
from qore.reflection import Type

class PythonObjectCacheTest(QorusJob):
    def run(self):
        try:
            UserApi.stopCapturingObjectsFromPython()
            UserApi.clearObjectCache()
            type0 = Type("string")
            qt.assertEq(0, UserApi.getObjectCacheSize())
            UserApi.startCapturingObjectsFromPython()
            type1 = Type("string")
            qt.assertEq(1, UserApi.getObjectCacheSize())
        finally:
            UserApi.stopCapturingObjectsFromPython()
    @endcode

    @section python_development_thread_stacks Python Thread Stacks

    The @ref pythonintro "python" module implements support for multiple %Python interpreters in Qorus programs along
    with multithreading by managing the %Python interpreter thread state manually.

    Additionally, the %Python recursion limit is also set automatically as a function of the current thread stack size;
    the default stack size for all Qorus programs can be set with the @ref stack-size option, and this option can
    furthermore be overridden in each interface by setting a value for the option on the interface directly.

    Stack size and %Python recursion limits are managed to avoid crashes due to stack exhaustion in %Qore and %Python
    code.

    Because setting a high default stack size value will cause far higher memory usage of the system as a whole, its
    recommended to set higher stack sizes by setting the appropriate value of the @ref stack-size option on each
    interface directly while also setting the \c remote flag to \c True on the interface, ensuring that it will be run
    in a dedicated process.  That way the higher stack size will be enforced only for the program that needs it.

    @note For processes running in @ref qorus-core "qorus-core" (i.e. where the \c remote flag is \c False), any
    locally-set @ref stack-size option value is ignored; in @ref qorus-core "qorus-core", only the global
    @ref stack-size option is used.

    @see
    - @ref stack-size
    - @ref wf_remote
    - @ref service_remote
    - @ref job_remote

    @section python_development_workflows Using Python in Qorus Workflows

    Qorus workflows can be defined in %Python by implementing a @ref step_source "step class" by subclassing one
    of the following step classes for the step:
    - @ref OMQ::UserApi::Workflow::QorusAsyncStep "wf.QorusAsyncStep"
    - @ref OMQ::UserApi::Workflow::QorusEventStep "wf.QorusEventStep"
    - @ref OMQ::UserApi::Workflow::QorusNormalStep "wf.QorusNormalStep"
    - @ref OMQ::UserApi::Workflow::QorusSubworkflowStep "wf.QorusSubworkflowStep"
    - @ref OMQ::UserApi::Workflow::QorusAsyncArrayStep "wf.QorusAsyncArrayStep"
    - @ref OMQ::UserApi::Workflow::QorusEventArrayStep "wf.QorusEventArrayStep"
    - @ref OMQ::UserApi::Workflow::QorusNormalArrayStep "wf.QorusNormalArrayStep"
    - @ref OMQ::UserApi::Workflow::QorusSubworkflowArrayStep "wf.QorusSubworkflowArrayStep"

    @par Example (python-simple-test-step1-v1.0.qstep.py):
    @code{.py}
from wf import QorusNormalStep

class PythonSimpleTestStep1(QorusNormalStep):
    def primary(self):
        UserApi.logInfo("hello from Python")
    @endcode

    @section python_development_services Using Python in Qorus Services

    Qorus services can be defined in %Python by subclassing the
    @ref OMQ::UserApi::Service::QorusService "svc.QorusService" class as in the following example:

    @par Example (python-simple-test-v1.0.qsd.py):
    @code{.py}
from svc import QorusService

class PythonSimpleTest(QorusService):
    def test(self, arg):
        UserApi.logInfo("Hello from Python")
        return arg
    @endcode

    @section python_development_jobs Using Python in Qorus Jobs

    Qorus jobs can be defined in %Python by implementing a @ref job_source "job class" and subclassing the
    @ref OMQ::UserApi::Job::QorusJob "job.QorusJob" class as in the following example.

    @par Example (python-simple-test-v1.0.qjob.py):
    @code{.py}
from job import QorusJob

class PythonSimpleTest(QorusJob):
    def run(self):
        UserApi.logInfo("Hello from Python")
    @endcode

    @section python_development_restrictions Restrictions on Python APIs

    %Python is not subject to sandboxing controls like %Qore code, so it's easier to do dangerous things with %Python.

    All normal %Python programming best practices should be followed when programming in %Python; make sure all
    resources are freed in \c finally blocks and so forth; Qorus can only manage %Qore resources, the %Python runtime
    manages all %Python resources normally.

    Do not do any of the following:
    - Generally you should not create %Python threads; any background functionality should be handled in a Qorus
      service; most Qorus APIs require the thread context to be set up properly before calling; only services support
      background threads; to start a thread in a service, use the
      @ref OMQ::UserApi::ServiceApi::startThread() "svcapi.startThread()" API
    - Do not make any calls that affect the current running process (ex: \c sys.exit(), \c _exit(), \c os._exit() and
      similar)

    @section python_development_qore_refs Qore Objects Imported Into Python Programs

    %Qore objects imported into %Python are subject to special reference handling.  Strong references to the %Qore
    objects are always managed in %Qorus, which means that when creating or acquiring a %Qore object in Qorus with
    %Python, the object will normally go out of scope after control returns to Qorus, meaning that the %Qore
    destructor is then run, so that %Qore's deterministic garbage collector can also be used in %Python code.

    For example, locks are released when
    @ref OMQ::UserApi::Workflow::DynamicDataHelper "wf.DynamicDataHelper" objects are collected after created
    from %Python step code.  The same applies to @ref OMQ::UserApi::Workflow::TempDataHelper "wf.TempDataHelper" and
    @ref OMQ::UserApi::Workflow::SensitiveDataHelper "wf.SensitiveDataHelper" objects.

    @see
    - @ref OMQ::UserApi::UserApi::startCapturingObjectsFromPython() "UserApi.startCapturingObjectsFromPython()"
    - @ref OMQ::UserApi::UserApi::startCapturingObjectsFromPython() "UserApi.stopCapturingObjectsFromPython()"

    @section python_development_client Using the Qorus Qore-Language Client API in Python

    Qorus's %Qore-language client API can be used as in the following example:
    @code{.py}
import qoreloader
from qore.QorusClientBase import Client

qrest = Client.QorusSystemRestHelper(None, True)
print("PID:", qrest.get("system/pid"))
    @endcode

    @section python_development_testing Writing Tests in Python for Qorus Interfaces

    To use Qorus (and generally any %Qore or Java) APIs in %Python, the \c qoreloader.so module is required.  This
    module can be found in \c $OMQ_DIR/python/qoreloader.so

    @see
    - @ref python_qoreloader_import_java
    - @ref python_qoreloader_import_qore

    The following classes can help to write tests written in %Python:
    - @ref QorusInterfaceTest::QorusWorkflowTest "QorusWorkflowTest"
    - @ref QorusInterfaceTest::QorusServiceTest "QorusServiceTest"
    - @ref QorusInterfaceTest::QorusJobTest "QorusJobTest"

    @par Example Workflow Test
    @code{.py}
import sys
import qoreloader
from qore.QorusInterfaceTest import QorusPassiveWorkflowTest, ExecSynchronousOrder

class MyTest(QorusPassiveWorkflowTest):
    def __init__(self):
        super(QorusPassiveWorkflowTest, self).__init__("SIMPLETEST", "1.0", sys.argv[1:])
        self.addTestCase("wf test", self.test1)
        self.main()

    def test1(self):
        self.exec(ExecSynchronousOrder({
            "name": "SIMPLETEST",
            "staticdata": {},
        }))

mytest = MyTest()
    @endcode

    @par Example Service Test
    @code{.py}
import sys
import qoreloader
from qore.QorusInterfaceTest import QorusServiceTest, CallService

class MyTest(QorusServiceTest):
    def __init__(self):
        super(QorusServiceTest, self).__init__("http-test", "user", sys.argv[1:])
        self.addTestCase("svc test", self.test1)
        self.main()

    def test1(self):
        call = CallService("http-test", "echo", 1)
        self.exec(call)
        self.assertEq(1, call.getResult()[0])

mytest = MyTest()
    @endcode

    @par Example Job Test
    @code{.py}
import sys
import qoreloader
from qore.QorusInterfaceTest import QorusJobTest, RunJob, RunJobResult
from qore.__root__ import OMQ

class MyTest(QorusJobTest):
    def __init__(self):
        super(QorusJobTest, self).__init__("test", sys.argv[1:])
        self.addTestCase("job test", self.test1)
        self.main()

    def test1(self):
        action = RunJob()
        self.exec(action);

        action = RunJobResult(OMQ.StatComplete)
        self.exec(action);

mytest = MyTest()
    @endcode
*/

/** @page javadevelopment Developing in Java

    @tableofcontents

    @ref develguide "Back to the Developer's Guide Table of Contents"

    @section javadevelopment_intro Introduction to Java Development in Qorus

    Qorus supports native Java development where code attributes of objects can be defined with code in Java in
    addition to %Qore.

    Java integration with %Qore is implemented using the @ref jniintro "jni" module, which provides tight
    integration with both languages, including dynamic imports into Java using bytecode generation of wrapper classes
    for deep language integration based on introspection / reflection of the imported language (%Qore or %Python) and
    runtime data conversions.

    All %Qore APIs are available in Java using dynamic imports using the special \c "qore" package.

    The main Qorus APIs are:
    -  @ref OMQ::UserApi::UserApi "UserApi": available as \c qore.OMQ.UserApi.UserApi
    -  @ref OMQ::UserApi::Workflow::WorkflowApi "WorkflowApi": available as \c qore.OMQ.UserApi.Workflow.WorkflowApi
    -  @ref OMQ::UserApi::Service::ServiceApi "ServiceApi": available as \c qore.OMQ.UserApi.Service.ServiceApi
    -  @ref OMQ::UserApi::Job::JobApi "JobApi": available as \c qore.OMQ.UserApi.Job.JobApi

    @see @ref jni_dynamic_import_in_java

    Java code is defined in class objects, and classpath entries for each object can be specified using the
    \c classpath tag in a @ref class_objects "class object"; see @ref javadevelopment_classpath for
    more information and examples.

    To use Java with %Qore, a compatible JDK must be installed on the Qorus server machine; see
    @ref install_java_sysreqs

    @section javadevelopment_classpath Java Classpath Handling in Qorus

    Generally, the Java classpath is set with the object tag \c classpath when defining Java code in Qorus.
    Furthermore, the recommended storage location for \c jar or \c class files is in <tt>$OMQ_DIR/user/jar</tt>.

    The \c classpath tag accepts environment variables, and each element in the classpath should be separated by a
    colon (\c ":"); see the following examples for more information.

    In @ref class_objects "class definitions", the Java classpath is set with the tag \c classpath as in the following
    example:

    @par Example Classpath Tag Value
    @verbatim classpath: $OMQ_DIR/user/jar/my-jar-1.jar:$OMQ_DIR/user/jar/my-jar-2.jar @endverbatim

    @subsection javadevelopment_compilation Compiling Java to Bytecode for Qorus

    Either @ref oload "oload" or the @ref org.qore.jni.compiler.QoreJavaCompiler "QoreJavaCompiler" must be used to
    compile Java source using dymamic imports to bytecode.

    Both @ref oload "oload" and @ref org.qore.jni.compiler.QoreJavaCompiler "QoreJavaCompiler" require the %Qore jni
    JAR file to be available as well:
    - <tt>$OMQ_DIR/jar/qore-jni.jar</tt>: provides the low-level API connecting %Qore and Java

    The standard Java compiler cannot be used if your Qorus code uses dynamic API imports.

    @section javadevelopment_workflows Using Java in Qorus Workflows

    Qorus workflows can be defined in Java by implementing a @ref step_source "step class" by subclassing one
    of the following step classes for the step:
    - @ref OMQ::UserApi::Workflow::QorusAsyncStep "QorusAsyncStep": available as
      \c qore.OMQ.UserApi.Workflow.QorusAsyncStep
    - @ref OMQ::UserApi::Workflow::QorusEventStep "QorusEventStep": available as
      \c qore.OMQ.UserApi.Workflow.QorusEventStep
    - @ref OMQ::UserApi::Workflow::QorusNormalStep "QorusNormalStep": available as
      \c qore.OMQ.UserApi.Workflow.QorusNormalStep
    - @ref OMQ::UserApi::Workflow::QorusSubworkflowStep "QorusSubworkflowStep": available as
      \c qore.OMQ.UserApi.Workflow.QorusSubworkflowStep
    - @ref OMQ::UserApi::Workflow::QorusAsyncArrayStep "QorusAsyncArrayStep": available as
      \c qore.OMQ.UserApi.Workflow.QorusAsyncArrayStep
    - @ref OMQ::UserApi::Workflow::QorusEventArrayStep "QorusEventArrayStep": available as
      \c qore.OMQ.UserApi.Workflow.QorusEventArrayStep
    - @ref OMQ::UserApi::Workflow::QorusNormalArrayStep "QorusNormalArrayStep": available as
      \c qore.OMQ.UserApi.Workflow.QorusNormalArrayStep
    - @ref OMQ::UserApi::Workflow::QorusSubworkflowArrayStep "QorusSubworkflowArrayStep": available as
      \c qore.OMQ.UserApi.Workflow.QorusSubworkflowArrayStep

    @section javadevelopment_services Using Java in Qorus Services

    Qorus services can be defined in Java by subclassing the
    @ref OMQ::UserApi::Service::QorusService "QorusService" class, available as
    \c qore.OMQ.UserApi.Service.QorusService in Java

    @section javadevelopment_jobs Using Java in Qorus Jobs

    Qorus jobs can be defined in Java by implementing a @ref job_source "job class" and subclassing the
    @ref OMQ::UserApi::Job::QorusJob "QorusJob" class (available as \c qore.OMQ.UserApi.Job.QorusJob in Java) as in
    the following example (note the use of the \c classpath tag to provide the classpath for jobs).

    @par Example Classpath Tag Value
    @verbatim classpath: $OMQ_DIR/user/jar/my-jar-1.jar:$OMQ_DIR/user/jar/my-jar-2.jar @endverbatim

    @par Example (java-example-job-v1.0.qjob.java):
    @code{.java}
package com.qoretechnologies.qorus.example;

import qore.OMQ.UserApi.Job.QorusJob;

class MyJavaExampleJob extends QorusJob throws Throwable {
    // the run method implements the job's logic
    public void run() throws Throwable {
        logInfo("test job info: %y", getInfo());
    }
}
    @endcode

    @section javadevelopment_restrictions Restrictions on Java APIs

    Java is not subject to sandboxing controls like %Qore code, so it's easier to do dangerous things with Java.

    All normal Java programming best practices should be followed when programming in Java; make sure all resources
    are freed in \c finally blocks and so forth; Qorus can only manage %Qore resources, the Java JVM manages all
    Java resources normally.

    Do not do any of the following:
    - Do not try to call any Qorus functionality from a Java thread not created by Qorus; most Qorus APIs require the
      thread context to be set up properly before calling; only services support background threads; to start a thread
      in a service, use the @ref OMQ::UserApi::ServiceApi::startThread() "qore.OMQ.UserApi.ServiceApi.startThread()"
      API
    - Generally you should not create Java threads; any backgrgound functionality should be handled in a Qorus service
    - Do not make any calls that affect the current running process (ex: \c System.exit(), \c Runtime.exit() or
      \c Runtime.halt() and similar)

    @section javadevelopment_qore_refs Java Classes Wrapping a Qore Object

    Java classes that wrap %Qore classes manage a weak reference to the %Qore object using the
    @ref org.qore.jni.QoreObjectBase "QoreObjectBase" class (in manually-generated wrapper classes also with the
    @ref org.qore.jni.QoreObjectWrapper "QoreObjectWrapper" class.  Strong references to the %Qore objects are always
    managed in %Qorus, which means that when creating or acquiring a %Qore object in Qorus with Java, the object will
    normally go out of scope after control returns to Qorus, meaning that the %Qore destructor is then run, so that
    %Qore's deterministic garbage collector can also be used in Java code.

    For example, locks are released when
    @ref OMQ::UserApi::Workflow::DynamicDataHelper "DynamicDataHelper" objects are collected after created
    from Java step code.  The same applies to
    @ref OMQ::UserApi::Workflow::TempDataHelper "TempDataHelper" or
    @ref OMQ::UserApi::Workflow::SensitiveDataHelper "SensitiveDataHelper" objects.

    @see
    - @ref OMQ::UserApi::UserApi::startCapturingObjectsFromJava() "qore.OMQ.UserApi.UserApi.startCapturingObjectsFromJava()"
    - @ref OMQ::UserApi::UserApi::stopCapturingObjectsFromJava() "qore.OMQ.UserApi.UserApi.stopCapturingObjectsFromJava()"

    @section javadevelopment_testing Writing Tests in Java for Qorus Interfaces

    The following %Qore classes should be dynamically imported to write tests written in Java:
    - @ref QorusInterfaceTest::QorusWorkflowTest "qoremod.QorusInterfaceTest.QorusWorkflowTest"
    - @ref QorusInterfaceTest::QorusServiceTest "qoremod.QorusInterfaceTest.QorusServiceTest"
    - @ref QorusInterfaceTest::QorusJobTest "qoremod.QorusInterfaceTest.QorusJobTest"

    @note \c qoremod allows %Qore's compiler and class loader to load %Qore modules dynamically and then import any
    symbols automatically using dynamic bytecode generation for wrapper classes and other definitions

    Examples of using dynamic APIs with Qorus:
    @verbatim
    # compile:
    qjavac -cp ${OMQ_DIR}/jar/qore-jni.jar MyTest.java
    # run:
    java -Djava.library.path=$OMQ_DIR/lib/libqore.so -cp ${OMQ_DIR}/jar/qore-jni.jar:. -Djava.system.class.loader=org.qore.jni.QoreURLClassLoader MyTest
    @endverbatim

    @see
    - @ref javadevelopment_qore_from_java for runtime dependency information for the %Qore library when using the Java Qorus
      client

    @par Example Workflow Test
    @code{.java}
import qoremod.QorusInterfaceTest.*;
import qoremod.QorusClientBase.*;
import qoremod.QorusClientBase.OMQ.$Constants;
import qoremod.QorusClientBase.OMQ.Client.QorusLocalRestHelper;

import org.qore.jni.Hash;
import org.qore.jni.QoreClosureMarkerImpl;

public class TestWorkflow extends QorusWorkflowTest {
    public static void main(String[] args) throws Throwable {
        new TestWorkflow(args);
    }

    public TestWorkflow(String[] args) throws Throwable {
        super("SIMPLETEST", "1.0", args);

        addTestCase("wf test", new QoreClosureMarkerImpl() {
            public Object call(Object... args) throws Throwable { testWorkflow(); return null; }
        });

        main();
    }

    @SuppressWarnings("unchecked")
    private void testWorkflow() throws Throwable {
        QorusLocalRestHelper qrest = new QorusLocalRestHelper();
        // turn off error generation for SIMPLETEST workflow
        qrest.put("workflows/SIMPLETEST/setOptions", new Hash() {
            {
                put("options", new Hash() {
                    {
                        put("no-errors", true);
                    }
                });
            }
        });

        Hash static_data = new Hash();
        Hash order_hash = new Hash();
        order_hash.put("staticdata", static_data);

        Hash result = execSynchronous(order_hash);
        assertEq(qoremod.QorusClientBase.OMQ.$Constants.StatComplete, result.get("status"));

        QorusClientAPI omqclient = new QorusClientAPI();
        Hash rv = (Hash)qrest.put("workflows/SIMPLETEST/setAutostart?autostart=1");
        try {
            exec(new CheckRunningWorkflow("SIMPLETEST"));

            // create a workflow order
            int wfiid = Integer.parseInt(omqclient.createWorkflowInstanceName("SIMPLETEST", "1.0", null, new Hash()));

            String name = getQorusInstanceName();
            assertTrue(name != null);

            // workaround for bug #2884:
            qrest.put("workflows/SIMPLETEST/reset");

            exec(new WaitForWfiid(wfiid));
            assertEq(qoremod.QorusClientBase.OMQ.$Constants.StatComplete, qrest.get("orders/" + wfiid + "/workflowstatus"));
        } finally {
            qrest.put("workflows/SIMPLETEST/setAutostart?autostart=0");
        }
    }
}
    @endcode

    @par Example Service Test
    @code{.java}
import qoremod.QorusInterfaceTest.*;
import qoremod.QorusClientBase.*;
import qoremod.QorusClientBase.OMQ.$Constants;
import qoremod.QorusClientBase.OMQ.Client.QorusSystemRestHelper;

import org.qore.jni.QoreClosureMarkerImpl;

public class TestService extends QorusServiceTest {
    public static void main(String[] args) throws Throwable {
        new TestService(args);
    }

    public TestService(String[] args) throws Throwable {
        super("http-test");

        addTestCase("svc test", new QoreClosureMarkerImpl() {
            public Object call(Object... args) throws Throwable { testService(); return null; }
        });
        main();
    }

    private void testService() throws Throwable {
        CallService call = new CallService("http-test", "echo", 1);
        exec(call);
        assertEq(1, ((Object[])call.getResult())[0]);
    }
}
    @endcode

    @par Example Job Test
    @code{.java}
import qoremod.QorusInterfaceTest.*;
import qoremod.QorusClientBase.*;
import qoremod.QorusClientBase.OMQ.$Constants;
import qoremod.QorusClientBase.OMQ.Client.QorusSystemRestHelper;

import org.qore.jni.QoreClosureMarkerImpl;

public class TestJob extends QorusJobTest {
    public static void main(String[] args) throws Throwable {
        new TestJob(args);
    }

    public TestJob(String[] args) throws Throwable {
        super("test");

        addTestCase("job test", new QoreClosureMarkerImpl() {
            public Object call(Object... args) throws Throwable { testJob(); return null; }
        });
        main();
    }

    private void testJob() throws Throwable {
        RunJob action = new RunJob();
        exec(action);

        action = new RunJobResult(qoremod.QorusClientBase.OMQ.$Constants.StatComplete);
        exec(action);
    }
}
    @endcode

    @section javadevelopment_client Qorus Java Client API

    The Qorus client API used in Java should be dynamically imported; ex:
    @verbatim
# compile:
qjavac -cp ${OMQ_DIR}/jar/qore-jni.jar MyQorusClient.java
# run:
java -Djava.library.path=$OMQ_DIR/lib/libqore.so -cp ${OMQ_DIR}/jar/qore-jni.jar:. -Djava.system.class.loader=org.qore.jni.QoreURLClassLoader MyQorusClient
    @endverbatim

    See the following section for runtime dependency information for the %Qore library when using the Java Qorus
    client.

    @section javadevelopment_qore_from_java Java APIs Based on Qore Functionality

    Java libraries for Qorus that depend on the native %Qore library and the @ref jniintro "jni" module to provide a
    wrapper for underlying %Qore functionality such as the Java client or test APIs must be run with either the Java
    runtime option \c java.library.path or the \c QORE_LIBRARY environment variable set to the location of the native
    %Qore library.

    @see @ref jni_from_java for more information
*/

/** @page designimplworkflows Designing and Implementing Workflows

    @tableofcontents

    @ref develguide "Back to the Developer's Guide Table of Contents"

    @section workflowdesign Designing Workflows

    Each Qorus interface (meaning workflows, services, and job) has a %Qore-language @ref Qore::Program "Program"
    object that manages its logic.  Qorus workflow logic can also be written in %Python and Java, however this is
    managed from the workflow's %Qore @ref Qore::Program "Program" object in any case.

    @note Workflow and step objects with code used to execute the workflow's logic are created once when the workflow
    is started, these objects are global across all workflow execution instances and workflow orders processed,
    therefore using class members to store state or information related workflow processing is generally inadvisable;
    please see @ref workflowdata for more information about Qorus APIs that provide workflow-order-specific data
    storage types that can be used to store and manage data specific to workflow orders being processed.

    @see
    - @ref workflowapi for more information on the workflow API including workflow @ref Qore::Program "Program"
      objects (@ref workflowprograms)
    - @ref workflowmodel for more information on Qorus workflows in general

    @subsection wfdesignoverview Overview

    All Qorus integration objects are described by YAML metadata produced by our IDE, which is available as a free
    (as in free of charge and also open source) extension to
    <a href="https://code.visualstudio.com">Microsoft Visual Studio Code</a>, a multi-platform editor from Microsoft.
    The Qorus extension is called
    <a href="https://marketplace.visualstudio.com/items?itemName=qoretechnologies.qorus-vscode">Qorus Developer Tools</a>
    and can be installed directly from Visual Studio Code.

    Workflows are made up a set of interdependent steps that each perform one traced and restartable action.  To
    design a workflow, a series of logical steps and their dependencies must be defined and then represented by a
    workflow definition file.  Once the high-level design for the workflow has been done, then the logic for the steps
    can be implemented and the workflow definition and the functions can be loaded into the database and executed.

    @image html Qorus-IDE-4-Workflow-Config.png "Workflows in the Qorus IDE" width=75%

    The following table defines the major elements used when designing and implementing an Qorus workflow.

    <b>Qorus Workflow Elements</b>
    |!Element|!Description
    |@ref stepdefs "Step"|The lowest element in a workflow, represents one traced and restartable action.  Each step \
        is defined by at least @ref primarystepcode "primary step code" containing the logic for the step, and \
        optionally other code attributes (such as @ref validationcode "validation code", run when the step is run in \
        error recovery mode, or @ref asyncbackendcode "asynchronous back-end code", required for \
        @ref asyncsteps "asynchronous steps") and other option attributes.
    |@ref wfdeffile "Workflow"|The workflow is the highest level element defining the logic as a set of steps and \
        inter-step dependencies, along with other attributes; workflows process workflow order data instances that \
        in turn contain the data and the status of processing (status of all steps).  A running workflow is called \
        a workflow execution instance and can be run either in batch mode (@ref OMQ::WM_Normal), batch recovery \
        mode (@ref OMQ::WM_Recovery), or synchronous mode.
    |@ref queue_objects "Queue"|@ref asyncsteps "Asynchronous steps" require a queue for linking the associated step \
        data created by the front-end logic with the @ref asyncbackendcode "back-end code".
    |@ref wf_sync_event_objects "Workflow Synchronization Events"|\
        @ref eventsteps "Workflow synchronization event steps" allow multiple workflow orders to synchronize their \
        processing based on a single event

    @image html Qorus-IDE-4-Workflow-Diagram.png "Workflow Step Dependencies in the Qorus IDE" width=75%

    @subsection wferrorhandling Workflow Error Handling and Recovery

    Qorus includes a framework for defining error information and raising errors.  If a workflow defines workflow-
    specific errors, @ref oload "oload" loads the error information the system database in the
    \c GLOBAL_WORKFLOW_ERRORS  and \c WORKFLOW_ERRORS tables (see @ref globalandworkflowerrors for more information).
    Each error definition a hash describing how the system should act when certain errors are raised when processing
    workflow order data.

    Workflows raise errors by throwing an unhandled exception or by calling one of the following APIs:
    - \b %Python: @ref OMQ::UserApi::Workflow::WorkflowApi::stepError() "wfapi.stepError()"
    - \b Java: @ref OMQ::UserApi::Workflow::WorkflowApi::stepError() "WorkflowApi.stepError()"
    - \b %Qore: @ref OMQ::UserApi::Workflow::WorkflowApi::stepError() "WorkflowApi::stepError()"

    In the case an exception is thrown, for %Python exceptions, the exception \c err value is the exception class name
    (\c "socket.timeout"); for Java exceptions, the exception full class name (ex: \c "javax.xml.soap.SOAPException")
    is used as the error name; for %Qore exceptions, the exception \c err code is used as the error name;
    the system will then use the error name as the hash key to look up error information to handle the error.

    @note An error will only affect the steps status if it has a severity of @ref OMQ::ES_Major or
    @ref OMQ::ES_Fatal, all other severity codes will cause the error to be logged but the status of the step to be
    unaffected.

    To allow a workflow to recover gracefully from an error, implement @ref validationcode "validation code" for each
    step.  @ref validationcode "Validation code" allows workflows to recover gracefully from errors such as lost
    request or response messages or temporary communication failures without requiring manual intervention.

    @subsubsection globalandworkflowerrors Global and Workflow-Specific Error Definitions

    By default, error definitions are global.  A global definition is a workflow error definition that applies to all
    workflows.  Workflow-specific error definitions apply only to a particular workflow configuration.

    There are two ways to create workflow-specific error definitions:
    - create the error definitions in an error definition file with the IDE
    - create the workflow-specific error manually with an API call (ex: @ref omq.system.update-workflow-error())

    The last point above implies that if two or more workflows define the same error with different attributes (but
    leave the error's \c "level" option either unset or assigned to the default: @ref OMQ::ErrLevelAuto), the first
    error will be a global error, and each time the other workflows define the error with a different set of
    attributes, those new errors will be workflow-specific error definitions.

    @note Workflow error configurations are considered to be @ref managed_by_operations "managed by operations", which
    means that once a workflow has been loaded into Qorus, if its error configuration is updated with the API, then
    those API-driven changes are persistent and will not be overwritten by subsequent loads of the workflow by
    @ref oload "oload".

    @subsubsection defaulterrordefinitions Default Global Workflow Error Definitions

    Qorus includes default error definitions for common technical errors that should normally result in a workflow
    order instance retry and also template errors that can be re-used in workflows as needed.

    To get a complete list of error definitions, issue the following command from the command line:
    @verbatim qdp omq/workflow_errors search @endverbatim

    See the Qorus web UI's "Global Errors" page or the detail page for each workflow to see how error's are configured
    in Qorus as errors may have been redefined or overridden after the initial installation.

    @note it is recommended that the above errors not be deleted but rather modified, since any new Qorus upgrade will
    re-write any missing error definitions to the \c GLOBAL_WORKFLOW_ERRORS table

    @subsection wfrecoverycompatibility Workflow Upgrades, Bug Fixes, and Recovery Compatibility

    Workflows and steps, along with almost every other object in the Qorus schema, are versioned.  When a new version
    of a workflow is released, either due to a logic upgrade or a bug fix, keep in mind that workflows can only
    recover data that has been processed by the same version of that workflow.

    @par Note: Keep Recovery Compatibility in Mind when Planning Workflow Updates
    Workflows with another workflowid (name and version) cannot recover data from a workflow with another workflowid.
    Also step changes (new stepid  name and version of the step) will impact workflow recoveries. Keep these facts in
    mind when planning workflow updates and plan accordingly.\n\n
    That is; \c EXAMPLE-WORKFLOW \c 1.1 cannot recover data processed by \c EXAMPLE-WORKFLOW \c 1.0.  Furthermore,
    \c example-step \c 1.1 cannot recover data processed by \c example-step \c 1.0.

    When it is necessary to maintain recovery compatibility in a workflow update, then it will be necessary to
    redefine steps and workflows with the same version name and number.  In these cases, the patch attribute of the
    object should be updated to reflect the change.

    Also keep in mind that new steps added to a workflow will be executed for data that is being recovered even with
    data that was initially processed by a previous version of the workflow that did not include the new step in its
    definition.

    If a step is removed from a workflow and data must be recovered where that step has a @ref OMQ::StatRetry status,
    then that data cannot be recovered by a definition of the workflow that no longer includes that step.

    These points should be considered carefully when planning workflow updates.

    Sometimes it may be necessary to release two or more versions of a workflow when changes must be made; for example
    one version to make a bug fix in an existing version, and a new version with additional or removed steps also
    including the bug fix.

    @subsection workflowdata Workflows and Order Data

    Because a running workflow execution instance can be working on several different orders at once in different
    threads, accessing workflow data is performed through API calls in order to guarantee that the workflow's program
    code accesses only the correct data for the current order being processed at all times.

    Accessing and processing data is done using the Qorus API as outlined in this section; these APIs set up the data
    context for each thread so that the correct data is accessed.

    @note Global variables are not allowed in workflow program objects; for a functional equivalent to global
    variables, see @ref instancedata "Workflow Execution Instance Data"

    @subsubsection staticdata Workflow Static Order Data

    Static data represents the workflow order data being processed.  Workflow static order data cannot be updated or
    deleted by the Qorus workflow API; it is read-only data representing the order data to be processed or fulfilled
    by the workflow.

    APIs:
    - \b %Python: @ref OMQ::UserApi::Workflow::WorkflowApi::getStaticData() "wfapi.getStaticData()"
    - \b Java: @ref OMQ::UserApi::Workflow::WorkflowApi::getStaticData() "WorkflowApi.getStaticData()"
    - \b %Qore: @ref OMQ::UserApi::Workflow::WorkflowApi::getStaticData() "WorkflowApi::getStaticData()"

    The information returned by the above function corresponds to the deserialized contents of the field
    \c ORDER_INSTANCE.STATICDATA.

    @note The workflow @ref wf_static_data_type "static data type" can also be defined and restricted; see
    @ref wf_static_data_type for more information

    @subsubsection dynamicdata Workflow Dynamic Order Data

    Dynamic data is associated with the workflow order data instance being processed, but it can be updated and is
    persistent.  Any changes made to dynamic data will be committed to the database before the update method returns,
    therefore any changes will be available in the future, even in the case of errors and later recovery processing.

    Dynamic data is appropriate for storing identifiers and references generated during order processing that are
    needed in subsequent steps, for example.

    %Python API support:
    - \b %Python: @ref OMQ::UserApi::Workflow::WorkflowApi::getDynamicData() "wfapi.getDynamicData()"
    - \b %Python: @ref OMQ::UserApi::Workflow::WorkflowApi::deleteDynamicDataKey() "wfapi.deleteDynamicDataKey()"
    - \b %Python: @ref OMQ::UserApi::Workflow::WorkflowApi::updateDynamicData() "wfapi.updateDynamicData()"
    - \b %Python: @ref OMQ::UserApi::Workflow::DynamicDataHelper "DynamicDataHelper" class

    Java API support:
    - \b Java: @ref OMQ::UserApi::Workflow::WorkflowApi::getDynamicData() "WorkflowApi.getDynamicData()"
    - \b Java: @ref OMQ::UserApi::Workflow::WorkflowApi::deleteDynamicDataKey() "WorkflowApi.deleteDynamicDataKey()"
    - \b Java: @ref OMQ::UserApi::Workflow::WorkflowApi::updateDynamicData() "WorkflowApi.updateDynamicData()"
    - \b Java: @ref OMQ::UserApi::Workflow::DynamicDataHelper "DynamicDataHelper" class

    %Qore API support:
    - \b %Qore: @ref OMQ::UserApi::Workflow::WorkflowApi::getDynamicData() "WorkflowApi::getDynamicData()"
    - \b %Qore: @ref OMQ::UserApi::Workflow::WorkflowApi::deleteDynamicDataKey() "WorkflowApi::deleteDynamicDataKey()"
    - \b %Qore: @ref OMQ::UserApi::Workflow::WorkflowApi::updateDynamicData() "WorkflowApi::updateDynamicData()"
    - \b %Qore: @ref OMQ::UserApi::Workflow::DynamicDataHelper "DynamicDataHelper" class

    @see @ref stepdata

    @subsubsection stepdata Workflow Dynamic Step Data

    Dynamic step data, like @ref dynamicdata "dynamic order data" is associated with the workflow order data instance
    and also the current step being processed, additionally it can be updated and is persistent like
    @ref dynamicdata "dynamic order data".  Any changes made to dynamic step data will be committed to the database
    before the update method returns, therefore any changes will be available in the future, even in the case of
    errors and later recovery processing.

    Dynamic step data is appropriate for storing information specific to a particular step, particularly user-driven
    form data with @ref asyncsteps "asynchronous steps" with the @ref step_user_interaction "user-interaction" flag enabled.

    %Python API support:
    - \b %Python: @ref OMQ::UserApi::Workflow::QorusStepBase::getStepData() "wf.QorusStepBase.getStepData()"
    - \b %Python: @ref OMQ::UserApi::Workflow::QorusStepBase::deleteStepDataKey() "wf.QorusStepBase.deleteStepDataKey()"
    - \b %Python: @ref OMQ::UserApi::Workflow::QorusStepBase::updateStepData() "wf.QorusStepBase.updateStepData()"
    - \b %Python: @ref OMQ::UserApi::Workflow::StepDataHelper "wf.StepDataHelper" class

    Java API support:
    - \b Java: @ref OMQ::UserApi::Workflow::QorusStepBase::getStepData() "QorusStepBase.getStepData()"
    - \b Java: @ref OMQ::UserApi::Workflow::QorusStepBase::deleteStepDataKey() "QorusStepBase.deleteStepDataKey()"
    - \b Java: @ref OMQ::UserApi::Workflow::QorusStepBase::updateStepData() "QorusStepBase.updateStepData()"
    - \b Java: @ref OMQ::UserApi::Workflow::StepDataHelper "StepDataHelper" class

    %Qore API support:
    - \b %Qore: @ref OMQ::UserApi::Workflow::QorusStepBase::getStepData() "QorusStepBase::getStepData()"
    - \b %Qore: @ref OMQ::UserApi::Workflow::QorusStepBase::deleteStepDataKey() "QorusStepBase::deleteStepDataKey()"
    - \b %Qore: @ref OMQ::UserApi::Workflow::QorusStepBase::updateStepData() "QorusStepBase::updateStepData()"
    - \b %Qore: @ref OMQ::UserApi::Workflow::StepDataHelper "StepDataHelper" class

    REST API support:
    - @ref rest_api_POST_v3_workflows__id_or_name__lockUserInteractionStep
    - @ref rest_api_POST_v3_orders__id__lockUserInteractionStep
    - @ref rest_api_PUT_v3_orders__id__stepData

    @see
    - @ref dynamicdata

    @subsubsection tempdata Workflow Temporary Order Data

    Qorus maintains a hash of temporary data associated to the workflow order data instance being processed.  This hash
    can be updated, but it is not persistent, therefore this hash is suitable for temporary data storage only.

    This data is lost every time Qorus detaches (i.e. temporarily or permanently stops processing a workflow order data
    instance, for example, due to an \c ERROR status and purges the data from the workflow data cache) from a workflow
    order data instance.

    Because temporary data is deleted every time Qorus detaches from a workflow order data instance, it can only be
    reliably set in the @ref attach "attach logic".

    %Python API support:
    - \b %Python: @ref OMQ::UserApi::Workflow::WorkflowApi::getTempData() "wfapi.getTempData()"
    - \b %Python: @ref OMQ::UserApi::Workflow::WorkflowApi::deleteTempDataKey() "wfapi.deleteTempDataKey()"
    - \b %Python: @ref OMQ::UserApi::Workflow::WorkflowApi::updateTempData() "wfapi.updateTempData()"
    - \b %Python: @ref OMQ::UserApi::Workflow::TempDataHelper "wf.TempDataHelper" class

    Java API support:
    - \b Java: @ref OMQ::UserApi::Workflow::WorkflowApi::getTempData() "WorkflowApi.getTempData()"
    - \b Java: @ref OMQ::UserApi::Workflow::WorkflowApi::deleteTempDataKey() "WorkflowApi.deleteTempDataKey()"
    - \b Java: @ref OMQ::UserApi::Workflow::WorkflowApi::updateTempData() "WorkflowApi.updateTempData()"
    - \b Java: @ref OMQ::UserApi::Workflow::TempDataHelper "TempDataHelper" class

    %Qore API support:
    - \b %Qore: @ref OMQ::UserApi::Workflow::WorkflowApi::getTempData() "WorkflowApi::getTempData()"
    - \b %Qore: @ref OMQ::UserApi::Workflow::WorkflowApi::deleteTempDataKey() "WorkflowApi::deleteTempDataKey()"
    - \b %Qore: @ref OMQ::UserApi::Workflow::WorkflowApi::updateTempData() "WorkflowApi::updateTempData()"
    - \b %Qore: @ref OMQ::UserApi::Workflow::TempDataHelper "TempDataHelper" class

    @subsubsection order_sensitive_data Workflow Sensitive Order Data

    Qorus was designed to allow workflow sensitive order data to be processed while avoiding inadvertent disclosure
    of this data to unauthorized persons.

    Workflow sensitive order data must be processed separately for each data subject stored against the workflow order,
    this is because each data subject's sensitive data can be queried, updated, or deleted separately across all
    workflow orders in the system (both in the system schema and any archiving schema).

    Workflow order sensitive data is stored separately for each data subject against the workflow order using two identifiers
    as follows:
    - \c skey: the sensitive data key type (not treated as sensitive itself, ex: \c "tax_id", \c "social_insurance_nr", \c "ssn", etc)
    - \c svalue: the sensitive data key value, which is also treated as sensitive itself

    The following image provides an overview of a concrete example of sensitive data stored against a workflow order storing
    sensitive data for at least two data subjects with tax_ids \c "984.302192.AF" and \c "739.323.714.BR":

    @image html "workflow_order_example.png" "Qorus Integration Engine Workflow Order Sensitive Data Example"

    The \c svalue value, being sensitive itself, should not be stored in @ref staticdata "static",
    @ref dynamicdata "dynamic" data, or @ref stepdata "step dynamic" data.
    To reference sensitive data from within non-sensitive data, an alias can be used, which is a unique identifier within a
    workflow order that can be used to uniquely identify sensitive data for a single data subject.  Sensitive data aliases are only
    usable in internal sensitive data APIs.

    For example, if a workflow order consists of non-sensitive order information along with a natural person's name and address (which
    is sensitive) for each order, then the sensitive data alias could simply be the list index (ex: \c "0", \c "1", ...).

    The following internal workflow APIs provide sensitive data support:

    %Python APIs:
    - \b %Python: @ref OMQ::UserApi::Workflow::WorkflowApi::getSensitiveData() "wfapi.getSensitiveData()"
    - \b %Python: @ref OMQ::UserApi::Workflow::WorkflowApi::getSensitiveDataAliases() "wfapi.getSensitiveDataAliases()"
    - \b %Python: @ref OMQ::UserApi::Workflow::WorkflowApi::getSensitiveDataFromAlias() "wfapi.getSensitiveDataFromAlias()"
    - \b %Python: @ref OMQ::UserApi::Workflow::WorkflowApi::getSensitiveDataKeyValues() "wfapi.getSensitiveDataKeyValues()"
    - \b %Python: @ref OMQ::UserApi::Workflow::WorkflowApi::deleteSensitiveData() "wfapi.deleteSensitiveData()"
    - \b %Python: @ref OMQ::UserApi::Workflow::WorkflowApi::deleteSensitiveDataKey() "wfapi.deleteSensitiveDataKey()"
    - \b %Python: @ref OMQ::UserApi::Workflow::WorkflowApi::updateSensitiveData() "wfapi.updateSensitiveData()"
    - \b %Python: @ref OMQ::UserApi::Workflow::WorkflowApi::updateSensitiveDataFromAlias() "wfapi.updateSensitiveDataFromAlias()"
    - \b %Python: @ref OMQ::UserApi::Workflow::SensitiveDataHelper "wf.SensitiveDataHelper" class

    Java APIs:
    - \b Java: @ref OMQ::UserApi::Workflow::WorkflowApi::getSensitiveData() "WorkflowApi.getSensitiveData()"
    - \b Java: @ref OMQ::UserApi::Workflow::WorkflowApi::getSensitiveDataAliases() "WorkflowApi.getSensitiveDataAliases()"
    - \b Java: @ref OMQ::UserApi::Workflow::WorkflowApi::getSensitiveDataFromAlias() "WorkflowApi.getSensitiveDataFromAlias()"
    - \b Java: @ref OMQ::UserApi::Workflow::WorkflowApi::getSensitiveDataKeyValues() "WorkflowApi.getSensitiveDataKeyValues()"
    - \b Java: @ref OMQ::UserApi::Workflow::WorkflowApi::deleteSensitiveData() "WorkflowApi.deleteSensitiveData()"
    - \b Java: @ref OMQ::UserApi::Workflow::WorkflowApi::deleteSensitiveDataKey() "WorkflowApi.deleteSensitiveDataKey()"
    - \b Java: @ref OMQ::UserApi::Workflow::WorkflowApi::updateSensitiveData() "WorkflowApi.updateSensitiveData()"
    - \b Java: @ref OMQ::UserApi::Workflow::WorkflowApi::updateSensitiveDataFromAlias() "WorkflowApi.updateSensitiveDataFromAlias()"
    - \b Java: @ref OMQ::UserApi::Workflow::SensitiveDataHelper "SensitiveDataHelper" class

    %Qore APIs:
    - \b %Qore: @ref OMQ::UserApi::Workflow::WorkflowApi::getSensitiveData() "WorkflowApi::getSensitiveData()"
    - \b %Qore: @ref OMQ::UserApi::Workflow::WorkflowApi::getSensitiveDataAliases() "WorkflowApi::getSensitiveDataAliases()"
    - \b %Qore: @ref OMQ::UserApi::Workflow::WorkflowApi::getSensitiveDataFromAlias() "WorkflowApi::getSensitiveDataFromAlias()"
    - \b %Qore: @ref OMQ::UserApi::Workflow::WorkflowApi::getSensitiveDataKeyValues() "WorkflowApi::getSensitiveDataKeyValues()"
    - \b %Qore: @ref OMQ::UserApi::Workflow::WorkflowApi::deleteSensitiveData() "WorkflowApi::deleteSensitiveData()"
    - \b %Qore: @ref OMQ::UserApi::Workflow::WorkflowApi::deleteSensitiveDataKey() "WorkflowApi::deleteSensitiveDataKey()"
    - \b %Qore: @ref OMQ::UserApi::Workflow::WorkflowApi::updateSensitiveData() "WorkflowApi::updateSensitiveData()"
    - \b %Qore: @ref OMQ::UserApi::Workflow::WorkflowApi::updateSensitiveDataFromAlias() "WorkflowApi::updateSensitiveDataFromAlias()"
    - \b %Qore: @ref OMQ::UserApi::Workflow::SensitiveDataHelper "SensitiveDataHelper" class

    @see
    - @ref sensitive_data in the System Reference Manual
    - @ref ops_sensitive_data in the Operations Manual

    @subsubsection instancedata Workflow Execution Instance Data

    Workflow execution instance data is stored in a hash maintained by the system.  This data is local to the running
    workflow execution instance pseudo-process and persists until the workflow execution instance terminates.

    Any changes made to this data will persist within the running workflow execution instance (pseudo-process)
    independently of the workflow order data processed.

    Because of this, workflow execution instance data is a substitute for global variables in a workflow program.
    Workflow programs are shared between all running workflow execution instances of that same type (sharing the same
    name and version and the same workflowid); global variables are not allowed because it is considered unsafe for
    workflow execution instances to share any common state.  If your workflows do need to share some data between
    execution instances, implement a Qorus service to provide this functionality instead.

    Workflow execution instance data will be set in the @ref onetimeinit "onetimeinit code" (initializing resources
    for the workflow execution instance), and read by the rest of the workflow.

    %Python methods:
    - \b %Python: @ref OMQ::UserApi::Workflow::WorkflowApi::getInstanceData() "wfapi.getInstanceData()"
    - \b %Python: @ref OMQ::UserApi::Workflow::WorkflowApi::deleteInstanceDataKey() "wfapi.deleteInstanceDataKey()"
    - \b %Python: @ref OMQ::UserApi::Workflow::WorkflowApi::updateInstanceData() "wfapi.updateInstanceData()"

    Java methods:
    - \b Java: @ref OMQ::UserApi::Workflow::WorkflowApi::getInstanceData() "WorkflowApi.getInstanceData()"
    - \b Java: @ref OMQ::UserApi::Workflow::WorkflowApi::deleteInstanceDataKey() "WorkflowApi.deleteInstanceDataKey()"
    - \b Java: @ref OMQ::UserApi::Workflow::WorkflowApi::updateInstanceData() "WorkflowApi.updateInstanceData()"

    %Qore methods:
    - \b %Qore: @ref OMQ::UserApi::Workflow::WorkflowApi::getInstanceData() "WorkflowApi::getInstanceData()"
    - \b %Qore: @ref OMQ::UserApi::Workflow::WorkflowApi::deleteInstanceDataKey() "WorkflowApi::deleteInstanceDataKey()"
    - \b %Qore: @ref OMQ::UserApi::Workflow::WorkflowApi::updateInstanceData() "WorkflowApi::updateInstanceData()"

    @subsection workflowinfo Workflow Information

    @subsubsection workflowmetadata Workflow Metadata

    The following properties of the workflow metadata can be returned by the following APIs:
    - \b %Python: @ref OMQ::UserApi::Workflow::WorkflowApi::getWorkflowMetadata() "wfapi.getWorkflowMetadata()"
    - \b Java: @ref OMQ::UserApi::Workflow::WorkflowApi::getWorkflowMetadata() "WorkflowApi.getWorkflowMetadata()"
    - \b %Qore: @ref OMQ::UserApi::Workflow::WorkflowApi::getWorkflowMetadata() "WorkflowApi::getWorkflowMetadata()"

    <b>Workflow Metadata</b>
    |!Key|!Description
    |\c name|name of the workflow
    |\c version|version of the workflow
    |\c patch|The patch attribute of the workflow
    |\c workflowid|ID of the current workflow (metadata ID)
    |\c remote|a boolean value giving the remote status of the workflow (if it is running as an independent process or not; see @ref wf_remote "the remote flag")
    |\c description|The description of the workflow
    |\c cached|The date and time the workflow metadata was read and cached from the database
    |\c attach_func_instanceid|The function instance ID of the @ref attach "attach function" for the workflow
    |\c detach_func_instanceid|The function instance ID of the @ref detach "detach function" for the workflow
    |\c onetimeinit_func_instanceid|The function instance ID of the @ref onetimeinit "onetimeinit function" for the workflow
    |\c errhandler_func_instanceid|The function instance ID of the @ref error_handler "error handler function" for the workflow
    |\c keylist|A list of valid @ref wf_keylist "order keys" for the workflow
    |\c errors|The error definitions for the workflow
    |\c options|A hash of valid workflow options, key = option, value = description

    @subsubsection workflowexecutioninstanceinfo Running Workflow Execution Instance Properties

    Properties of the current running workflow execution instance can be retrieved via the following APIs:
    - \b %Python: @ref OMQ::UserApi::Workflow::WorkflowApi::getWorkflowInstanceData() "wfapi.getWorkflowInstanceData()"
    - \b Java: @ref OMQ::UserApi::Workflow::WorkflowApi::getWorkflowInstanceData() "WorkflowApi.getWorkflowInstanceData()"
    - \b %Qore: @ref OMQ::UserApi::Workflow::WorkflowApi::getWorkflowInstanceData() "WorkflowApi::getWorkflowInstanceData()"

    <b>Running Workflow Execution Instance Properties</b>
    |!Key|!Description
    |\c dbstatus|the status of the workflow order in the database (for the current status, see the \c status key, see @ref StatusDescriptions for possible values); this will normally be @ref OMQ::StatInProgress, unless called from the @ref detach (first available in Qorus 2.6.2)
    |\c external_order_instanceid|The external order instance ID saved against the order, if any
    |\c execid|the execution instance ID (workflow pseudo-process ID, first available in Qorus 2.6.0.3)
    |\c initstatus|the status of the workflow when it was cached (before it was updated to OMQ::StatInProgress, see @ref StatusDescriptions for possible values); note that synchronous workflow orders are created with status @ref OMQ::StatInProgress, so \c initstatus should always be @ref OMQ::StatInProgress for synchronous orders
    |\c instancemode|The mode the workflow execution instance process is running in (@ref OMQ::WM_Normal or @ref OMQ::WM_Recovery)
    |\c mode|The mode the current thread is running in (@ref OMQ::WM_Normal or @ref OMQ::WM_Recovery)
    |\c remote|a boolean value giving the remote status of the workflow (if it is running as an independent process or not; see @ref wf_remote)
    |\c sync|@ref True if the workflow execution instance is synchronous, @ref False if not
    |\c name|name of the workflow
    |\c parent_workflow_instanceid|The workflow order data instance ID of the parent workflow if the current workflow order is a subworkflow, NOTHING if not
    |\c priority|The priority (0 - 999) of the workflow order data instance (first available in Qorus 2.6.0.3)
    |\c started|The date/time the workflow order data instance was created (first available in Qorus 2.6.0.3)
    |\c status|The current status of the workflow order data instance (see @ref StatusDescriptions for possible values); this will normally be @ref OMQ::StatInProgress; first available in Qorus 2.6.2)
    |\c version|version of the workflow
    |\c workflowid|ID of the current workflow (metadata ID)
    |\c workflow_instanceid|The current workflow order data instance ID being processed

    @subsection wf_recoverability Workflow Error Recoverability

    Qorus workflows should always target comprehensive error recoverability, so that workflows can handle any
    recoverable error by design, meaning that, assuming that the input data are correct and that end systems and
    network transports are available (or become available within the retry period(s) defined by the workflow and
    server settings), the workflow will complete successfully even in case of errors.

    The following sections describe the design and implementation constraints for a workflow to meet these
    requirements, the common errors that must be dealt with, and how to deal with them.

    @subsubsection wf_implconstraints Workflow Design and Implementation Constraints

    The following are some examples of conditions that must be addressed for a workflow to meet comprehensive error
    recoverability requirements:

    @par Requirement 1: Steps Perform One Atomic Action
    Steps must be designed to perform a single atomic action (can be multiple actions that occur in sequence and are
    only ever executed together, even in the case of errors).  Otherwise the workflow cannot be recovered properly in
    the case of errors.\n\n
    If a step performs more than one action, and one of the actions fails, then the Qorus system cannot ensure that
    the workflow will be restarted at the point of failure when recovering, because the step is the lowest restartable
    element in a workflow.  In this case, adjust your design by splitting each atomic action into a separate step.

    @par Requirement 2: End Systems Must Remain Consistent
    It must not be possible for conditions out of Qorus's control to cause inconsistencies in end systems such that no
    further action can be taken on the workflow's data and the workflow stalls.\n\n
    For example, non-repeatable functions in end systems called by Qorus workflows must be implemented so that they
    either succeed or are rolled back completely; actions must be atomic. If a condition out of Qorus's control (such
    as a power failure on a server hosting an application while the application is executing a function called by
    Qorus) can cause an application to reach an inconsistent state where further actions cannot be taken on the data in
    question, then that state will have to be corrected before the workflow can continue.  To avoid this, all actions
    in end systems must be atomic.

    @anchor req3
    @par Requirement 3: Non-Repeatable Steps Must Include Validation
    Always include @ref validationcode "validation code" for steps that cannot be repeated.  Either a transport layer
    failure, application failure, or Qorus failure could cause the step to be recovered when the action was actually
    successfully completed in the end system.\n\n
    For steps using network communication that triggers an action in a remote system that cannot be repeated for the
    same input data, in the case of lack of answer by the end system, the possibility must be considered that the
    action was executed, but the response message was lost (for example, due to network problems).  In this case, the
    step should implement @ref validationcode "validation code" to check the end system if the message was successful
    or not.

    @par Requirement 4: Check the Validity of Input Data
    Always check the validity/consistency of input data if inconsistent data is a possibility, and inconsistent data
    can cause problems in end systems or the proper execution of the workflow.\n\n
    Inconsistent input data can lead to a situation where a workflow stalls in the middle of execution and can never
    be recovered.\n\n
    For example, if inconsistent data are only detected in step five of a ten step workflow, and changes are made in
    four applications before step five, from a data consistency point of view, in the worst case this could lead to
    the necessity of manually cleaning up data from the first four systems to back out the workflow's actions, and in
    the best case represents a probable waste of resources (disk space, etc).\n\n
    To avoid this, all necessary measures must be taken to ensure the validity of the data before starting the
    workflow's logic that writes the data to end systems.\n\n
    This can be done in the @ref attach "attach logic" (an attribute of the workflow object), for example, or, if the
    validity of the data does not depend on changing states in other applications, in the first step of the workflow.

    @par Requirement 5: All Errors Must Be Recognized and Flagged
    All responses from end systems must be checked for all possible error conditions.\n\n
    This point is common sense; in order to avoid the situation where a workflow has an error status, but Qorus
    reports @ref OMQ::StatComplete, all errors must be recognized and flagged.  Generally, Qorus workflows should
    handle errors as intelligently as possible.  Every error that could occur in a workflow that requires an automatic
    retry must be defined with a custom error definition, and the system behavior should be
    carefully considered with each error.

    @subsubsection complexrecovery Recovery from Complex Error Conditions

    This section describes some possible error conditions necessitating the requirements in the previous section.

    - Unavailability of Transport Layer (ex: network problem)
      - in the case of outgoing messages where the message is not received
      - in the case of reply messages where the reply from the end system is never received
    - Unavailability of End System(s) (ex: unplanned application or server restart)
      - in the case of an end-application failure when no Qorus-initiated action is taking place
      - in the case of an end-application failure during an Qorus-initiated action
    - Catastrophic Failure of Qorus Server (ex: power outage on server infrastructure)

    By designing and implementing your workflows to the requirements in the previous section, the error conditions
    above can be covered with no data loss.  The following conditions apply principally to @ref req3 "Requirement 3"
    above.

    @par Unavailability of Transport Layer or End Systems

    These cases can be recognized by a communications failure (normally an exception) or a message timeout.

    In either case, if the workflow's logic cannot determine if the message was processed by the end system before the
    failure, and the action can only be performed once for the input data in the end system in question, then the
    error defined by the workflow should have a @ref OMQ::StatRetry status, and @ref validationcode "validation code"
    must be defined that will check the end system to see if the action was carried out or not.

    This can happen, for example, if an HTTP message (or other network message) is sent and a timeout occurs.  The
    timeout could have happened because the message was never received, the message was received and processed, and
    the response message was lost, or the message was received and an error happened while processing the message that
    prohibited the response from being sent.

    Because this information is critical to the further processing of the workflow/order data, the programmer must
    define @ref validationcode "validation code" to the step object that will verify the status of the action in the
    end system before continuing when the step is recovered by Qorus.

    A @ref validationcode "validation code" should be used instead of handling the error in the step logic itself,
    because the problem that caused the error could prohibit the @ref validationcode "validation code" from being
    run successfully (for example with a temporary network outage or an end-application restart).  As the
    @ref validationcode "validation code" is run after the recovery delay (see system options @ref recover_delay and
    @ref async_delay), the chances of successfully determining the status are higher than with trying to handle the
    error in the step logic itself.

    @par Note: Error Handling Belongs in Validation Code, not Primary Step Code
    When implementing steps, errors should be flagged (but not handled) in the
    @ref primarystepcode "primary step code"; error handling should be implemented in the
    @ref validationcode "validation code".

    @subsubsection infrastructure_failure Catastrophic Failure of Server Infrastructure, System Database

    While hardly a common problem, Qorus has been designed so that recovery from a system crash (power outage,
    database outage, etc) is recoverable as long as the database remains consistent (the system schema must be
    recovered to a consistent state).

    The Qorus database should always be in a clustered or high-availability configuration in order to ensure database
    consistency.  Qorus's internal design is such that catastrophic failures such as a power failure on the system
    hosting the Qorus application can always be recovered to a consistent state and will allow properly-designed
    workflows to be recovered.

    When Qorus recovers a crashed application session, all steps that were @ref OMQ::StatInProgress are set to
    @ref OMQ::StatRetry.  When they are retried, if each step that requires @ref validationcode "validation code"
    (for example, a non-repeatable step in an end-system) has one, then the workflow can ensure that it can always
    recover at any point from an Qorus system failure.

    @see @ref appsessionrecovery for details on Qorus application session recovery

    @section wfdeffile Workflow Definition File

    Workflow definition files define workflow metadata including the steps and dependencies between steps.

    Workflow definition files are defined in YAML.

    Workflows files define the following properties:
    - @ref wf_name
    - @ref wf_version
    - @ref wf_description
    - @ref wf_author
    - @ref wf_remote
    - @ref wf_autostart
    - @ref wf_sla_threshold
    - @ref wf_max_instances
    - @ref wf_options
    - @ref wf_static_data_type
    - @ref wf_keylist
    - @ref wf_class
    - @ref wf_modules
    - @ref stepdefs

    @see
    - @ref workflowconfigitems
    - @ref implementingqorusobjectsusingyaml for details on how to define workflows using YAML definition files.

    <hr>
    @subsection wf_name Workflow Name

    The name of the workflow; the name and version together are unique identifiers for the workflow and are used to
    derive the workflowid (the single unique identifier for the workflow; it is generated from a database sequence
    when the workflow is loaded into the system via @ref oload "oload").

    Mutiple workflows with the same name and different versions can exist in the system at the same time.  Workflows
    are referred to with their workflowid, which is derived from the name and version together.

    <hr>
    @subsection wf_version Workflow Version

    The version of the workflow; the name and version together are unique identifiers for the workflow and are used to
    derive the workflowid (the single unique identifier for the workflow; it is generated from a database sequence
    when the workflow is loaded into the system via @ref oload "oload").

    Mutiple workflows with the same name and different versions can exist in the system at the same time.  Workflows
    are referred to with their workflowid, which is derived from the name and version together.

    <hr>
    @subsection wf_description Workflow Description

    The description of the workflow; accepts markdown for formatted output.

    <hr>
    @subsection wf_author Workflow Author Parameter

    The \c "author" value indicates the author of the workflow and will be returned with the workflow metadata in the
    REST API and also is displayed in the system UI.

    <hr>
    @subsection wf_remote Workflow Remote Parameter

    The \c "remote" flag indicates if the workflow will run as an independent @ref qwf "qwf" process communicating
    with other elements of Qorus Integration Engine with a distributed queue protocol rather than internally in the
    @ref qorus-core "qorus-core" process.

    When workflows run in separate @ref qwf "qwf" processes, it provides a higher level of stability and control to
    the integration platform as a whole, as a workflow with implementation problems cannot cause the integration
    platform to fail.

    There is a performance cost to running in separate @ref qwf "qwf" processes; workflow startup and shutdown is
    slightly slower, and communication with @ref qorus-core "qorus-core" also suffers a performance hit as all
    communication must be serialized and transmitted over the network.

    Furthermore memory usage is significantly higher for interfaces running in separate programs, as all the common
    infrastructure for each interface must be duplicated in each process.

    The default for this option depends on the client option @ref remote (if this client option is
    not set, then the default value is @ref True).

    The remote value can be changed at runtime by using the following REST API:
    @ref rest_api_PUT_latest_workflows__id_or_name__setRemote

    @note The \c remote flag is considered to be @ref managed_by_operations "managed by operations",
    which means that once an interface has been loaded into Qorus, if its \c remote flag is updated with the API,
    then those API-driven changes are persistent and will not be overwritten by subsequent loads of the
    interface by @ref oload "oload".

    <hr>
    @subsection wf_autostart Workflow Autostart Parameter

    The workflow \c "autostart" parameter sets the number of workflow execution instances to be started when the system is started;
    if the system should ensure that this workflow is generally running, then set this key to a value greater than zero.

    If no value is provided for this option, the system will not start the workflow automatically; any workflow execution instances
    for this workflow must be started manually.

    If a non-zero value is provided for this workflow, then the system will attempt to start the workflow at all times if all its
    dependencies are met, and it is not disabled.  Additionally, if the workflow cannot be started for any reason (for example, due
    to an error in the @ref onetimeinit "onetimeinit logic" or a dependency error), an @ref ongoingalerts "ongoing system alert"
    will be raised, which is only cleared when the workflow is successfully started (or the autostart parameter is set to zero).

    @note The workflow \c "autostart" value is considered to be @ref managed_by_operations "managed by operations",
    which means that once a workflow has been loaded into Qorus, if its \c "autostart" value is updated with the API,
    then those API-driven changes are persistent and will not be overwritten by subsequent loads of the workflow by
    @ref oload "oload".

    <hr>
    @subsection wf_sla_threshold Workflow SLA Threshold Parameter

    The workflow \c "sla_threshold" parameter sets the amount of time as an integer in seconds in which each workflow
    order should get a final status, where a final status is defined as either @ref OMQ::StatComplete "COMPLETE" or
    @ref OMQ::StatCanceled "CANCELED"; if not present the default value of 30 minutes is assumed (see
    @ref OMQ::DefaultWorkflowSlaThreshold "DefaultWorkflowSlaThreshold").

    This value is used to do SLA reporting for workflow orders in the REST and WebSocket APIs.

    @note The workflow \c "sla_threshold" value is considered to be
    @ref managed_by_operations "managed by operations", which means that once a workflow has been loaded into Qorus,
    if its \c "sla_threshold" value is updated with the API, then those API-driven changes are persistent and will not
    be overwritten by subsequent loads of the workflow by @ref oload "oload".

    <hr>
    @subsection wf_max_instances Workflow Max Instances Parameter

    The optional "max_instances" key sets the maximum number of workflow execution instances that can be running at
    one time; note that workflow execution instances are capable of processing up to two orders in parallel at any one
    time: one in "normal" mode and one in recovery mode.

    To serialize workflow processing and ensure that only one order is processed at one time at any particular point
    in the workflow's logic, set the \c "max_instances" value to \c 1, and use the \c synchronized keyword on a
    function or method called in both normal and recovery mode, or make a service call to a service method that uses
    threading primitives to ensure atomicity of operation (or has the
    @ref service_method_lock "service method write lock" flag set).

    <hr>
    @subsection wf_options Workflow Options

    If workflow options are defined in the workflow definition, the workflow will advertise and accept only the
    options defined as valid options for the workflow (aside from system options that can be overridden
    at the workflow level, which are always accepted as workflow options).

    Valid options are stored in the YAML file as a hash where the hash keys are the option names, and the values
    assigned to the keys are the descriptions of the options.

    <hr>
    @subsection wf_static_data_type Workflow Static Data Type

    Workflows can declare type enforcement for static data in the IDE; if defined, this will be enforced whenever
    workflow order data is created.

    If the static data type is defined, and a workflow order is attempted to be created with static data that is not
    accepted by the type, an \c ORDER-DATA-ERROR exception is thrown.

    <hr>
    @subsection wf_keylist Workflow Order Keys

    Workflow order keys can be used both for quick identification and lookup of order data and can also be used to
    enforce uniqueness of orders with varying granularity (system-wide, workflow-specific, or
    workflow-version-specific uniqueness).

    In order to set a workflow order key against a workflow, the valid keys must be defined in this list.

    Any number of workflow keys may be given in the workflow definition, in contrast to the single
    \c external_order_instanceid that can be given at the workflow order data instance object level and can also be
    used for the same purpose (quickly looking up workflow order data instances from a external key).

    Keys can be set and retrieved by the following APIs:
    - \b %Python: @ref OMQ::UserApi::Workflow::WorkflowApi::setOrderKeys() "wfapi.setOrderKeys()"
    - \b %Python: @ref OMQ::UserApi::Workflow::WorkflowApi::getOrderKeys() "wfapi.getOrderKeys()"
    - \b Java: @ref OMQ::UserApi::Workflow::WorkflowApi::setOrderKeys() "WorkflowApi.setOrderKeys()"
    - \b Java: @ref OMQ::UserApi::Workflow::WorkflowApi::getOrderKeys() "WorkflowApi.getOrderKeys()"
    - \b %Qore: @ref OMQ::UserApi::Workflow::WorkflowApi::setOrderKeys() "WorkflowApi::setOrderKeys()"
    - \b %Qore: @ref OMQ::UserApi::Workflow::WorkflowApi::getOrderKeys() "WorkflowApi::getOrderKeys()"

    Key metadata is saved in the \c WORKFLOW_KEYS table, and workflow order data instance keys
    are saved in the \c ORDER_INSTANCE_KEYS table.  Note that a single key value can be saved for more than one
    workflow order data instance; the indexes on the \c ORDER_INSTANCE_KEYS only enforce that values may not be
    repeated for the same \c workflow_instanceid and key name.

    The REST API provides methods to lookup workflow orders by workflow keys; see the following API for more
    information:
    - @ref rest_api_GET_latest_orders

    @subsection wf_class Workflow Class

    Qorus workflows can declare a workflow class that defines workflow-level code.  The \c "class-name" attribute
    defines the name of the class that will be used for the workflow. The class must inherit the workflow base class
    for the programming language used as described below.

    %Python workflow base class:
    - @ref OMQ::UserApi::Workflow::QorusWorkflow "wf.QorusWorkflow" class:
      - @ref OMQ::UserApi::Workflow::QorusWorkflow::attachImpl() "wf.QorusWorkflow.attachImpl()": @ref attach
      - @ref OMQ::UserApi::Workflow::QorusWorkflow::detachImpl() "wf.QorusWorkflow.detachImpl()": @ref detach
      - @ref OMQ::UserApi::Workflow::QorusWorkflow::errorHandlerImpl() "wf.QorusWorkflow.errorHandlerImpl()":
        @ref error_handler
      - @ref OMQ::UserApi::Workflow::QorusWorkflow::oneTimeInitImpl() "wf.QorusWorkflow.oneTimeInitImpl()":
        @ref onetimeinit

    Java workflow base class:
    - @ref OMQ::UserApi::Workflow::QorusWorkflow "QorusWorkflow" class:
      - @ref OMQ::UserApi::Workflow::QorusWorkflow::attachImpl() "QorusWorkflow.attachImpl()": @ref attach
      - @ref OMQ::UserApi::Workflow::QorusWorkflow::detachImpl() "QorusWorkflow.detachImpl()": @ref detach
      - @ref OMQ::UserApi::Workflow::QorusWorkflow::errorHandlerImpl() "QorusWorkflow.errorHandlerImpl()":
        @ref error_handler
      - @ref OMQ::UserApi::Workflow::QorusWorkflow::oneTimeInitImpl() "QorusWorkflow.oneTimeInitImpl()":
        @ref onetimeinit

    %Qore workflow base class:
    - @ref OMQ::UserApi::Workflow::QorusWorkflow "QorusWorkflow" class:
      - @ref OMQ::UserApi::Workflow::QorusWorkflow::attachImpl() "QorusWorkflow::attachImpl()": @ref attach
      - @ref OMQ::UserApi::Workflow::QorusWorkflow::detachImpl() "QorusWorkflow::detachImpl()": @ref detach
      - @ref OMQ::UserApi::Workflow::QorusWorkflow::errorHandlerImpl() "QorusWorkflow::errorHandlerImpl()":
        @ref error_handler
      - @ref OMQ::UserApi::Workflow::QorusWorkflow::oneTimeInitImpl() "QorusWorkflow::oneTimeInitImpl()":
        @ref onetimeinit

    @subsubsection onetimeinit Workflow Class One Time Initialization Method

    @par Synopsis
    This method is executed once when the workflow execution instance starts, and once again after every workflow
    instance cache reset.

    @par Workflow Class Method
    - \b %Python: @ref OMQ::UserApi::Workflow::QorusWorkflow::oneTimeInitImpl() "QorusWorkflow.oneTimeInitImpl()"
    - \b Java: @ref OMQ::UserApi::Workflow::QorusWorkflow::oneTimeInitImpl() "QorusWorkflow.oneTimeInitImpl()"
    - \b %Qore: @ref OMQ::UserApi::Workflow::QorusWorkflow::oneTimeInitImpl() "QorusWorkflow::oneTimeInitImpl()"

    @par Note: Acquire Workflow Execution Instance Resources in the onetimeinit() Method
    Persistent objects with a high acquisition cost can be acquired in the onetimeinit() method.  The following APIs
    save and retrieve workflow instance data:
    - \b %Python: @ref OMQ::UserApi::Workflow::WorkflowApi::updateInstanceData() "wfapi.updateInstanceData()"
    - \b %Python: @ref OMQ::UserApi::Workflow::WorkflowApi::getInstanceData() "wfapi.getInstanceData()"
    - \b Java: @ref OMQ::UserApi::Workflow::WorkflowApi::updateInstanceData() "WorkflowApi.updateInstanceData()"
    - \b Java: @ref OMQ::UserApi::Workflow::WorkflowApi::getInstanceData() "WorkflowApi.getInstanceData()"
    - \b %Qore: @ref OMQ::UserApi::Workflow::WorkflowApi::updateInstanceData() "WorkflowApi::updateInstanceData()"
    - \b %Qore: @ref OMQ::UserApi::Workflow::WorkflowApi::getInstanceData() "WorkflowApi::getInstanceData()"

    @subsubsection attach Workflow Class Attach Method

    @par Synopsis
    This method is called when Qorus starts working on a workflow order data instance (when Qorus "attaches" to the
    workflow order data instance, reading it into memory from the database).\n\n
    If any error is raised in the attach code, the workflow order data instance will receive an @ref OMQ::StatError
    status and the attach operation will fail.

    @par Note: Reliably Set TempData in Attach Logic
    @ref tempdata "TempData" can only be reliably set in attach code, because a workflow can be restarted from
    any step after an error.  Therefore you cannot ensure that @ref tempdata "TempData" set in step logic
    will be available when executing the following step, in case an error occurs.

    @par Workflow Class Method
    - \b %Python: @ref OMQ::UserApi::Workflow::QorusWorkflow::attachImpl() "wf.QorusWorkflow.attachImpl()"
    - \b Java: @ref OMQ::UserApi::Workflow::QorusWorkflow::attachImpl() "QorusWorkflow.attachImpl()"
    - \b %Qore: @ref OMQ::UserApi::Workflow::QorusWorkflow::attachImpl() "QorusWorkflow::attachImpl()"

    @subsubsection detach Workflow Class Detach Method

    @par Synopsis
    This method is called when the workflow order data instance status is committed to the database (when Qorus
    "detaches" from the workflow order data instance).  The first argument passed to the function is the workflow
    order data instance's status (@ref StatusDescriptions "status descriptions") that will be written to the database.
    The second argument passed is the external order instance ID, if any exists.

    @par Note: Update Processing Status Externally with Detach Logic
    Because detach logic is called any time the workflow order data instance status is saved to the database, it can
    be used to update the status of a workflow order data instance in an external system, if required.

    @par Workflow Class Method
    @ref OMQ::UserApi::Workflow::QorusWorkflow::detachImpl() "QorusWorkflow::detachImpl()"

    @subsubsection error_handler Workflow Class Error Handler Method

    @par Synopsis
    This code is called when errors are raised.  It allows workflows to do external logging or to take custom
    actions when errors are raised.

    @par Workflow Class Method
    - \b %Python: @ref OMQ::UserApi::Workflow::QorusWorkflow::errorHandlerImpl() "QorusWorkflow.errorHandlerImpl()"
    - \b Java: @ref OMQ::UserApi::Workflow::QorusWorkflow::errorHandlerImpl() "QorusWorkflow.errorHandlerImpl()"
    - \b %Qore: @ref OMQ::UserApi::Workflow::QorusWorkflow::errorHandlerImpl() "QorusWorkflow::errorHandlerImpl()"

    @subsection wf_modules Workflow Modules

    This attribute provides a list of %Qore-language modules that are loaded in the workflow's logic container that
    can provide base classes for the @ref wf_class "workflow class", @ref step_source "step classes", or other
    functionality for the workflow.

    @see @ref develmodules_workflow_modules for more information.

    @subsection workflowconfigitems Workflow Configuration Items

    Workflows cannot declare configuration items because workflows are just a set of steps. Instead it's allowed to
    set the value of a step configuration item on the workflow level at runtime using the operational web UI or the
    REST API.

    @note All configuration item values are considered to be @ref managed_by_operations "managed by operations" by
    design, which means that once a configuration item has been loaded into Qorus, any changes to its value with the
    API are persistent and will not be overwritten by subsequent loads of the configuration item by
    @ref oload "oload".

    @section stepdefs Step Definitions

    All Qorus integration objects are described by YAML metadata produced by our IDE, which is available as a free
    (as in free of charge and also open source) extension to
    <a href="https://code.visualstudio.com">Microsoft Visual Studio Code</a>, a multi-platform editor from Microsoft.
    The Qorus extension is called
    <a href="https://marketplace.visualstudio.com/items?itemName=qoretechnologies.qorus-vscode">Qorus Developer Tools</a>
    and can be installed directly from Visual Studio Code.

    The IDE allows step metadata to be defined as well as the step's @ref step_source "code" if required; steps
    relying solely on building blocks and/or with their implementation in one or more
    @ref finite_state_machines "finite state machines" or implemented using
    @ref devintro_no_code_connections "class connection" do not require any additional code.

    @image html Qorus-IDE-4-Step-Config.png "Workflow Steps in the Qorus IDE" width=75%

    The following diagram illustrates a subset of the attributes of a step that can be defined.

    @image html step.png "Step Metadata Diagram"

    Note that each logic attribute is defined by a @ref step_source "step class", and the step ID is not assigned in
    the workflow definition file, but rather by the loader (@ref oload "oload").

    Steps have the following attributes:
    - @ref step_name
    - @ref step_version
    - @ref step_patch
    - @ref step_description
    - @ref step_author
    - @ref step_library
    - @ref step_mappers
    - @ref step_vmaps
    - @ref step_lang
    - @ref step_source
    - @ref step_user_interaction
    - @ref step_queue
    - @ref step_event_type
    - @ref step_usermetadata
    - @ref step_config_items

    @subsection step_name Step Name

    The name of the step; the name and version together are unique identifiers for the step and are used to derive
    the stepid (the single unique identifier for the step; it is generated from a database sequence when the step
    is loaded into the system via @ref oload "oload").

    Mutiple steps with the same name and different versions can exist in the system at the same time.  Steps are
    referred to with their stepid, which is derived from the name and version together.

    @subsection step_version Step Version

    The version of the step; the name and version together are unique identifiers for the step and are used to derive
    the stepid (the single unique identifier for the step; it is generated from a database sequence when the step
    is loaded into the system via @ref oload "oload").

    Mutiple steps with the same name and different versions can exist in the system at the same time.  Steps are
    referred to with their stepid, which is derived from the name and version together.

    @subsection step_patch Step Patch

    A string "patch" label which can be used to show that a step was updated while not affecting the stepid.

    @note The \c patch value can be updated without affecting references to other objects; the unique ID for the
    object is not updated when the \c patch value is updated

    @subsection step_description Step Description

    A description for the step; the description field supports markdown for formatted output in the UI and IDE.

    @subsection step_author Step Author

    The \c "author" value indicates the author of the step and will be returned with the step metadata in the
    REST API and also is displayed in the system UI.

    @subsection step_library Step Library

    Steps support @ref library_objects "library objects" that provide additional code for the step.

    @see @ref library_objects for more information

    @subsection step_mappers Step Mappers

    An optional list of @ref mappers "mappers" that are used in the step.

    @see
    - @ref mappers
    - @ref mapper-devel-files

    @subsection step_vmaps Step Value Maps

    An optional list of @ref value-maps "value maps" that are used in the step.

    @see
    - @ref value-maps
    - @ref value-map-oload

    @subsection step_user_interaction Step User Interaction Flag

    @par Synopsis
    If this is step key is set to \c True, then the @ref asyncsteps "asynchronous step" will support APIs for user
    interaction; can only be set on @ref asyncsteps "asynchronous steps".  If this key is not present in the step
    definition, the default value is \c False.

    @par REST API support
    The following APIs can be used to atomically acquire step data for editing by a particular user:
    - @ref rest_api_POST_v3_workflows__id_or_name__lockUserInteractionStep
    - @ref rest_api_POST_v3_orders__id__lockUserInteractionStep

    @see @ref asyncsteps

    @subsection step_lang Step Language

    The programming language used for the step implementation.

    @subsection step_source Step Source Class Definitions

    The Qorus IDE allows for editing the source code for a step as well as editing the step's metadata.

    @image html Qorus-5-Step-Code-Example.png "Workflow Step Code Example in the Qorus IDE" width=75%

    The step's logic is defined as a class that inherits one of the following step classes:

    <b>Step Classes per Step Type</b>
    |!Step Type|!Step Class
    |@ref asyncsteps|\b %Python / \b Java / \b %Qore: @ref OMQ::UserApi::Workflow::QorusAsyncStep "QorusAsyncStep"
    |@ref eventsteps|\b %Python / \b Java / \b %Qore: @ref OMQ::UserApi::Workflow::QorusEventStep "QorusEventStep"
    |@ref normalsteps|\b %Python / \b Java / \b %Qore: @ref OMQ::UserApi::Workflow::QorusNormalStep "QorusNormalStep"
    |@ref subworkflowsteps|\b %Python / \b Java / \b %Qore: \
        @ref OMQ::UserApi::Workflow::QorusSubworkflowStep "QorusSubworkflowStep"
    |@ref arraysteps "Array" @ref asyncsteps|\b %Python / \b Java / \b %Qore: \
        @ref OMQ::UserApi::Workflow::QorusAsyncArrayStep "QorusAsyncArrayStep"
    |@ref arraysteps "Array" @ref eventsteps|\b %Python / \b Java / \b %Qore: \
        @ref OMQ::UserApi::Workflow::QorusEventArrayStep "QorusEventArrayStep"
    |@ref arraysteps "Array" @ref normalsteps|\b %Python / \b Java / \b %Qore: \
        @ref OMQ::UserApi::Workflow::QorusNormalArrayStep "QorusNormalArrayStep"
    |@ref arraysteps "Array" @ref subworkflowsteps|\b %Python / \b Java / \b %Qore: \
        @ref OMQ::UserApi::Workflow::QorusSubworkflowArrayStep "QorusSubworkflowArrayStep"

    The step's class determines its type as given in the above table.

    @note
    - Step logic defined in methods of the above classes can be implemented by @ref finite_state_machines instead.
      In case a @ref finite_state_machines "finite state machine" trigger is associated with a step method, the step
      method will never be executed, so the method body can be empty (as long as it is syntactically valid so that the
      interface program can be loaded / compiled).
    - Step logic can also be implemented by a @ref devintro_no_code_connections "class connection" using the
      trigger for the step's method in question

    @subsubsection classstepconstructors Step Constructors and Static Initialization

    Class-based steps can have a constructor and classes can have static initialization, but please note that if the
    step has @ref step_config_items "configuration items", it must be instantiated by @ref oload "oload" in order to
    validate the workflow's logic and in some cases to create the step's configuration in the system.  In such a case,
    if the constructor or static class initialization requires features that are only available at runtime in Qorus
    itself, the errors raised will cause step class instantiation or static class instantiation to fail.

    The step constructor takes no arguments.

    @subsection step_queue Asynchronous Step Queue

    Queues provide the storage and delivery mechanism by which the results of executing an asynchronous event for an
    @ref asyncsteps "asynchronous step" are delivered to the right step instance.

    Each @ref asyncsteps "asynchronous step" in a workflow must be associated to a queue (although in theory all the
    @ref asyncsteps "asynchronous steps" can use the same queue if desired).

    A single queue can be used for any number of @ref asyncsteps "asynchronous steps", however the keys in a queue
    must be unique.

    The step queue value must be set to a string giving the name of the @ref queue_objects "queue" for asynchronous
    steps.  The queue will link the asynchronous step's @ref primarystepcode "primary step code" with the
    @ref asyncbackendcode "back-end code".\n
    \n
    When the result of the asynchronous action is available, the result must be posted to the step's
    @ref queue_objects "queue" using the key created in the step's @ref primarystepcode "primary step code" when one
    of the following methods is called, depending on the language used:
    - \b %Python: @ref OMQ::UserApi::Workflow::QorusAsyncStepBase::submitAsyncKey() "QorusAsyncStepBase.submitAsyncKey()"
    - \b Java: @ref MQ::UserApi::Workflow::QorusAsyncStepBase::submitAsyncKey() "QorusAsyncStepBase.submitAsyncKey()"
    - \b %Qore: @ref OMQ::UserApi::Workflow::QorusAsyncStepBase::submitAsyncKey() "QorusAsyncStepBase::submitAsyncKey()"

    @note Alternatively @ref qorus_api_util_workflow_submit_async_key can be called as well to submit the key

    The @ref queue_objects "queue" will hold this data (stored in the database table \c QUEUE_DATA) and pass it to the
    @ref asyncbackendcode "asynchronous back-end code" in order to determine the step's status.\n
    \n
    See @ref queue_objects for more information.

    @subsection step_event_type Workflow Synchronization Step Event Type

    A @ref eventsteps "workflow synchronization event step" must be associated with a
    @ref wf_sync_event_objects "workflow synchronization event type", and therefore an attribute providing a valid
    value of this type is required for this kind of step.

    During step execution, the step must be bound to a @ref wf_sync_event_objects "workflow synchronization event" by
    calling one of the following APIs:
    - <b>@ref finite_state_machines "FSM / Flow API"</b>: @ref qorus_api_util_workflow_bind_event or
      @ref qorus_api_util_workflow_bind_event_unposted
    - \b %Python: @ref OMQ::UserApi::Workflow::QorusEventStepBase::bindEvent() "QorusEventStepBase.bindEvent()" or
      @ref OMQ::UserApi::Workflow::QorusEventStepBase::bindEventUnposted() "QorusEventStepBase.bindEventUnposted()"
    - \b Java: @ref OMQ::UserApi::Workflow::QorusEventStepBase::bindEvent() "QorusEventStepBase.bindEvent()" or
      @ref OMQ::UserApi::Workflow::QorusEventStepBase::bindEventUnposted() "QorusEventStepBase.bindEventUnposted()"
    - \b %Qore: @ref OMQ::UserApi::Workflow::QorusEventStepBase::bindEvent() "QorusEventStepBase::bindEvent()" or
      @ref OMQ::UserApi::Workflow::QorusEventStepBase::bindEventUnposted() "QorusEventStepBase::bindEventUnposted()"

    Alternatively, in case the step should not bind itself to a
    @ref wf_sync_event_objects "workflow synchronization event", one of the following APIs can be called instead:
    - <b>@ref finite_state_machines "FSM / Flow API"</b>: @ref qorus_api_util_workflow_skip_event
    - \b %Python: @ref OMQ::UserApi::Workflow::QorusEventStepBase::skipEvent() "QorusEventStepBase.skipEvent()"
    - \b Java: @ref OMQ::UserApi::Workflow::QorusEventStepBase::skipEvent() "QorusEventStepBase.skipEvent()"
    - \b %Qore: @ref OMQ::UserApi::Workflow::QorusEventStepBase::skipEvent() "QorusEventStepBase::skipEvent()"

    If none of these APIs are called in the step's @ref primarystepcode "primary step code", the step will exit with
    an error.  Otherwise, if a @ref wf_sync_event_objects "workflow synchronization event" is bound to the step, the
    step will only receive a @ref OMQ::StatComplete "COMPLETE" status when the event is posted.

    Workflow synchronization events can be posted with the following APIs:
    - Qorus Data Provider API: @ref qorus_api_util_post_sync_event
    - \b %Python: @ref OMQ::UserApi::UserApi::postSyncEvent() "UserApi::postSyncEvent()"
    - \b Java: @ref OMQ::UserApi::UserApi::postSyncEvent() "UserApi.postSyncEvent()"
    - \b %Qore: @ref OMQ::UserApi::UserApi::postSyncEvent() "UserApi.postSyncEvent()"
    - REST API: @ref rest_api_PUT_latest_sync-events__type___key__post
    - xRPC API: omq.system.post-event()

    The value of the tag must be the name of a valid @ref wf_sync_event_objects "workflow synchronization event".

    @see @ref eventsteps for an example of a workflow synchronization step definition where this key is defined.

    @subsection step_usermetadata Step User Metadata

    Steps can also provide user-defined metadata which is returned as part of the step's metadata description.

    This information can be used by internal Qorus code, external programs, or web pages (for example) to control user
    interactions related to the step (among other uses).

    @see @ref step_user_interaction

    @subsection step_config_items Step Configuration Items

    Steps can declare @ref devintro_no_code_config_items "configuration items" as metadata to allow for the behavior
    of the step to be modified by users at runtime using the operational web UI or the REST API.

    Step configuration items are:
    -# Created by @ref oload "oload" when loading the step
    -# Read at runtime with job APIs to affect the functionality of the step
    -# Updated using the web UI using the REST API with
       @ref rest_api_PUT_latest_workflows__id_or_name__stepinfo__id_or_name__config__name_

    Step configuration items are designed to allow users to affect the execution of a step so that changes can be made
    by authorized users in the UI without requiring a change to development.

    @note All configuration item values are considered to be @ref managed_by_operations "managed by operations" by
    design, which means that once a configuration item has been loaded into Qorus, any changes to its value with the
    API are persistent and will not be overwritten by subsequent loads of the configuration item by
    @ref oload "oload".

    @anchor stepconfigitem_override
    @par Strictly Local Step Config Item

    If the \c strictly_local flag on a step configuration item is \c False, then the step configuration item is not local
    and the value can also be set on workflow or global level.

    If the \c strictly_local flag is \c True, then the step configuration item is local and hence the value for this item
    cannot be set on workflow either global level.

    @note All configuration item values are considered to be @ref managed_by_operations "managed by operations" by
    design, which means that once a configuration item has been loaded into Qorus, any changes to its value with the
    API are persistent and will not be overwritten by subsequent loads of the configuration item by
    @ref oload "oload".

    @note Step configuration items must be returned through a URI path in the workflow context in order to reflect the
    proper value of configuration items with the \c strictly_local flag set to \c False; use the following REST API to
    retrieve step configuration items in the context of its declaring workflow:
    @ref rest_api_GET_latest_workflows__id_or_name__stepinfo__id_or_name__config__name_

    @see @ref devintro_no_code_config_items

    @subsection steplib Step Library Objects

    Steps support @ref library_objects "library objects" in way similar to workflows, services, and jobs, however step
    library objects are loaded into the workflow's program container.

    Library objects for steps can only be defined in YAML step definition file (for more details see
    @ref implementingqorusobjectsusingyaml).

    @subsection normalsteps Normal Steps

    A normal step is a step that is not a @ref subworkflowsteps "subworkflow", @ref asyncsteps "asynchronous", or
    @ref eventsteps "workflow synchronization event" step.  Normal steps do not have
    @ref asyncbackendcode "asynchronous back-end code", a @ref queue_objects "queue", or a
    @ref wf_sync_event_objects "workflow synchronization event type" and cannot be used as a
    @ref subworkflowsteps "subworkflow step".

    A normal step may be an @ref arraysteps "array step", which would make it a normal @ref arraysteps "array step".

    The base step classes to be inherited by normal step classes are:

    %Python / Java / %Qore classes:
    - \b %Python / \b Java / \b %Qore: @ref OMQ::UserApi::Workflow::QorusNormalStep "QorusNormalStep": when the logic should
      be executed once
    - \b %Python / \b Java / \b %Qore: @ref OMQ::UserApi::Workflow::QorusNormalArrayStep "QorusNormalArrayStep": when the
      logic should be executed an arbitrary number of times

    See the documentation for the classes above for example step definitions.

    @note Step logic defined in methods of step classes can be implemented by @ref finite_state_machines instead.
    In case a @ref finite_state_machines "Finite State Machine" trigger is associated with a step method, the step
    method will never be executed, so the method body can be empty (as long as it is syntactically valid).  In this
    case, the following methods can be implemented by @ref finite_state_machines :
    - <b><tt>array</tt></b> trigger for the @ref arraycode "array()" method for @ref arraysteps "array steps"
    - <b><tt>primary</tt></b> trigger for the @ref primarystepcode "primary()" method
    - <b><tt>validation</tt></b> trigger for the @ref validationcode "validation()" method

    @subsection subworkflowsteps Subworkflow Step

    A subworkflow step binds a child workflow (called a subworkflow) to a step.  The child workflow's status will be
    bound to the step's status; that is; whatever status the child workflow has will be reflected as the step's
    status.  This is how Qorus supports logical branching in workflows, where one branch of processing is optionally
    executed based on a logical condition.

    The base step classes to be inherited by subworkflow step classes are as follows.

    %Python / Java / %Qore classes:
    - \b %Python / \b Java / \b %Qore: @ref OMQ::UserApi::Workflow::QorusSubworkflowStep "QorusSubworkflowStep": when
      the logic should be executed once
    - \b %Python / \b Java / \b %Qore: @ref OMQ::UserApi::Workflow::QorusSubworkflowArrayStep "QorusSubworkflowArrayStep":
      when the logic should be executed an arbitrary number of times

    See the above classes for example step definitions.

    Subworkflow steps are not bound to any particular workflow type; the only rule for a subworkflow step is that one
    of the following API calls must be made in the @ref primarystepcode "primary step code" for the steps.

    <b>@ref finite_state_machines "FSM / Flow API" for @ref fsm_api_call_states "API Call States"</b>:
    - @ref qorus_api_util_workflow_bind_subworkflow
    - @ref qorus_api_util_workflow_skip_subworkflow

    %Python and Java methods:
    - \b %Python / \b Java:
      @ref OMQ::UserApi::Workflow::QorusSubworkflowStepBase::bindSubworkflow() "QorusSubworkflowStepBase.bindSubworkflow()"
    - \b %Python / \b Java:
      @ref OMQ::UserApi::Workflow::QorusSubworkflowStepBase::skipSubworkflow() "QorusSubworkflowStepBase.skipSubworkflow()"

    %Qore methods:
    - \b %Qore:
      @ref OMQ::UserApi::Workflow::QorusSubworkflowStepBase::bindSubworkflow() "QorusSubworkflowStepBase::bindSubworkflow()"
    - \b %Qore:
      @ref OMQ::UserApi::Workflow::QorusSubworkflowStepBase::skipSubworkflow() "QorusSubworkflowStepBase::skipSubworkflow()"

    @note
    - Subworkflow steps may not have @ref validationcode "validation code".

    A subworkflow step may be an @ref arraysteps "array step", which would make it a subworkflow
    @ref arraysteps "array step".

    @note Step logic defined in methods of step classes can be implemented by @ref finite_state_machines instead.
    In case a @ref finite_state_machines "Finite State Machine" trigger is associated with a step method, the step
    method will never be executed, so the method body can be empty (as long as it is syntactically valid).  In this
    case, the following methods can be implemented by @ref finite_state_machines :
    - <b><tt>array</tt></b> trigger for the @ref arraycode "array()" method for @ref arraysteps "array steps"
    - <b><tt>primary</tt></b> trigger for the @ref primarystepcode "primary()" method

    @subsubsection workflow_feedback Workflow Feedback

    Data can be passed from subworkflows back to the parent as workflow feedback.

    @par Child Feedback
    Child workflows can provide feedback to the parent by calling the following APIs.\n\n
    <b>@ref finite_state_machines "FSM / Flow API" for @ref fsm_api_call_states "API Call States"</b>:
    - @ref qorus_api_util_workflow_leave_feedback
    .
    %Python, Java, and %Qore methods:
    - \b %Python: @ref OMQ::UserApi::Workflow::WorkflowApi::leaveParentFeedback() "wfapi.leaveParentFeedback()"
    - \b Java: @ref OMQ::UserApi::Workflow::WorkflowApi::leaveParentFeedback() "WorkflowApi.leaveParentFeedback()"
    - \b %Qore: @ref OMQ::UserApi::Workflow::WorkflowApi::leaveParentFeedback() "WorkflowApi::leaveParentFeedback()"

    @par Parent Feedback
    The parent can retrieve the feedback (in a step executed after the subworkflow step) by calling the following
    APIs.\n\n
    <b>@ref finite_state_machines "FSM / Flow API" for @ref fsm_api_call_states "API Call States"</b>:
    - @ref qorus_api_util_workflow_get_feedback
    .
    %Python, Java, and %Qore methods:
    - \b %Python: @ref OMQ::UserApi::Workflow::WorkflowApi::getChildFeedback() "wfapi.getChildFeedback()"
    - \b Java: @ref OMQ::UserApi::Workflow::WorkflowApi::getChildFeedback() "WorkflowApi.getChildFeedback()"
    - \b %Qore: @ref OMQ::UserApi::Workflow::WorkflowApi::getChildFeedback() "WorkflowApi::getChildFeedback()"

    @subsection asyncsteps Asynchronous Steps

    Asynchronous steps allow Qorus to efficiently process asynchronous actions.  In the context of Qorus workflow
    processing, asynchronous actions are actions that may take a significant amount of time to complete.  It is not
    necessary to know in advance how much time the action will take to complete to define an asynchronous step.

    The base step classes to be inherited by asynchronous step classes are as follows.

    %Python / %Qore classes:
    - \b %Python / \b Java / \b %Qore: @ref OMQ::UserApi::Workflow::QorusAsyncStep "QorusAsyncStep": when the logic should be
      executed once
    - \b %Python / \b Java / \b %Qore: @ref OMQ::UserApi::Workflow::QorusAsyncArrayStep "QorusAsyncArrayStep": when the logic
      should be executed an arbitrary number of times

    See the above classes for example step definitions.

    To define an asynchronous step, the step definition must define @ref asyncbackendcode "asynchronous back-end code"
    and a @ref queue_objects "queue", and one of the following API calls must be made during the execution of the
    @ref primarystepcode "primary step code".

    <b>@ref finite_state_machines "FSM / Flow API" for @ref fsm_api_call_states "API Call States"</b>:
    - @ref qorus_api_util_workflow_submit_async_key
    - @ref qorus_api_util_workflow_skip_async_step

    %Python methods:
    - \b %Python: @ref OMQ::UserApi::Workflow::QorusAsyncStepBase::submitAsyncKey() "QorusAsyncStepBase.submitAsyncKey()"
    - \b %Python: @ref OMQ::UserApi::Workflow::QorusAsyncStepBase::skipAsyncStep() "QorusAsyncStepBase.skipAsyncStep()"

    Java methods:
    - \b Java: @ref OMQ::UserApi::Workflow::QorusAsyncStepBase::submitAsyncKey() "submitAsyncKey()"
    - \b Java: @ref OMQ::UserApi::Workflow::QorusAsyncStepBase::skipAsyncStep() "skipAsyncStep()"

    %Qore methods:
    - \b %Qore: @ref OMQ::UserApi::Workflow::QorusAsyncStepBase::submitAsyncKey() "QorusAsyncStepBase::submitAsyncKey()"
    - \b %Qore: @ref OMQ::UserApi::Workflow::QorusAsyncStepBase::skipAsyncStep() "QorusAsyncStepBase::skipAsyncStep()"

    The methods listed above save a reference to the step's action as a unique key in the namespace of the queue; all
    keys submitted to a queue of the same name must be unique (this is enforced by an index in the Qorus database).

    The system option @ref async_delay determines when the system will retry the step if the step's queue has not been
    @ref updating_async_queues "updated" in time.  If there is no @ref validationcode "validation code", the default
    behavior for the system will be to delete any queue data for the step, and re-run the step's
    @ref primarystepcode "primary step code".  If this is not the desired behavior, then you must implement
    @ref validationcode "validation code" to control how the system reacts to an asynchronous timeout.

    When the result of the asynchronous action is available, code external to the workflow must
    @ref updating_async_queues "update the queue entry" using a supported API that identifies the queue entry with the
    queue's name and the unique key in the queue; any data posted to the queue entry is passed to the step's
    @ref asyncbackendcode "back end logic".

    Often asynchronous updates are enabled by implementing a Qorus service to monitor the result of asynchronous
    processing that then @ref updating_async_queues "updates the queue entry" to enable processing to continue for the
    affected order.

    Within Qorus, the following is an example of how to call the REST API
    @ref rest_api_POST_latest_async-queues__queue__update from a Qorus
    service; in this example, a table in an external database is polled by checking which queue entries are still
    outstanding by calling @ref rest_api_GET_v3_async-queues__queue__qinfo and then updated with
    @ref rest_api_POST_latest_async-queues__queue__update.

    @par Asynchronous Queue Update Example
    @code{.py}
# get list of outstanding queue entries
*list<auto> l = map int(__8_1.queuekey), UserApi::callRestApi("GET", "async-queues/bridge/qinfo?status=" +
    OMQ::StatWaiting);

if (!l) {
    return;
}

# check if database has been updated
AbstractTable table = UserApi::getSqlTable(ds, "rd");
hash<auto> sh = {
    "columns": ("ind", "sysnmbr", "status"),
    "where": {
        "sysnmbr": op_ne(NULL),
        "ind": op_in(l),
    },
};
*hash<auto> q = table.select(sh);

# loop through result set and update "bridge" queue with key as %ind
context (q) {
    slog(LL_DETAIL_1, "updating queue 'bridge': ind=%y, data=%y", %ind, %%);
    hash<auto> args = {
        "key": %ind,
        "data": %%,
    };
    UserApi::callRestApi("POST", "async-queues/bridge/update", args);
} @endcode

    An asynchronous step may be an @ref arraysteps "array step", which would make it an asynchronous
    @ref arraysteps "array step".

    Asynchronous steps define a segment discontinuity; all @ref normalsteps "normal steps" leading up to the
    asynchronous step are in the same segment; and all @ref normalsteps "normal steps" executed after the asynchronous
    step are in another segment.  Qorus workflow segments are each processed in their own thread and can process
    workflow order data instances independently of one another.

    @see
    - @ref updating_async_queues
    - @ref rest_api_latest_async-queues
    - @ref rest_api_latest_async-queues__queue_
    - @ref rest_api_latest_orders__id__async-queue
    - @ref step_user_interaction

    @note Step logic defined in methods of step classes can be implemented by @ref finite_state_machines instead.
    In case a @ref finite_state_machines "Finite State Machine" trigger is associated with a step method, the step
    method will never be executed, so the method body can be empty (as long as it is syntactically valid).  In this
    case, the following methods can be implemented by @ref finite_state_machines :
    - <b><tt>array</tt></b> trigger for the @ref arraycode "array()" method for @ref arraysteps "array steps"
    - <b><tt>end</tt></b> trigger for the @ref asyncbackendcode "end()" method
    - <b><tt>primary</tt></b> trigger for the @ref primarystepcode "primary()" method
    - <b><tt>validation</tt></b> trigger for the @ref validationcode "validation()" method

    @subsection eventsteps Workflow Synchronization Event Steps

    Workflow synchronization event steps allow many workflow orders to synchronize their processing based on a single
    event.  A workflow synchronization event step may be an @ref arraysteps "array step", which would make it a
    workflow synchronization event @ref arraysteps "array step".

    The base step classes to be inherited for asynchronous step classes are as follows.

    %Python / Java / %Qore classes:
    - \b %Python / \b Java / \b %Qore: @ref OMQ::UserApi::Workflow::QorusEventStep "QorusEventStep": when the logic should be executed once
    - \b %Python / \b Java / \b %Qore: @ref OMQ::UserApi::Workflow::QorusEventArrayStep "QorusEventArrayStep": when the logic should be
      executed an arbitrary number of times

    See the above classes for example step definitions.

    The @ref primarystepcode "primary step code" for a workflow synchronization event step must make one of the
    following API calls:
    - <b>@ref finite_state_machines "FSM / Flow API"</b>: @ref qorus_api_util_workflow_bind_event
    - <b>@ref finite_state_machines "FSM / Flow API"</b>: @ref qorus_api_util_workflow_bind_event_unposted
    - <b>@ref finite_state_machines "FSM / Flow API"</b>: @ref qorus_api_util_workflow_skip_event
    - \b %Python: @ref OMQ::UserApi::Workflow::QorusEventStepBase::bindEvent() "QorusEventStepBase.bindEvent()"
    - \b %Python: @ref OMQ::UserApi::Workflow::QorusEventStepBase::bindEventUnposted() "QorusEventStepBase.bindEventUnposted()"
    - \b %Python: @ref OMQ::UserApi::Workflow::QorusEventStepBase::skipEvent() "QorusEventStepBase.skipEvent()"
    - \b Java: @ref OMQ::UserApi::Workflow::QorusEventStepBase::bindEvent() "QorusEventStepBase.bindEvent()"
    - \b Java: @ref OMQ::UserApi::Workflow::QorusEventStepBase::bindEventUnposted() "QorusEventStepBase.bindEventUnposted()"
    - \b Java: @ref OMQ::UserApi::Workflow::QorusEventStepBase::skipEvent() "QorusEventStepBase.skipEvent()"
    - \b %Qore: @ref OMQ::UserApi::Workflow::QorusEventStepBase::bindEvent() "QorusEventStepBase::bindEvent()"
    - \b %Qore: @ref OMQ::UserApi::Workflow::QorusEventStepBase::bindEventUnposted() "QorusEventStepBase::bindEventUnposted()"
    - \b %Qore: @ref OMQ::UserApi::Workflow::QorusEventStepBase::skipEvent() "QorusEventStepBase::skipEvent()"

    The step definition must reference a @ref wf_sync_event_objects "workflow synchronization event type" as well;
    event keys bound or posted are treated unique within their @ref wf_sync_event_objects "event type".  Additionally,
    workflow synchronization event steps may not have @ref validationcode "validation code".

    @note
    - If none of the required API calls are made to either bind an event or skip the event binding for the step, the
      step will get an @ref OMQ::StatError "ERROR" status.
    - A workflow synchronization event step will go to @ref OMQ::StatComplete when its event is posted; see
      @ref qorus_api_util_post_sync_event,
      @ref OMQ::UserApi::UserApi::postSyncEvent() "UserApi::postSyncEvent()",
      and @ref rest_api_PUT_latest_sync-events__type___key__post for information on how to post a synchronization
      event
    - Step logic defined in methods of step classes can be implemented by @ref finite_state_machines instead.
      In case a @ref finite_state_machines "Finite State Machine" trigger is associated with a step method, the step
      method will never be executed, so the method body can be empty (as long as it is syntactically valid).  In this
      case, the following methods can be implemented by @ref finite_state_machines :
      - <b><tt>array</tt></b> trigger for the @ref arraycode "array()" method for @ref arraysteps "array steps"
      - <b><tt>primary</tt></b> trigger for the @ref primarystepcode "primary()" method

    @see
    - @ref wf_sync_event_objects
    - @ref step_event_type
    - @ref qorus_api_util_workflow_bind_event
    - @ref qorus_api_util_workflow_bind_event_unposted
    - @ref qorus_api_util_workflow_skip_event
    - @ref OMQ::UserApi::Workflow::QorusEventStepBase::bindEvent() "QorusEventStepBase::bindEvent()"
    - @ref OMQ::UserApi::Workflow::QorusEventStepBase::bindEventUnposted() "QorusEventStepBase::bindEventUnposted()"
    - @ref OMQ::UserApi::Workflow::QorusEventStepBase::skipEvent() "QorusEventStepBase::skipEvent()"
    - @ref qorus_api_util_post_sync_event
    - @ref OMQ::UserApi::UserApi::postSyncEvent() "UserApi::postSyncEvent()"
    - @ref rest_api_PUT_latest_sync-events__type___key__post
    - omq.system.post-event()

    @subsection arraysteps Array Step

    Any type of step can be an array step.  An array step is any step that may need to repeat its action more than
    once.  Any step type can be an array step; @ref normalsteps "normal", @ref asyncsteps "asynchronous",
    @ref subworkflowsteps "subworkflow", or @ref eventsteps "workflow synchronization event" steps can be array steps.
    The difference between a non-array step is that array steps have an array method, and the argument signature also
    changes for other step methods.

    The recommended way to define steps is by defining all the step's logic as a subclass of one of the following step classes:

    <b>Array Step Classes per Step Type</b>
    |!Step Type|!Base Step Class
    |@ref arraysteps "Array" @ref asyncsteps|\b %Python / \b %Qore / \b Java: \
        @ref OMQ::UserApi::Workflow::QorusAsyncArrayStep "QorusAsyncArrayStep"
    |@ref arraysteps "Array" @ref eventsteps|\b %Python / \b %Qore / \b Java: \
        @ref OMQ::UserApi::Workflow::QorusEventArrayStep "QorusEventArrayStep"
    |@ref arraysteps "Array" @ref normalsteps|\b %Python / \b %Qore / \b Java: \
        @ref OMQ::UserApi::Workflow::QorusNormalArrayStep "QorusNormalArrayStep"
    |@ref arraysteps "Array" @ref subworkflowsteps|\b %Python / \b %Qore / \b Java: \
        @ref OMQ::UserApi::Workflow::QorusSubworkflowArrayStep "QorusSubworkflowArrayStep"

    See the above classes for example step definitions.

    The return value of the array code will determine how many times the step will execute, and on what data.
    Please note that array steps have different code signatures, as the array element is always passed to the step
    logic code (@ref primarystepcode "primary step code", @ref validationcode "validation code", and
    @ref asyncbackendcode "asynchronous back-end code" for @ref asyncsteps "asynchronous steps").

    @note Step logic defined in methods of step classes can be implemented by @ref finite_state_machines instead.
    In case a @ref finite_state_machines "Finite State Machine" trigger is associated with a step method, the step
    method will never be executed, so the method body can be empty (as long as it is syntactically valid).  In this
    case, the following methods can be implemented by @ref finite_state_machines :
    - <b><tt>array</tt></b> trigger for the @ref arraycode "array()" method for @ref arraysteps "array steps"
    - <b><tt>primary</tt></b> trigger for the @ref primarystepcode "primary()" method
    - <b><tt>validation</tt></b> trigger for the @ref validationcode "validation()" method

    @subsection primarystepcode Primary Step Code

    @par Synopsis
    As the name suggests, the primary step code should contain all the logic for the step when run in
    @ref OMQ::WM_Normal mode (not recovering).  In the step definition the primary step code is identified by the
    \c funcname key, or, if this is not present, the name of the step is assumed to be the name of the primary step
    code as well.

    @note @ref asyncsteps "Asynchronous steps", @ref subworkflowsteps "subworkflow steps", and
    @ref eventsteps "workflow synchronization event steps" all have special requirements for API calls that must be
    made in the primary step code; see the documentation for each step type for more information.

    Every step base class has an abstract \c primary() method where the primary step logic must be defined.  See the
    class documentation for the specific @ref step_source "step class" for more information on requirements for the
    primary step method.

    @note Step logic defined in methods of step classes can be implemented by @ref finite_state_machines instead;
    in case a step is defined with a @ref finite_state_machines "Finite State Machine" with the \c primary trigger,
    the \c primary() method will never be executed, and the method body should remain empty.

    @subsection validationcode Validation Code

    @par Synopsis
    The validation code is run whenever the step is recovered (for asynchronous steps, this could also be if the
    asynchronous step's queue entry has not been updated within the time period defined by the
    @ref async_delay system option).  This function's return value tells Qorus if the step function should be run
    again or not.  Note that @ref subworkflowsteps "subworkflow steps" and
    @ref eventsteps "workflow synchronization event steps" cannot have validation code.

    @par Note: Always Implement Validation Code for Non-Repeatable Actions
    A number of problems could prohibit a step from being updated with the correct status, for example, network
    problems, power outages, other application problems, etc.  To handle these situations gracefully, implement
    validation code to verify the status of the step before running the step's primary step code again.  The arguments
    passed to the validation code depend on the type of step.

    @subsubsection validationreturnvalue Validation Code Return Value

    The following table describes how the system reacts depending on the return value of the validation logic.

    <b>Validation Code Return Value</b>
    |!Return Value|!System Behavior
    |@ref OMQ::StatComplete|Do not run the primary step logic; mark the step as @ref OMQ::StatComplete "COMPLETE" \
        and continue.  For asynchronous steps, @ref asyncbackendcode "back-end code" also will not be run
    |@ref OMQ::StatError|Do not run the primary step logic; mark the step as @ref OMQ::StatError "ERROR" and stop \
        running any further dependencies of this step
    |@ref OMQ::StatRetry|Run the primary step loggic again immediately.  If the step is an \
        @ref asyncsteps "asynchronous step" with queue data with a @ref OMQ::QS_Waiting status, the queue data will \
        be deleted immediately before the primary step logic is run again
    |@ref OMQ::StatAsyncWaiting|For @ref asyncsteps "asynchronous steps" only, do not run the primary step logic and \
        keep the @ref OMQ::StatAsyncWaiting "ASYNC-WAITING" status.  For non-asynchronous steps, raises an error and \
        the return value is treated like @ref OMQ::StatError "ERROR"
    |any other status|an error is raised and the return value is treated like @ref OMQ::StatError "ERROR"

    @subsubsection validationmethod Validation Method

    Some step base classes have a \c validation() method that can be overridden where the validation logic can be
    defined.  See the class documentation for the specific @ref step_source "step class" for more information on
    the signature and requirements for the validation method (if it's supported for the step type, not all step
    types support validation logic), and see @ref validationreturnvalue for a description of how the return value of
    this method affects workflow order processing.

    @note
    - @ref asyncsteps "Asynchronous steps" should normally have validation code, because Qorus will automatically
      try to recover an asynchronous step if the @ref queue_objects "queue" is not updated within the time period
      defined by the @ref async_delay system option.  If no validation code is defined, then the system will
      automatically delete the queue data (if any is present) and rerun the @ref primarystepcode "primary step code",
      which may not be the desired behavior.
    - @ref subworkflowsteps "Subworkflow steps" will never be recovered in the parent workflow, and subworkflow
      steps may not have validation code for this reason.  A subworkflow step's status is bound to the subworkflow,
      and any errors must be corrected in the subworkflow.
    - @ref eventsteps "Workflow synchronization event steps" cannot have validation code; they are
      either waiting for their event or @ref OMQ::StatComplete.  To force a
      @ref eventsteps "Workflow synchronization event step" to continue, either post its event or call
      omq.system.skip-step() on the step.
    - Step logic defined in methods of step classes can be implemented by @ref finite_state_machines instead;
      in case a step is defined with a @ref finite_state_machines "Finite State Machine" with the \c validation
      trigger, the \c validation() method will never be executed, and the method body should remain empty (a default
      \c return statement may be necessary for syntactic correctness, however the method code will never be executed
      as long a @ref finite_state_machines "Finite State Machine" trigger exists for the method).

    @subsection asyncbackendcode Asynchronous Back-End Code

    @par Synopsis
    This logic must be defined for @ref asyncsteps "asynchronous steps".  This logic is run when the queue data bound
    to the asynchronous step is updated and receives the status @ref OMQ::QS_Received.  The job of this code is to
    determine if the asynchronously-received data is correct or not; if it is not correct, then the code should
    raise an error by throwing an exception or by calling the following API method:
    - \b %Python: @ref OMQ::UserApi::Workflow::WorkflowApi::stepError() "wfapi.stepError()"
    - \b Java: @ref OMQ::UserApi::Workflow::WorkflowApi::stepError() "WorkflowApi.stepError()"
    - \b %Qore: @ref OMQ::UserApi::Workflow::WorkflowApi::stepError() "WorkflowApi::stepError()"

    @ref asyncsteps "Asynchronous steps" can define an \c end() method to process data submitted for the asynchronous
    workflow event.  See the class documentation for the specific @ref step_source "step class" for more information
    on the \c end() method.

    @note Step logic defined in methods of step classes can be implemented by @ref finite_state_machines instead;
    in case a step is defined with a @ref finite_state_machines "Finite State Machine" with the \c end trigger,
    the \c end() method will never be executed, and the method body should remain empty.

    @subsection arraycode Array Code

    @par Synopsis
    This code is run every time Qorus starts executing an @ref arraysteps "array step".  This could be in
    @ref OMQ::WM_Normal "normal mode" (the first time the step is executed), in @ref OMQ::WM_Recovery "recovery mode",
    or when Qorus attaches to a workflow order data instance in order to execute
    @ref asyncbackendcode "back-end code".  For each element in the list returned, Qorus will run the appropriate
    function and track the results separately.  If no value or an empty list is returned the first time the array
    function is executed, the entire @ref arraysteps "array step" receives a @ref OMQ::StatComplete "COMPLETE" status
    and the step function is not run.\n
    \n
    For class-based steps, the array method is an abstract method defined in all array base step classes and must be
    defined in the step's class.

    @note
    - The return value of the array code is not stored in persistent storage.  In order to ensure correct
      functionality in the case of recoveries (or with @ref asyncbackendcode "back end logic" in asynchronous steps),
      the array function must return the same array with elements in the same order every time it is run.  If necessary,
      the list or information to regenerate the list can be stored in @ref dynamicdata "dynamic order" or
      @ref stepdata "dynamic step" data.
    - Step logic defined in methods of step classes can be implemented by @ref finite_state_machines instead;
      in case a step is defined with a @ref finite_state_machines "Finite State Machine" with the \c array trigger,
      the \c array() method will never be executed, and the method body should remain empty (in Java, a default
      <tt>return null</tt> statement may be necessary for syntactic correctness, however the method code will never be
      executed as long a @ref finite_state_machines "Finite State Machine" trigger exists for the method).
*/

/** @page implementingservices Implementing Services

    @tableofcontents

    @ref develguide "Back to the Developer's Guide Table of Contents"

    @section svcimplintro Overview

    All Qorus integration objects are described by YAML metadata produced by our IDE, which is available as a free
    (as in free of charge and also open source) extension to
    <a href="https://code.visualstudio.com">Microsoft Visual Studio Code</a>, a multi-platform editor from Microsoft.
    The Qorus extension is called
    <a href="https://marketplace.visualstudio.com/items?itemName=qoretechnologies.qorus-vscode">Qorus Developer Tools</a>
    and can be installed directly from Visual Studio Code.

    User services are like named and versioned API sets that can be live-upgraded.  User service methods are available
    to all workflows and jobs (and to other services) and can be automatically exported to other applications through
    lightweight web services (RPC protocols and REST) through the @ref httpserver "HTTP server" (in fact, this is the
    default behavior, but can be inhibited by setting the @ref service_method_internal "internal flag" on the
    @ref service_methods "service method").

    @image html Qorus-IDE-4-Service-Config.png "Services in the Qorus IDE" width=75%

    Additionally, services can also have one or more background threads, and therefore do not have to wait for input
    data to perform some processing.

    @see
    - @ref serviceapi for more information on the service API including service @ref Qore::Program "Program" objects
    - @ref callingservices for information on how to call services from Qorus user code (workflows, services, and
      jobs).

    Services can also be called from the command-line using the @ref qrest "qrest" program as follows:

    @verbatim unixprompt% qrest put services/<name>/<method>/call args=... @endverbatim

    @section servicedesc Qorus Services

    Services are defined in YAML in files defining service metadata including an attribute giving the file name of
    the @ref service_source "service class source" that implements the method logic.

    Services are loaded from the database into their own program objects and have their own
    @ref serviceapi "internal API".  All user-defined services must be of the type \c "user".  System services are
    delivered with Qorus and should not be modified, as this is likely to affect system stability.

    The following diagram illustrates the a subset of the attributes of a service.

    @image html service-diagram.png "Service Metadata Diagram"

    <b>Service Metadata</b>
    |!Key|!Mand.?|!Description
    |@ref service_type|Y|The type of service: \c system or \c user
    |@ref service_name|Y|The name of the service; generally considered unique
    |@ref service_version|Y|The version of the service; only one version of a service can be loaded at a time
    |@ref service_patch|N|A string that describes the patchlevel of the service
    |@ref service_description|Y|The description of the service; supports markdown in the UI and the IDE
    |@ref service_author|N|The author of the service
    |@ref service_library|N|Library objects providing additional code to the service
    |@ref service_mappers|N|A list of data mappers that the service can use
    |@ref service_vmaps|N|A list of value maps that the service can use
    |@ref service_lang|Y|The language of the service's source code
    |@ref service_source|Y|The source code to the service
    |@ref service_methods|N|The methods implemented by the service's source code and/or base classes
    |@ref service_config_items|N|Configuration for the service
    |@ref service_file_resources|N|File resources for the service
    |@ref service_api_manager|N|API manager configuration
    |@ref service_autostart|N|The autostart flag that indicates if the service should be started automatically
    |@ref service_remote|N|The remote flag that indicates if the service runs in its own process or not
    |@ref service_container_cpu_request|N|(Enterprise Edition only) The initial CPU allocation for \
        @ref service_stateless "stateless services" running in Qorus in \
        <a href="https://kubernetes.io/">Kubernetes</a>
    |@ref service_container_memory_request|N|(Enterprise Edition only) The initial memory requirement for \
        @ref service_stateless "stateless services" running in Qorus in \
        <a href="https://kubernetes.io/">Kubernetes</a>
    |@ref service_container_cpu_limit|N|(Enterprise Edition only) The CPU usage limit for \
        @ref service_stateless "stateless services" running in Qorus in \
        <a href="https://kubernetes.io/">Kubernetes</a>
    |@ref service_container_memory_limit|N|(Enterprise Edition only) The hard memory limit for \
        @ref service_stateless "stateless services" running in Qorus in \
        <a href="https://kubernetes.io/">Kubernetes</a>
    |@ref service_scaling_min_replicas|N|(Enterprise Edition only) The minimum number of replicas that will be \
        started when Qorus is running under <a href="https://kubernetes.io/">Kubernetes</a> for \
        @ref service_stateless "stateless services" only
    |@ref service_scaling_max_replicas|N|(Enterprise Edition only) The maximum number of replicas that will be \
        started when Qorus is running under <a href="https://kubernetes.io/">Kubernetes</a> for \
        @ref service_stateless "stateless services" only
    |@ref service_scaling_cpu|N|(Enterprise Edition only) The percentage CPU usage goal for \
        <a href="https://kubernetes.io/">Kubernetes</a> for all pods for @ref service_stateless "stateless services" \
        only
    |@ref service_scaling_memory|N|(Enterprise Edition only) The memory usage target for \
        <a href="https://kubernetes.io/">Kubernetes</a> for @ref service_stateless "stateless services" only
    |@ref service_stateless|N|(Enterprise Edition only) The stateless flag for the service; indicates if the service \
        is started externally to Qorus can can run in multiple processes
    |@ref service_modules|N|A list of %Qore-language modules to be loaded into the service's \
        @ref svcprograms "Program container"

    @note Attributes labeled "Enterprise Edition only" are not available in the Community Edition of Qorus.

    @subsection service_type Service Type

    There are two types of services:
    - \c system: for system services delivered with Qorus
    - \c user: user services written / configured by Qorus developers

    @subsection service_name Service Name

    The name of the service; the name and version together are unique identifiers for the service and are used to
    derive the serviceid (the single unique identifier for the service; it is generated from a database sequence when
    the service is loaded into the system via @ref oload "oload").

    There can only be one service of a given type and name loaded in the system at any time, so the tyoe abd name of a
    service together also make a unique compound identifier for the job, however since system services are stable, and
    user services should avoid using names used by system services, the name of a service is often used as a unique
    key as well.

    In case a user service might have the same name as a system service, the user service would be inaccessible with
    APIs (such as the REST API) where the service name is used as a unique key, therefore it is advised to never name
    a user service with the same name as a sytem service.

    @subsection service_version Service Version

    Version string for the service; the version is informative; only the latest version of a service can be
    loaded in Qorus at any time, so services are referenced by name generally, and sometimes by type and name.

    @subsection service_patch Service Patch

    A string "patch" label which can be used to show that a service was updated while not affecting the serviceid.

    @note The \c patch value can be updated without affecting references to other objects; the unique ID for the
    object is not updated when the \c patch value is updated, however since service names are already treated as
    unique, the \c patch attribute is not as useful as in other objects but is still included in services for
    consistency's sake.

    @subsection service_description Service Description

    Description of the service; accepts markdown for formatted output in the UI and IDE.

    @subsection service_author Service Author

    The \c "author" value indicates the author of the service and will be returned with the service metadata in the
    REST API and also is displayed in the system UI.

    @subsection service_library Service Library

    Services support @ref library_objects "library objects" that provide additional code for the service.

    @see @ref library_objects for more information

    @subsection service_mappers Service Mappers

    An optional list of @ref mappers "mappers" that are used in the service.

    @see
    - @ref mappers
    - @ref mapper-devel-files

    @subsection service_vmaps Service Value Maps

    An optional list of @ref value-maps "value maps" that are used in the service.

    @see
    - @ref value-maps
    - @ref value-map-oload

    @subsection service_lang Service Language

    The programming language used for the service implementation.

    @subsection service_source Service Source

    The implementation of the service must be made in the programming language given by @ref service_lang; the main
    job class must inherit one of the following classes depending on the source language:
    The source for a service is a class inheriting one of the following classes depending on the source language:
    - \b %Python: @ref OMQ::UserApi::Service::QorusService "svc.QorusService"
    - \b Java: @ref OMQ::UserApi::Service::QorusService "QorusService"
    - \b %Qore: @ref OMQ::UserApi::Service::QorusService "QorusService"

    @subsubsection classserviceconstructors Service Constructors and Static Initialization

    Service classes can have a constructor and classes can have static initialization, but please note that if
    the constructor or static class initialization requires features that are only available at runtime in Qorus
    itself, the errors raised in @ref oload "oload" will cause service class instantiation or static class
    instantiation to fail.

    To work around this, put all initialization requiring runtime support in Qorus in the
    @ref serviceinit "init method" of the service.  This method is only called when the service is initialized by
    Qorus at runtime.

    The service constructor must take no arguments.

    @subsubsection classservicestaticvars Class-Based Service Static Class Variables

    Static class variables are initialized when the class is loaded which is also performed by @ref oload "oload",
    therefore if any static class variables have initialization code that requires Qorus functionality, this can cause
    @ref oload "oload" to fail, therefore it's recommended to put such static initialization in the class's
    \c constructor() method instead as in the preceding example.

    @subsection service_methods Service Methods

    Service methods define the user-visible interface of the service.  The logic in a service
    program is defined by the method code and any @ref library_objects "library objects" loaded into the service's
    program container.

    Service methods are the user-visible entry-points to a service and as such contain the logic of the service.

    The following diagram illustrates a subset of the attributes of a service method.

    @image html service-method.png "Service Method Metadata Diagram"

    <b>Service Method Metadata</b>
    |!Key|!Mand.?|!Description
    |@ref service_method_name|N|The name of the method; also a public method with this name must be defined in the \
        source as well
    |@ref service_method_description|Y|Description of the method object
    |@ref service_method_author|N|The optional author of the method, in case it differs from the service's author
    |@ref service_method_lock|N|must be either \c none, \c read, or \c write (default \c none), to determine how the \
        service's @ref Qore::Thread::RWLock "RWLock" will be grabbed before the method is executed
    |@ref service_method_internal|N|If this boolean flag is set to \c True, then the method will not be \
        automatically exported through the any network interface
    |@ref service_method_write|N|(Enterprise Edition Only) If this boolean flag is set to \c True, then the method \
        will be marked as a write method, meaning that external callers will have to have the \
        @ref OMQ::QR_CALL_USER_SERVICES_RW "CALL-USER-SERVICES-RW" role to call the method if \
        @ref RBAC "RBAC security" is enabled

    @note
    - Both static and non-static class methods (or in the case of %Python, class methods) can be exported as
      service methods.
    - Service method logic defined in methods of service classes can be implemented by @ref finite_state_machines
      instead; in case a method is defined with a @ref finite_state_machines "Finite State Machine" trigger for the
      method, the method logic defined in the service class will never be executed, and the method body should remain
      empty.
    - Service methods can also be implemented by a @ref devintro_no_code_connections "class connection" using the
      trigger for the method
    - Attributes labeled "Enterprise Edition only" are not available in the Community Edition of Qorus.

    @subsubsection service_method_name Service Method Name
    The service method name must be unique (although service methods may be overloaded in Java and %Qore) and is used
    when calling the method or accessing it using the REST API.

    @subsubsection service_method_author Service Method Author

    A string giving the name of the author or authors of the service method.

    @subsubsection service_method_description Service Method Description
    The description supports markdown in the UI and IDE.

    @subsubsection service_method_lock Service Method Read Write Lock Setting
    Each service has a read-write lock object (%Qore class @ref Qore::Thread::RWLock "RWLock") associated with it.
    Methods can be tagged to acquire the lock for reading, writing, or not acquire the lock at all (default behavior).

    This attribute can be used to provide safe multi-threaded access to internal resources.  For example, if the
    service provides methods to read data and a method to reload the data from an external resource (such as a
    database), then the read methods can be tagged to acquire the lock in read mode, and the method to reload the data
    can be tagged to acquire the lock in write mode.  This way, the reload method will block until all reads have
    finished, and the reads will block if any reload is in progress.

    The read-write lock will be released safely when execution returns to the Qorus system, even if an exception is
    thrown in the method.

    @par Note: Use the Read-Write Lock to Provide a Thread-Safe Caching Service
    The Read-Write lock attribute on each method can be used to ensure consistent access to internal data, while
    allowing the data to be changed even while new requests come in during the update.

    @subsubsection service_method_internal Service Method Internal Flag
    If the \c "internal" flag is set to \c True on a method, then that method can only be called internally.  Any
    direct call to this method from an external source (such as through lightweight web-service protocols exported
    through the @ref httpserver "HTTP server") will result in the method not being called and an exception returned to
    the called instead.
    This flag should be set on methods that return unserializable objects that cannot be sent through network
    interfaces.

    @subsubsection service_method_write Service Method Write Flag
    If the \c "write" flag is set on a method, then users without the
    @ref OMQ::QR_CALL_USER_SERVICES_RW "CALL-USER-SERVICES-RW" (for user services) or the
    @ref OMQ::QR_CALL_SYSTEM_SERVICES_RW "CALL-SYSTEM-SERVICES-RW" (for system services) or another permission that
    contains these cannot call the service method from an external network interface.

    @subsubsection service_method_source Service Method Source
    @anchor java_method_annotations
    @par Depcrecated Java Service Method Annotations
    When delivering compiled Java code implementing service methods in class or jar files, the Java annotation
    interface @ref com.qoretechnologies.qorus.service.QorusMethod "QorusMethod" must be used to declare Qorus methods
    as in the following example:
    @code{.java}
class MyJavaService extends QorusService {
    @QorusMethod(
        // the desc value is required; all other values are optional
        desc = "returns a constant string as an example",
        // the author value is optional (default is empty)
        author = "Josephine Programmer",
        // this method is available from network interfaces by default (default)
        intern = false,
        // this method does not need write permissions to call (default)
        write = false,
        // no locking is done on the call (default)
        lock = LockType.None
    )
    public static String getExampleString() {
        return "hello";
    }
}
    @endcode
    \n
    @note
    - Annotations are necessary to use when delivering Java code in binary form; i.e. as a class or in a jar file.
    - Annotations are not used when Java services are created using the Qorus IDE; in this case the method metadata is
      stored in YAML; see @ref implementingqorusobjectsusingyaml for more information
    - Service method logic defined in methods of service classes can be implemented by @ref finite_state_machines
      instead; in case a method is defined with a @ref finite_state_machines "Finite State Machine" trigger for the
      method, the method logic defined in the service class will never be executed, and the method body should remain
      empty.
    \n
    @anchor service_method_restrictions
    @par Restrictions on copy() Methods
    To export a \c copy() service method with a %Qore class-based service, name the class method \c _copy() (with a
    leading underscore), and give the method name \c copy().  The translation to the internal name (to avoid a
    conflict with the special class method \c copy()) is done automatically by @ref oload "oload" and by the Qorus
    runtime. See the following example for more information.
    \n
    @par Example %Qore Class-Based Service with a Copy Method: copy-example-v1.0.qsd
    @code{.py}
%new-style
%strict-args
%require-types
%enable-all-warnings

class CopyExample inherits QorusService {
    _copy() {
    }
}
    @endcode

    @par Disallowed Service Methods in Class-Based Services
    The following special class methods may not be exported as service methods:
    - \c constructor()
    - \c destructor()
    - \c methodGate()
    - \c memberGate()
    - \c memberNotification()

    @anchor service_method_java_bin
    @par Service Methods in Binary Java Files
    Java service methods implemented in base classes in binary formats like jar or class files should be declared
    using the @ref java_method_annotations "QoreMethod annotation".

    @par Example Java Service Definition: MyJavaService.java
    @code{.java}
package com.qoretechnologies.qorus.example;

import qore.OMQ.UserApi.UserApi;
import qore.OMQ.UserApi.Service.*;

import java.time.ZonedDateTime;

class MyJavaService extends QorusService {
    public static final ZonedDateTime systemStarted;

    static {
        try {
            systemStarted = (ZonedDateTime)callRestApi("GET", "system/starttime");
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    // in order to be serve as a service init method, the method must be declared as a service method in the
    // service's metadata
    public void init() {
    }

    // in order to be serve as a service method, the method must be declared as a service method in the service's
    // metadata
    public static void other() {
    }
}
    @endcode

    @subsection service_config_items Service Configuration Items

    Services can declare @ref devintro_no_code_config_items "configuration items" as metadata to allow for the
    behavior of the service to be modified by auhtorized users at runtime using the operational web UI or the REST
    API.

    Service configuration items are:
    -# Created by @ref oload "oload" when loading the service
    -# Read at runtime with job APIs to affect the functionality of the service
    -# Updated using the web UI using the REST API with @ref rest_api_PUT_latest_services__id_or_name__config__name_

    Service configuration items are designed to allow users to affect the execution of a service so that changes can
    be made by authorized users in the UI without requiring a change to development.

    @note All configuration item values are considered to be @ref managed_by_operations "managed by operations" by
    design, which means that once a configuration item has been loaded into Qorus, any changes to its value with the
    API are persistent and will not be overwritten by subsequent loads of the configuration item by
    @ref oload "oload".

    @anchor local_serviceconfigitem
    @par Strictly Local Service Config Item

    If the \c strictly_local flag on a service configuration item is \c False, then the service configuration item is
    not local and the value can also be set on global level.

    If the \c strictly_local flag is \c True, then service job configuration item is local and hence the value for this item
    cannot be set on global level.

    @note All configuration item values are considered to be @ref managed_by_operations "managed by operations" by
    design, which means that once a configuration item has been loaded into Qorus, any changes to its value with the
    API are persistent and will not be overwritten by subsequent loads of the configuration item by
    @ref oload "oload".

    @see @ref devintro_no_code_config_items

    @subsubsection service_config_item_updates Reacting Dynamically to Service Config Item Changes

    Services can react actively to configuration item changes by using the following APIs to register a callback that
    will be called when a config item value is updated:
    - \b %Python: @ref OMQ::UserApi::Service::ServiceApi::setConfigItemChangeCallback() "svcapi.setConfigItemChangeCallback()"
    - \b Java: @ref OMQ::UserApi::Service::ServiceApi::setConfigItemChangeCallback() "ServiceApi.setConfigItemChangeCallback()"
    - \b %Qore: @ref OMQ::UserApi::Service::ServiceApi::setConfigItemChangeCallback() "ServiceApi::setConfigItemChangeCallback()"

    @subsection service_file_resources Service File Resources

    Service file resources are resource files that are declared with the \c "resource" tag in a
    @ref servicedesc "service definition file" and loaded into the database with @ref oload "oload".

    These file resources can then be served automatically if the service binds a @ref OMQ::AbstractServiceHttpHandler
    object with @ref OMQ::UserApi::Service::ServiceApi::bindHttp() "ServiceApi::bindHttp()" to serve HTTP requests.

    @note
    - Make sure to set a URL root path in the
      @ref OMQ::AbstractServiceHttpHandler::constructor() "AbstractServiceHttpHandler::constructor()" by setting
      \a isregex to @ref False "False" in order for service file resources to be served automatically.
    - Service file resources can be retrieved and queried by using
      @ref service_resource_functions "service resource APIs" in the service API.

    Each resource name is its relative file name; for example if the following resource is declared in a service:
    @verbatim resource: html/* @endverbatim

    And the file \c html/extension.html is loaded by @ref oload "oload" as a service file resource, then
    \c "html/extension.html" is a valid resource name, and could be set as the default resource (the resource that's
    served when no other resource is matched to a request) with
    @ref OMQ::AbstractServiceHttpHandler::setDefaultResource() "AbstractServiceHttpHandler::setDefaultResource()".

    For example, if the code in the following examples is used to create the service HTTP handler object and bind the handler:

    @par %Python Example
    @code{.py}
from svc import QorusService

class MyHttpHandler(OMQ.AbstractServiceHttpHandler):
    def __init__(self):
        super(MyHttpHandler, self).__init__("my-service", None, None, None, False)

class MyService(QorusService):
    def init(self):
        svcapi.bindHttp(MyHttpHandler())
    @endcode

    @par %Qore Example
    @code{.py}
class MyHttpHandler inherits OMQ::AbstractServiceHttpHandler {
    constructor() : OMQ::AbstractServiceHttpHandler("my-service", NOTHING, NOTHING, NOTHING, False) {
    }
}

class MyService inherits QorusService {
    init() {
        bindHttp(new MyHttpHandler());
    }
}
    @endcode

    Then a request like the following is received:
    @verbatim
GET /my-service/html/extension.html HTTP/1.1
    @endverbatim

    The <i>cx.resource_path</i> value in the call to
    @ref OMQ::AbstractServiceHttpHandler::handleRequestImpl() "AbstractServiceHttpHandler::handleRequestImpl()" will
    be set to \c "html/extension.html", which in this example would be a valid service file resource, therefore if the
    @ref OMQ::AbstractServiceHttpHandler::handleRequestImpl() "AbstractServiceHttpHandler::handleRequestImpl()"
    returns @ref nothing, this resource would be automatically served to the requestor.

    @subsection servicefileresourcerendering Automatic Resource Template Rendering

    Mixed text/HTML/JavaScript and %Qore code can be automatically rendered and served if the resource has the file
    extension: \c "qhtml", \c "qjs", or \c "qjson".  In this case the final rendered text is rendered and served
    automatically according to the rules described in @ref WebUtil::StaticTemplateManager::add().

    Summary of unrendered text format:
    - \c {% <i>qore statement</i> \c %}
    - \c {{ <i>qore expression returning a string</i> \c }}

    @par Example HTML Template
    @verbatim
{% foreach hash<auto> $h in ($ctx.list) { %}
<tr>
    <td class="name"><a href="?rpath={{ $ctx.parent_url ? $ctx.rpath : "" }}/{{ $h.name }}" {{ $h.type != "DIRECTORY" ? "class=\"file\"" : ""}}>{{ $h.name }}</a></td>
    <td class="text-left" width="40">{{ $h.type != "DIRECTORY" ? "File" : "Directory" }}</td>
    <td class="text-right">{{ $h.type != "DIRECTORY" ? $h.size : "--" }}</td>
</tr>
{% } %}
    @endverbatim

    @par Example JavaScript Template
    @verbatim
const ws_server = '{{"ws" + ($ctx.ssl ? "s" : "") + "://" + $ctx.hdr.host + "/" + UserApi::getConfigItemValue("websockets-root-uri")}}';
    @endverbatim

    @subsubsection service_file_resource_templates Service File Resource Template Programs

    Qorus's service template manager sets up the embedded @ref Qore::Program "Program" object for templates with additional
    code similar to a service @ref Qore::Program "Program".

    The following are additions and enhancements available to template processing and rendering when used with Qorus services:
    - the following parse defines are set:
      - \c "Qorus" (common to workflows, services, and jobs)
      - \c "QorusServer" (common to workflows, services, and jobs)
      - \c "QorusHasUserConnections" (common to workflows, services, and jobs)
      - \c "QorusHasAlerts" (common to workflows, services, and jobs)
      - \c "QorusService" (service-specific)
      - \c "QorusHasHttpUserIndex" (service-specific)
      - all defines set in system option @ref defines (common to workflows, services, and jobs)
    - the entire @ref serviceapi "service api" is available
    - service helper objects such as @ref OMQ::omqservice "omqservice" are also imported and available
    - the \a $ctx variable used in the template code has the value documented in
      @ref OMQ::AbstractServiceHttpHandler::handleRequestImpl()

    @note
    - The template program's parse options are set automatically by the \c parse-options attribute of the service;
      it's not possible to set them with parse directives inside the template, as injected code (which is injected as
      source) would be injected with the wrong style.  This means that the standard %Qore style in template programs
      is "old style"; i.e. variables require the dollar sign (ex: \c $ctx) by default; "new style" (without dollar
      signs) is only used if set in the service's metadata.  As setting parse options is not currently supported with
      YAML-based service metadata, all service templates are parsed with old style for services with YAML-based
      metadata.

    @subsection service_api_manager Service API Manager Configuration

    Use the Api Manager configuration to configure a Qorus service as a protocol handler using a supported API schema
    (currently SOAP and Swagger).

    @image html Qorus-IDE-4-API-Manager.png "API Manager Configuration in the Qorus IDE" width=60%

    To configure a service as an API manager, you need to specify the schema type (\c soap to provide a WSDL or
    \c swagger to provide a JSON or YAML schema) and then the schema file.  The IDE will then upload the schema file
    to the server, which will reply with endpoint information, at which time the IDE will allow you to associate a
    service method or a @ref finite_state_machines "finite state machine" to each API endpoint to provide the
    implementation of each API endpoint specified by the schema.

    The schema file itself will be saved against the service as a @ref service_file_resources "file resource".

    In the Enterprise Edition of Qorus, the @ref service_stateless "stateless" flag can be combined with an API
    manager configuration to implement a scalable microservice for handling APIs under
    <a href="https://kubernetes.io/">Kubernetes</a>.

    @subsection service_autostart Service Autostart Flag

    If the \c "autostart" flag is set to \c True, then the service will be started automatically whenever Qorus is
    started or whenever it and all @ref rbacgroups "interface groups" it is a member of are enabled.

    @note The service \c "autostart" value is considered to be @ref managed_by_operations "managed by operations",
    which means that once a service has been loaded into Qorus, if its \c "autostart" value is updated with the API,
    then those API-driven changes are persistent and will not be overwritten by subsequent loads of the service by
    @ref oload "oload".

    @subsection service_remote Service Remote Flag

    The \c "remote" flag indicates if the service will run as an independent @ref qsvc "qsvc" process communicating
    with other elements of Qorus Integration Engine with a distributed queue protocol rather than internally in the
    @ref qorus-core "qorus-core" process.

    When services run in separate @ref qsvc "qsvc" processes, it provides a higher level of stability and control to
    the integration platform as a whole, as a service with implementation problems cannot cause the integration
    platform to fail.

    There is a performance cost to running in separate @ref qsvc "qsvc" processes; service startup and shutdown is
    slightly slower, and communication with @ref qorus-core "qorus-core" also suffers a performance hit as all
    communication must be serialized and transmitted over the network.

    Calls to service methods in remote processes may not leave @ref thread_resources "thread resources" active when
    returning from the method; doing so will cause an exception to be thrown and for the thread resource to be
    cleaned up automatically.

    Additionally, service methods running in remote @ref qsvc "qsvc" processes cannot return non-serializable data
    (non-serializable objects, references, callable data types), and also their methods cannot accept these values as
    arguments.  Furthermore, all HTTP or other protocol support implemented in remote services will be subject to
    round-trip network serialization to and from @ref qorus-core "qorus-core".

    @note If your service has methods that require or return non-serializable data types, then the \c "remote" flag
    must be set to @ref False "False".

    The default for this option depends on the client option @ref remote (if this client option is not set, then the
    default value is @ref True).

    The remote value can be changed at runtime by using the following REST API:
    @ref rest_api_PUT_latest_services__id_or_name__setRemote

    @note The \c remote flag is considered to be @ref managed_by_operations "managed by operations",
    which means that once an interface has been loaded into Qorus, if its \c remote flag is updated with the API,
    then those API-driven changes are persistent and will not be overwritten by subsequent loads of the
    interface by @ref oload "oload".

    @subsection service_stateless Service Stateless Flag

    "Stateless" services are services that scale horizontally across many processes and potentially many VM
    containers.

    Statless services automatically support a "soft failover" for service calls and accesses to service resources; if
    a stateless service program instance dies in a call, then another client is chosen automatically and the request
    is sent to a running client without passing the error back to the caller.

    Stateless services can serve HTTP, REST, FTP, and WebSocket requests; see the class documentation for the
    particular handler class for more information on how they behave with stateless services.

    @note
    - The @ref service_autostart "autostart" flag is ignored for stateless services; stateless services are
      started and scaled automatically when running under @ref <a href="https://kubernetes.io/">Kubernetes</a>; to
      stop a stateless services, the service must be disabled.  See @ref service_stateless_kubernetes for more
      information.
    - Stateless services are not supported in the Community Edition

    @subsubsection service_stateless_kubernetes Stateless Service Support in Kubernetes

    When Qorus is running under <a href="https://kubernetes.io/">Kubernetes</a>,
    <a href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/">stateful sets</a> are created and
    destroyed automatically for stateless services, and additionally the associated
    <a href="https://kubernetes.io/docs/concepts/workloads/pods/">pods</a> are scaled to zero when
    stateless services (or an @ref rbacgroups "interface group" that they are a member of) are disabled.

    Qorus determines that it is running under Kubernetes if processes are started in independent mode and the
    \c KUBERNETES_SERVICE_HOST environment variable is set.

    @note Stateless services are not supported in the Community Edition

    @see
    - @ref service_container_cpu_request
    - @ref service_container_memory_request
    - @ref service_container_cpu_limit
    - @ref service_container_memory_limit
    - @ref service_scaling_min_replicas
    - @ref service_scaling_max_replicas
    - @ref service_scaling_cpu
    - @ref service_scaling_memory

    @subsubsection service_stateless_load Loading Stateless Services

    Stateless services are always started externally to Qorus (for example by Kubernetes or OpenShift); they are
    assumed to always be @ref service_remote "remote", and additionally the @ref service_autostart "autostart" flag is
    ignored.

    @note Stateless services are not supported in the Community Edition

    @subsubsection service_stateless_unload Unloading and Resetting Stateless Services

    Stateless services are stopped when they are unloaded or reset; in such a case the external software can decide to
    restart them; normally they will be restarted when an unload or reset action is initiated by Qorus.

    @note Stateless services are not supported in the Community Edition

    @subsubsection service_container_cpu_request Stateless Service Kubernetes Initial CPU Requirements

    The initial CPU requirement for stateless services when Qorus is running under
    <a href="https://kubernetes.io/">Kubernetes</a> expressed as a floating-point number (ex: \c 0.5 = half a CPU).

    This number is used by the Kubernetes scheduler to determine if a service can be scheduled; if no node has enough
    free CPU resources, then the service will not be scheduled and cannot be started.

    @note Stateless services are not supported in the Community Edition

    @subsubsection service_container_memory_request Stateless Service Kubernetes Initial Memory Requirements

    The initial memory requirement for stateless services when Qorus is running under
    <a href="https://kubernetes.io/">Kubernetes</a> expressed as a string (ex: \c 250Mi or \c 2Gi).

    This number is used by the Kubernetes scheduler to determine if a service can be scheduled; if no node has enough
    free memory, then the service will not be scheduled and cannot be started.

    @note Stateless services are not supported in the Community Edition

    @subsubsection service_container_cpu_limit Stateless Service Kubernetes CPU Usage Limit

    The hard CPU usage limit for stateless services when Qorus is running under
    <a href="https://kubernetes.io/">Kubernetes</a> expressed as a floating-point number (ex: \c 4.5 = four and a half
    CPUs).  If the service exceeds this value, it will be subjected to CPU usage throttling.

    @note Stateless services are not supported in the Community Edition

    @subsubsection service_container_memory_limit Stateless Service Kubernetes Memory Limit

    The hard memory limit for stateless services when Qorus is running under
    <a href="https://kubernetes.io/">Kubernetes</a> expressed as a string (ex: \c 250Mi or \c 2Gi).

    If the service exceeds this value when running, it will be terminated.

    @note Stateless services are not supported in the Community Edition

    @subsubsection service_scaling_min_replicas Stateless Service Kubernetes Autoscaling Min Replicas Value

    The minimum number of replicas that will be started when Qorus is running under
    <a href="https://kubernetes.io/">Kubernetes</a>.

    This option is valid for @ref service_stateless "stateless services" only and also only takes effect when Qorus
    is running under <a href="https://kubernetes.io/">Kubernetes</a>.

    @note Stateless services are not supported in the Community Edition

    @subsubsection service_scaling_max_replicas Stateless Service Kubernetes Autoscaling Max Replicas Value

    The maximum number of replicas that will be started when Qorus is running under
    <a href="https://kubernetes.io/">Kubernetes</a>.

    This option is valid for @ref service_stateless "stateless services" only and also only takes effect when Qorus
    is running under <a href="https://kubernetes.io/">Kubernetes</a>.

    @note Stateless services are not supported in the Community Edition

    @subsubsection service_scaling_cpu Stateless Service Kubernetes Autoscaling CPU Target Value

    The percentage CPU usage goal for <a href="https://kubernetes.io/">Kubernetes</a> for all pods for the service
    when Qorus is running under <a href="https://kubernetes.io/">Kubernetes</a>.

    This option is valid for @ref service_stateless "stateless services" only and also only takes effect when Qorus
    is running under <a href="https://kubernetes.io/">Kubernetes</a>.

    @note Stateless services are not supported in the Community Edition

    @subsubsection service_scaling_memory Stateless Service Kubernetes Autoscaling Memory Target Value

    The memory usage target for pods for the stateless service when Qorus is running under
    <a href="https://kubernetes.io/">Kubernetes</a>.

    This option is valid for @ref service_stateless "stateless services" only and also only takes effect when Qorus
    is running under <a href="https://kubernetes.io/">Kubernetes</a>.

    @note Stateless services are not supported in the Community Edition

    @subsection service_modules Service Modules Parameter

    The \c "service-modules" option lists modules providing base classes for %Qore-language
    @ref service_source "services classes".

    Modules declared like this will be loaded into each service's @ref svcprograms "Program container", and their
    classes can be used as base classes for @ref service_source "service classes".

    @see @ref develmodules_service_modules for more information.

    @subsection serviceloading Service Loading

    Otherwise, a service is loaded and initialized any time a method of that service is called and the service has not
    already been loaded.  In this case all the service's methods are loaded and parsed into the same program object,
    along with any library function, classes, and constants associated with the service.  Any parse exceptions during
    service loading will prohibit the service from being loaded.

    @subsection serviceinit Service Initialization
    If a service has an \c init() method, this method is called as soon as the service has been loaded and parsed, and
    before any call to a service method is made.  For example, if a service with an \c init() method is loaded because
    a call to another method is made, the \c init() method will be called first, and then the called method will be
    called and the value returned to the caller.

    An exception when running the \c init() method will cause the service to be unloaded, and the exception will be
    returned to the caller.

    If the service has a \c start() method, then it must also have a \c stop() method.  The \c start() method will be
    run in a separate thread and is expected to run until the \c stop() method is called.  The \c stop() method should
    signal the routine running in the \c start() method to exit.

    When the \c start() method returns, the service is automatically unloaded.  To start threads in user code in a
    service, use the svc_start_thread() or svc_start_thread_args() functions (in which case, to use these functions,
    the service must also have a \c stop() method).

    @note When the \c init() method is explicitly called, this call is ignored, in the sense that, if the service is
    already loaded, no action is taken, and if it is not, the service is loaded and initialized, so the \c init()
    method is called as per the rules above.  Therefore to simple ensure that a service is loaded and initialized, it
    is safe to call the \c init() method of a service at any time.  Also note that the \c init() method may be safely
    called even if no \c init() method is defined for the service.

    @section servicehttp Service HTTP Handlers

    Qorus services can implement generic HTTP request handlers by subclassing @ref OMQ::AbstractServiceHttpHandler and
    binding it either to the global Qorus listeners or service-specific listeners using:
    - \b %Python: @ref OMQ::UserApi::Service::ServiceApi::bindHttp() "svcapi.bindHttp()"
    - \b %Qore: @ref OMQ::UserApi::Service::ServiceApi::bindHttp() "ServiceApi::bindHttp()"

    Using this mechanism, Qorus services can implement custom HTTP-based protocols or use one of the existing heler
    classes to export RPC services, @ref servicerestapis "REST APIs",
    @ref servicewebsockets "web sockets server event sources", or even generic HTML user interfaces and
    @ref uiextensions "Qorus web UI extensions".

    @subsection uiextensions Developing Web UI Extensions

    The web UI can be extended with Qorus services by registering the extension with the following function:
    - \b %Qore: @ref OMQ::UserApi::Service::ServiceApi::uiExtensionRegister() "ServiceApi::uiExtensionRegister()"

    The only argument of this function must be a class descended from @ref OMQ::QorusExtensionHandler as in the
    following examples:

    @par %Python Example
    @code{.py}
from svc import QorusService

class myExtensionHandler(OMQ.QorusExtensionHandler):
    def __init__(self):
        super(myExtensionHandler, self).__init__("Example", "Example Extension", "my example extension")
        self.setDefaultResource("templates/index.qhtml")

class MyService(QorusService):
    def init(self):
        svcapi.uiExtensionRegister(myExtensionHandler())
    @endcode

    @par %Qore Example
    @code{.py}
%new-style
%strict-args
%require-types
%enable-all-warnings

class myExtensionHandler inherits QorusExtensionHandler {
    constructor() : QorusExtensionHandler("Example", "Example Extension", "my example extension") {
        setDefaultResource("templates/index.qhtml");
    }
}

class MyService inherits QorusService {
    init() {
        uiExtensionRegister(new myExtensionHandler());
    }
}
    @endcode

    @subsubsection uiextensionresources UI Extension Resources

    At least one @ref service_file_resources "service file resource" is required: the bootstrap HTML page; this
    resource is set by calling @ref OMQ::QorusExtensionHandler::setDefaultResource() as in the above example.

    Resources must be declared in the @ref servicedesc "service definition file" with a service file resource
    declaration.

    The following is an example UI extension service with example resources.

    @par index.html
    @verbatim
<h1>Hello World!</h1>
    @endverbatim

    @par Resource Tag
    @verbatim resource: index.html @endverbatim

    @par %Python Example (\c hello-world-v1.0.py)
    @code{.py}
from service import QorusService

class HelloWorldHandler(OMQ.QorusExtensionHandler):
    def __init__(self):
        super(myExtensionHandler, self).__init__("examples", "Hello World")
        self.setDefaultResource("index.html")

class HelloWorld(QorusService):
    def init(self):
        svcapi.uiExtensionRegister(HelloWorldHandler())
    @endcode

    @par %Qore Example (\c hello-world-v1.0.qsd)
    @code{.py}
%new-style
%strict-args
%require-types
%enable-all-warnings

class HelloWorldHandler inherits QorusExtensionHandler {
    constructor(): QorusExtensionHandler("examples", "Hello World") {
        setDefaultResource('index.html');
    }
}

class HelloWorld inherits QorusService {
    # "init" is a registered service method in the corresponding YAML metadata file
    init() {
        uiExtensionRegister(new HelloWorldHandler());
    }
}
    @endcode

    @subsection servicerestapis Service REST APIs

    REST APIs can be developed with Qorus services by subclassing the @ref OMQ::AbstractServiceRestHandler class and
    bound with:
    - \b %Python: @ref OMQ::UserApi::Service::ServiceApi::bindHttp() "svcapi.bindHttp()"
    - \b %Qore: @ref OMQ::UserApi::Service::ServiceApi::bindHttp() "ServiceApi::bindHttp()"

    Consider the following examples:

    @par %Python Example (rest-example-v1.0.py)
    @code{.py}
from svc import QorusService
from qore.RestHandler import RestHandler, AbstractRestClass

class ExampleRestClass(AbstractRestClass):
    def name(self):
        return "subclass"

    def get(self, cx, ah):
        return RestHandler.makeResponse(200, "OK")

class ExampleRestHandler(OMQ.AbstractServiceRestHandler):
    def __init__(self):
        super(MyRestHandler, self).__init__("example")
        self.addClass(ExampleRestClass())

    def get(self, cx, ah):
        return RestHandler.makeResponse(200, "OK");

class PythonRestTest(QorusService):
    def init(self):
        svcapi.bindHttp(ExampleRestHandler())
    @endcode

    @par %Qore Example (rest-example-v1.0.qsd)
    @code{.py}
%new-style
%strict-args
%require-types
%enable-all-warnings

# example class for handling REST operations
class ExampleRestClass inherits RestHandler::AbstractRestClass {
    string name() {
        return "subclass";
    }

   hash get(hash cx, *hash ah) {
        return RestHandler::makeResponse(200, "OK");
    }
}

class ExampleRestHandler inherits AbstractServiceRestHandler {
    constructor() : AbstractServiceRestHandler("example") {
        addClass(new ExampleRestClass());
    }

   hash get(hash cx, *hash ah) {
        return RestHandler::makeResponse(200, "OK");
    }
}

class RestExample inherits QorusService {
    # "init" is a registered service method in the corresponding YAML metadata file
    init() {
        bindHttp(new ExampleRestHandler());
    }
}
    @endcode

    This is a simple service declaration that exports a (very simple) REST API at "/example" that returns the string
    \c "OK" to the following requests:
    - <tt>GET /example HTTP/1.1</tt>: handled by ExampleRestHandler
    - <tt>GET /example/subclass HTTP/1.1</tt>: handled by ExampleRestClass

    @subsection servicewebsockets Service WebSockets

    Qorus services can provide websocket server services by subclassing @ref OMQ::AbstractServiceWebSocketHandler and
    bound with:
    - \b %Python: @ref OMQ::UserApi::Service::ServiceApi::bindHttp() "svcapi.bindHttp()"
    - \b %Qore: @ref OMQ::UserApi::Service::ServiceApi::bindHttp() "ServiceApi::bindHttp()"

    Consider the following examples:

    @par %Python Example (websocket-example-v1.0.qsd.py)
    @code{.py}
from svc import QorusService
from qore.WebSocketHandler import WebSocketHandler, WebSocketConnection
from qore.json import make_json
from datetime import timedelta

quit = False
ExitPollInterval = timedelta(seconds = 1)

class MyWebSocketConnection(WebSocketConnection):
    def __init__(self, handler):
        super(MyWebSocketConnection, self).__init__(handler)

    def gotMessage(self, msg):
        UserApi.logInfo("got msg: %y", msg)

class MyWebSocketHandler(OMQ.AbstractServiceWebSocketHandler):
    def __init__(self):
        super(MyWebSocketHandler, self).__init__("my-websocket")
        svcapi.startThread(self.eventListener)

    def eventListener(self):
        global quit
        global ExitPollInterval
        min_id = 1
        while not quit:
            eh = svcapi.waitForEvents(min_id, ExitPollInterval)
            if 'shutdown' in eh:
                UserApi.logInfo("system is shutting down; stopping event thread")
                break
            min_id = eh['lastid'] + 1
            if not 'events' in eh:
                continue
            json = make_json(eh['events'])
            self.sendAll(json)

    def getConnectionImpl(self, cx, hdr, cid):
        return MyWebSocketConnection(self)

class PythonWebSocketTest(QorusService):
    # "init" is a registered service method in the corresponding YAML metadata file
    def init(self):
        svcapi.bindHttp(MyWebSocketHandler())

    # "stop" is a registered service method in the corresponding YAML metadata file
    def stop(self):
        global quit
        quit = True
    @endcode

    @par %Qore Example (websocket-example-v1.0.qsd)
    @code{.py}
%new-style
%strict-args
%require-types
%enable-all-warnings

class MyWebSocketHandler inherits OMQ::AbstractServiceWebSocketHandler {
    public {
        const ExitPollInterval = 1s;
    }

    constructor() : AbstractServiceWebSocketHandler("my-websocket") {
        ServiceApi::startThread(\eventListener());
    }

    private eventListener() {
        int min_id = 1;
        while (!quit) {
            hash eh = ServiceApi::waitForEvents(min_id, ExitPollInterval);
            if (eh.shutdown) {
                UserApi::logInfo("system is shutting down; stopping event thread");
                break;
            }
            min_id = eh.lastid + 1;
            if (!eh.events)
                continue;
            sendAll(make_json(eh.events));
        }
    }
}

class WebSocketExample inherits QorusService {
    # "init" is a registered service method in the corresponding YAML metadata file
    init() {
        our *bool quit;
        bindHttp(new MyWebSocketHandler());
    }

    # "stop" is a registered service method in the corresponding YAML metadata file
    stop() {
        quit = True;
    }
}
    @endcode

    The above example service will listen for all system events with
    @ref OMQ::UserApi::Service::ServiceApi::waitForEvents() "waitForEvents()" (polling every second
    for a service stop event) and serialize any new system events with JSON using
    @ref Qore::Json::make_json() "make_json()" and send to all connected clients using
    @ref WebSocketHandler::WebSocketHandler::sendAll() "WebSocketHandler::sendAll()".

    @section serviceftp Service FTP Handlers

    Qorus services can implement a custom FTP server for receiving data by subclassing @ref OMQ::AbstractFtpHandler
    and calling the following API on the resulting object:
    - \b %Python: @ref OMQ::UserApi::Service::ServiceApi::bindFtp() "svcapi.bindFtp()"
    - \b %Qore: @ref OMQ::UserApi::Service::ServiceApi::bindFtp() "ServiceApi::bindFtp()"

    Consider the following example services:

    @par %Python Example (python-ftp-example-v1.0.qsd.py)
    @code{.py}
from svc import QorusService
from OMQ import AbstractFtpHandler
import os
from os.path import dirname, basename, exists

# import symbols from Qore modules
from qore.Util import get_random_string
from qore.FsUtil import remove_tree
# import symbol from Qore
from qore.__root__.Qore import mkdir_ex

dir = ""
rmdir = False
stats = {
    "in": {
        "files": 0,
    }
}

class MyFtpHandler(AbstractFtpHandler):
    def __init__(self, dir):
        super(MyFtpHandler, self).__init__(dir)

    def authReceiveFile(self, cwd, orig, path):
        path += ".tmp"
        UserApi.logInfo("authorizing receipt of file %s -> %s", path, path)
        return path

    def fileReceived(self, path):
        global stats

        stats['in']['files'] += 1
        UserApi.logInfo("received file: dir: %y fn: %y", dirname(path), basename(path))

class PythonFtpTest(QorusService):
    # "init" is a registered service method in the corresponding YAML metadata file
    def init(self):
        global dir
        dir = os.environ['OMQ_DIR'] + "/user/ftp-test" + get_random_string()
        if not exists(dir):
            global rmdir
            mkdir_ex(dir, 0o700, True)
            rmdir = True
        handler = MyFtpHandler(dir)
        handler.addListener(0)
        svcapi.bindFtp(handler)

    # "info" is a registered service method in the corresponding YAML metadata file
    def info(self):
        global stats
        return stats

    # "stop" is a registered service method in the corresponding YAML metadata file
    def stop(self):
        global dir
        global rmdir
        if rmdir:
            svcapi.logInfo("removing FTP tree: %y", dir)
            remove_tree(dir)

    # "port" is a registered service method in the corresponding YAML metadata file
    def port(self):
        res = svcapi.getServiceInfo()['resources']
        for key in (res):
            if res[key]['type'] == "FtpListener" and res[key]['info']['familystr'] == "ipv4":
                return res[key]['info']['port']

        raise QoreException("FTP-ERROR", "cannot determine FTP port")
    @endcode

    @par %Qore Example (ftp-example-v1.0.qsd)
    @code{.py}
%new-style
%strict-args
%require-types
%enable-all-warnings

const DEFAULTS = {
    "listeners": list(18002),
    "dir": "/tmp",
};

class MyFtpHandler inherits public OMQ::AbstractFtpHandler {
    constructor(string dir) : AbstractFtpHandler(dir) {
    }

    *string authReceiveFile(string cwd, string orig, reference path) {
        UserApi::logInfo("authorizing receipt of file %s -> %s", path, path + ".tmp");
        path += ".tmp";
    }

    fileReceived(string path) {
        ++stats."in".files;
        UserApi::logInfo("received file: dir: %y fn: %y", dirname(path), basename(path));
    }
}

class FtpExample inherits QorusService {
    private {
        hash<auto> stats = {
            "in": {
                "files": 0,
            },
        };
    }

    # "init" is a registered service method in the corresponding YAML metadata file
    init() {
        hash<auto> opt = getOptionsSetDefaults();
        logInfo("starting with options: %y", opt);

        MyFtpHandler handler(opt.dir);
        foreach auto l in (opt.listeners) {
            handler.addListener(l);
        }

        bindFtp(handler);
    }

    # "info" is a registered service method in the corresponding YAML metadata file
    hash<auto> info() {
        return stats;
    }

    private hash getOptionsSetDefaults() {
        # get persistent options for service from system properties
        *hash<auto> props = propGet("ftp-example");
        # allow system properties to override default values
        return map {$1.key: props{$1.key} ?? $1.value}, DEFAULTS.pairIterator();
    }
}
    @endcode

    This service will create an FTP server on port 18002 by default and store any files received in the \c "/tmp"
    directory by adding \c ".tmp" on the filename.

    The @ref OMQ::AbstractFtpHandler::fileReceived() "AbstractFtpHandler::fileReceived()" callback could then be
    modified to create a workflow order instance for the file's data if necessary (for example).
*/

/** @page implementingjobs Implementing Jobs

    @tableofcontents

    @ref develguide "Back to the Developer's Guide Table of Contents"

    @section jobimplintro Implementing Qorus Jobs

    All Qorus integration objects are described by YAML metadata produced by our IDE, which is available as a free
    (as in free of charge and also open source) extension to
    <a href="https://code.visualstudio.com">Microsoft Visual Studio Code</a>, a multi-platform editor from Microsoft.
    The Qorus extension is called
    <a href="https://marketplace.visualstudio.com/items?itemName=qoretechnologies.qorus-vscode">Qorus Developer Tools</a>
    and can be installed directly from Visual Studio Code.

    Jobs are simple tasks executed on a schedule, similar to a cron job.  The information and status of processing is
    stored in the database and is reported through system APIs.  An internal API is also provided to jobs; see
    @ref jobapi for more information.

    @image html Qorus-IDE-4-Job-Config.png "Jobs in the Qorus IDE" width=1000

    @see
    - @ref jobapi for more information on the job API including job @ref Qore::Program "Program" objects
    - @ref jobs for more information on Qorus jobs in general

    @section jobdeffile Job Definition Files

    Job definition files define job metadata including the job schedule and furthermore contain a link to the job
    class source code.

    Job definition files are defined in YAML as described in this section.

    Job definition files are used to create job definitions in the Qorus schema that will be run acording to their
    schedule.

    Job YAML definition files are parsed by the @ref oload "oload" program, which will create the jobs in the Qorus
    database according to the information in the file.

    Jobs have the following properties:
    - @ref job_name
    - @ref job_version
    - @ref job_description
    - @ref job_author
    - @ref job_remote
    - @ref job_active
    - @ref job_schedule
    - @ref job_run_skipped
    - @ref job_expiry_date
    - @ref job_lang
    - @ref job_source
    - @ref job_class_name
    - @ref job_library
    - @ref job_mappers
    - @ref job_vmaps
    - @ref job_groups
    - @ref job_modules
    - @ref job_config_items

    @subsection job_name Job Name

    The name of the job; the name and version together are unique identifiers for the job and are used to derive
    the jobid (the single unique identifier for the job; it is generated from a database sequence when the job
    is loaded into the system via @ref oload "oload").

    There can only be one job of a given name loaded in the system at any time, so the name of a job is also a unique
    identifier for the job.

    @subsection job_version Job Version

    Version string for the job object; this version is informative; only one version of a job is stored in the
    database at a time.

    @subsection job_patch Job Patch

    A string "patch" label which can be used to show that a job was updated while not affecting the jobid.

    @note The \c patch value can be updated without affecting references to other objects; the unique ID for the
    object is not updated when the \c patch value is updated, however since job names are already unique, the \c patch
    attribute is not as useful as in other objects but is still included in jobs for consistency's sake.

    @subsection job_description Job Description

    Description of the job; accepts markdown for formatted output.

    @subsection job_author Job Author

    The \c "author" value indicates the author of the job and will be returned with the job metadata in the
    REST API and also is displayed in the system UI.

    @subsection job_remote Job Remote Flag

    The \c "remote" flag indicates if the job will run as an independent @ref qjob "qjob" process communicating
    with other elements of Qorus Integration Engine with a distributed queue protocol rather than internally in the
    @ref qorus-core "qorus-core" process.

    When jobs run in separate @ref qjob "qjob" processes, it provides a higher level of stability and control to
    the integration platform as a whole, as a workflow with implementation problems cannot cause the integration
    platform to fail.

    There is a performance cost to running in separate @ref qjob "qjob" processes; job startup and shutdown is
    slightly slower, and communication with @ref qorus-core "qorus-core" also suffers a performance hit as all
    communication must be serialized and transmitted over the network.

    Furthermore memory usage is significantly higher for interfaces running in separate programs, as all the common
    infrastructure for each interface must be duplicated in each process.

    The default for this option depends on the client option @ref remote (if this client option is
    not set, then the default value is @ref True).

    The remote value can be changed at runtime by using the following REST API:
    @ref rest_api_PUT_latest_jobs__id_or_name__setRemote

    @note The \c remote flag is considered to be @ref managed_by_operations "managed by operations",
    which means that once an interface has been loaded into Qorus, if its \c remote flag is updated with the API,
    then those API-driven changes are persistent and will not be overwritten by subsequent loads of the
    interface by @ref oload "oload".

    @subsection job_active Job Active Flag

    A boolean value giving the active status of the job; if not present, the default is \c True.

    An inactive job is only run on demand; its schedule is ignored.

    @subsection job_schedule Job Schedule

    A cron specification, either this value or the \c duration attribute must be set, but not both.

    Job schedules follow the format of a cron job time specification; it is made up of 5 fields separated by spaces as
    follows:

    |!Field|!Values
    |\c minutes|\c 0-59
    |\c hours|\c 0-23
    |<tt>days of month</tt>|\c 1-31
    |\c months|\c 1-12 (or 3-letter English month abbreviations: <tt>Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, \
        Oct, Nov, Dec</tt>)
    |<tt>days of week</tt>|\c 0-7 (\c 0 and \c 7 are Sunday, or 3-letter English day abbreviations: <tt>Sun, Mon, \
        Tue, Wed, Thu, Fri, Sat</tt>)

    Case is ignored when giving month or day of week abbreviations.  A field may be an asterisk (\c *), which stands
    for all possible values in that field.

    Lists and ranges are allowed (also ranges and lists of abbreviated names are allowed); examples:
    - <tt>1,2,5,9</tt>
    - <tt>0-4,8-12,15</tt>
    - <tt>mon-wed,thu,sat</tt>

    A skip/repeat specification can be appended with an asterisk (\c *) or a range in the format
    \"<b><tt>/</tt><i>number</i></b>\", which means that the job should run every <i>number</i> units (ie minutes,
    hours, days, etc) in the range.  For example:
    - \c *<tt>/2</tt>: means every 2 minutes (or hours, days, etc, depending on the field)
    - \c 0-12/3: means every 3 hours from 0 to 12 (if given in an hour field)

    Because fields are separated by spaces, no spaces are allowed within a field.

    @note The day of a command's execution can be specified by two fields, <tt>days of month</tt>, and
    <tt>days of week</tt>.  If both fields are restricted (ie, aren't \c *), the command will be run when either field
    matches the current time.  For example, \c "30 4 1,15 * fri" would cause a command to be run at 4:30 am on the 1st
    and 15th of every month, plus every Friday.

    Some examples:

    - run ten minutes after midnight, every day\n
      \c "10 0 * * *"

    - run at 2:35pm on the first of every month\n
      \c "35 14 1 * *"

    - run at 11 pm on weekdays\n
      \c "0 23 * * mon-fri"

    - run 34 minutes after the hour, every other hour, every day\n
      <tt>\"34 *</tt><tt>/2 * * *\"</tt>

    - run at 5 after 4am every Sunday\n
      \c "5 4 * * sun"

    @note The job's schedule value is considered to be @ref managed_by_operations "managed by operations",
    which means that once a job has been loaded into Qorus, if its schedule is updated with the API,
    then those API-driven changes are persistent and will not be overwritten by subsequent loads of the job by
    @ref oload "oload".

    @since Qorus 2.7.0.p2 added support for the skip/repeat specification (\"<b><tt>/</tt><i>number</i></b>\")

    @subsection job_run_skipped Job Run Skipped Flag

    A boolean value telling the system if the job should be run immediately if the last scheduled run was missed due
    to system downtime or the job being disabled; if not present, the default is \c True

    @subsection job_expiry_date Job Expiry Date

    An optional expiration date; the job will not be run (and will be automatically set to inactive) when the
    expiration date is reached.

    @subsection job_class_name Job Class Name

    Indicates the class name of the job's class; this allows the job to have names that are not valid identifiers in
    the source language.

    @subsection job_lang Job Language

    The programming language used for the job implementation.

    @subsection job_source Job Source Code

    The implementation of the job must be made in the programming language given by @ref job_lang; the main job class
    must inherit one of the following classes depending on the source language:
    - \b %Python: @ref OMQ::UserApi::Job::QorusJob "job.QorusJob"
    - \b Java: @ref OMQ::UserApi::Job::QorusJob "QorusJob"
    - \b %Qore: @ref OMQ::UserApi::Job::QorusJob "QorusJob"

    The job's logic will be executed by calling the \c run() method for the job, unless a \c run trigger for a
    @ref finite_state_machines "finite state machine" or @ref devintro_no_code_connections "class connection" has been
    defined; in that case the job's source code is ignored.

    @par Example Python Job Definition: example-job-v1.0.qjob:
    @code{.py}
class PythonSimpleTest(job.QorusJob):
    def run(self):
        UserApi.logInfo("job info: %y", getInfo())
    @endcode

    @par Example Java Classpath Tag Value
    @verbatim classpath: $OMQ_DIR/user/jar/my-jar-1.jar:$OMQ_DIR/user/jar/my-jar-2.jar @endverbatim

    @par Example Java Job Definition: MyJavaExampleJob.java
    @code{.java}
package com.qoretechnologies.qorus.example;

import qore.OMQ.UserApi.Job.QorusJob;

class MyJavaExampleJob extends QorusJob {
    // the run method implments the job's logic
    public void run() throws Throwable {
        logInfo("test job info: %y", getInfo());
    }
}
    @endcode

    @note
    - The \c classpath tag can be used to add entries to the classpath for Java classes; \c $OMQ_DIR can be used
      in classpath entries as in the above example and will be resolved to the Qorus directory; see
      @ref javadevelopment_classpath for more information

    @par Example %Qore Job Definition: example-job-v1.0.qjob:
    @code{.py}
%new-style
%require-types
%strict-args
%enable-all-warnings

class MyExampleJob inherits QorusJob {
    # the run() method implements the job's logic
    run() {
        logInfo("job info: %y", getInfo());
    }
}
    @endcode

    @note
    - Job logic defined in the \c run() method of a job class can be implemented by @ref finite_state_machines
      instead; in case a @ref finite_state_machines "Finite State Machine" has the \c run trigger in a job, the
      \c run() method logic defined in the job class will never be executed, and the method body should remain
      empty.
    - The run method can also be implemented by a @ref devintro_no_code_connections "class connection" using the
      \c run trigger

    @subsection job_library Job Library

    Jobs support @ref library_objects "library objects" that provide additional code for the job.

    @see @ref library_objects for more information

    @subsection job_mappers Job Mappers

    An optional list of @ref mappers "mappers" that are used in the job.

    @see
    - @ref mappers
    - @ref mapper-devel-files

    @subsection job_vmaps Job Value Maps

    An optional list of @ref value-maps "value maps" that are used in the job.

    @see
    - @ref value-maps
    - @ref value-map-oload

    @subsection job_groups Job Groups

    An optional list of @ref rbacgroups "interface groups" that the job is a member of.

    Note that the job will be disabled if any of the interface groups is disabled; additionally, interface groups
    provide the ability to restrict users from accessing unauthorized configuration or data.

    @see @ref rbacgroups for more information

    @subsection job_modules Job Modules

    This attribute provides a list of %Qore-language modules that are loaded in the job's logic container that
    can provide base classes for the @ref job_source "job class" as well as other functionality for the job.

    @see @ref develmodules_job_modules for more information.

    @subsection classjobconstructors Job Constructors and Static Initialization

    Job classes can have a constructor and classes can have static initialization, but a job constructor cannot
    require any arguments.

    @subsection job_config_items Job Configuration Items

    Jobs can declare @ref devintro_no_code_config_items "configuration items" as metadata to allow the behavior of the
    job to be modified by users at runtime using the operational web UI or the REST API.

    Job configuration items are:
    -# Created by @ref oload "oload" when loading the job
    -# Read at runtime with job APIs to affect the functionality of the job
    -# Updated using the web UI using the REST API with @ref rest_api_PUT_latest_jobs__id_or_name__config__name_

    Job configuration items are designed to allow users to affect the execution of a job so that changes can be made
    by authorized users in the UI without requiring a change to development.

    @note All configuration item values are considered to be @ref managed_by_operations "managed by operations" by
    design, which means that once a configuration item has been loaded into Qorus, any changes to its value with the
    API are persistent and will not be overwritten by subsequent loads of the configuration item by
    @ref oload "oload".

    @anchor local_jobconfigitem
    @par Strictly Local Job Config Item

    If the \c strictly_local flag on a job configuration item is \c False, then the job configuration item is not local
    and the value can also be set on global level.

    If the \c strictly_local flag is \c True, then the job configuration item is local and hence the value for this item
    cannot be set on global level.

    @note All configuration item values are considered to be @ref managed_by_operations "managed by operations" by
    design, which means that once a configuration item has been loaded into Qorus, any changes to its value with the
    API are persistent and will not be overwritten by subsequent loads of the configuration item by
    @ref oload "oload".

    @see @ref devintro_no_code_config_items
*/

/** @page finite_state_machines Finite State Machines / Flow Designer

    @tableofcontents

    @ref develguide "Back to the Developer's Guide Table of Contents"

    @section fsm_overview Overview of Finite State Machines / Flow Designer

    All Qorus integration objects are described by YAML metadata produced by our IDE, which is available as a free
    (as in free of charge and also open source) extension to
    <a href="https://code.visualstudio.com">Microsoft Visual Studio Code</a>, a multi-platform editor from Microsoft.
    The Qorus extension is called
    <a href="https://marketplace.visualstudio.com/items?itemName=qoretechnologies.qorus-vscode">Qorus Developer Tools</a>
    and can be installed directly from Visual Studio Code.

    Qorus's Flow Designer creates executable configurations called finite state machines that allow arbitrary logic to
    be configured and deployed by connecting integration objects, supporting no-code solutions when existing building
    blocks are sufficient to cover the implementation requirements.

    @note
    - Finite state machines can be defined for @ref stepdefs "workflow steps", @ref service_methods "service methods",
      or @ref job_source "jobs"; if any finite state machine is defined for a trigger, then any code also defined for
      that action is ignored, and only the finite state machine is executed.
    - Finite state machines are executed entirely on the server side based on their configuration; this differs from
      @ref devintro_no_code_connections "class connections", which are executed based on code generated directly in
      the IDE.

    @image html Qorus-IDE-4-FSM.png "Flow Designer Example" width=1000

    Finite state machines are made up of a set of @ref fsm_states "states" connected by
    @ref fsm_transitions "state transitions" which determine the flow of execution (and state data, for states that
    produce and accept data) and also control error handling.

    @section fsm_data_processing Data Processing in Finite State Machines

    Finite state machines can accept input data and produce output data as well; any input data submitted to the
    finite state machine when it is executed (either implicitly, such as when triggered from a service method call,
    other interface action, or event), is passed through the execution of the finite state machine; each state can
    accept or ignore its input data, and the data output by each state can be accepted or ignored by any states
    connected through transitions.

    @subsection fsm_state_input_data Finite State Machine Input Data

    When editing @ref devintro_no_code_config_items "config items" in finite machine states, the input data passed to
    the state from the previous state can be referenced as \c $local:input; for example to get the \c account-id key
    from local input, you can use:
    @verbatim $local:{input.account-id} @endverbatim

    Note the following example using input data in the argument of an @ref fsm_api_call_states "API call state"; the
    same approach can also be used in @ref devintro_no_code_config_items "config items" and other arguments in other
    state types.

    @image html Qorus-IDE-4-FSM-State-Config-Local-Input-Example.png "Referencing Local Input Data in an FSM State" width=40%

    @see @ref bb_template_strings for more information about accessing contextual data with template strings

    @section fsm_states Finite State Machine States

    Each state can be one of the following types:
    - Action state types:
      - @ref fsm_class_connector_states "class connector": executes the given class connector
      - @ref fsm_data_pipeline_states "data pipeline": executes the given data pipeline
      - standalone @ref mapper-devel "mapper": executes the given mapper
      - @ref fsm_api_call_states "API call": executes the given API
      - @ref fsm_search_single_states "Single-Record Search": executes a search for a single record in a data provider
      - @ref fsm_search_states "Record Search": executes a search for multiple records in a data provider
      - @ref fsm_create_states "Record Create": creates records in a data provider
      - @ref fsm_update_states "Record Update": updates records in a data provider
      - @ref fsm_delete_states "Record Search": deletes records in a data provider
    - Flow control state types:
      - @ref fsm_if_states "if state": provides logical branching
      - @ref fsm_block_states "block states": provides loop functionality

    @note A @ref mapper-devel "mapper" can also be considered a single-element @ref data_pipelines "data pipeline",
    because @ref mapper-devel "mappers" can also be elements of @ref data_pipelines "data pipelines".

    @subsection fsm_class_connector_states Finite State Machine Class Connector States

    A class connector state executes a @ref class_connectors "class connector" for the given class.  The state's input
    data is the class connector input data, and the state's output data is the connector's output data.

    The @ref class_config_items "class's config items" can be configured in the state as well.

    @image html Qorus-IDE-4-FSM-Connector-State.png "FSM Connector State" width=40%

    @subsection fsm_data_pipeline_states Finite State Machine Data Pipeline States

    A data pipeline state is a state that executes a @ref data_pipelines "data pipeline".  The input data to the state
    is the input data for the data pipeline.

    Finite state machine data pipeline states do not have any output data, as pipelines have no output data.

    Data pipelines do not have output data, because they are not necessarily linear; they can have any number of
    parallel queues, in which case there is no single final pipeline element; pipeline elements do not have output
    data but rather enqueue data for further processing, and in typical use cases the final data pipeline processor
    elements in a queue do not enqueu any data for further processing but rather write data to an output location, and
    finally data pipelines are designed to process large volumes of data (including the output processing of the
    data), therefore a bulk output of massive amounts of data is impractical and does not feature in the design of
    data pipelines.

    @image html Qorus-IDE-4-FSM-Pipeline-State.png "FSM Pipeline State" width=40%

    @subsection fsm_api_call_states Finite State Machine API Call States

    An API call state is a state in the flow where an API call is made to an accessible data provider supporting the
    request-response integration pattern in Qorus.

    These can be accessed through data provider factories, a connection supporting a data provider, or a remote Qorus
    connection.

    The input type of the API call state depends on the value of the <tt>Allow API Arguments</tt> switch.  If this
    switch is set to \c True, then there is no input type, and the state is compatible with all previous states, as
    the input data is used only as local context (as <tt>$local:input</tt>) when resolving arguments given in the
    state itself, otherwise the input type of the state is the request type.

    In all cases the output type is the response type.

    When the state is executed, the API is called using the argument data, either from input data (if
    <tt>Allow API Arguments</tt> is \c False) or from data given in the API call state itself (if
    <tt>Allow API Arguments</tt> is \c True) to form the request, and the response is returned as the output data of
    the state.

    The following is an example API call state:

    @image html Qorus-IDE-4-FSM-API-Call-State.png "API Call State Example" width=40%

    @subsubsection fsm_qorus_api_calls Qorus APIs in API Call States

    Qorus exports many convenient APIs through the \c qorus-api DataProvider factory that can be used in Finite State
    Machine.

    The following is a table listing the available APIs.

    @note Each API should be self-documenting, as they are introspected with documentation about each API and also
    about each argument.

    <b>Qorus APIs in the qorus-api DataProvider Factory</b>
    |!API Path|!Description
    |\c factory/qorus-api/data-provider/create|Executes a "create record" action in a record-based data provider; \
        also supports upserting / merging in supported data providers
    |\c factory/qorus-api/data-provider/delete|Executes a "delete record" action in a record-based data provider
    |\c factory/qorus-api/data-provider/do-request|Executes a request-response API call in an API-based data provider
    |\c factory/qorus-api/data-provider/search|Executes a record search action in a record-based data provider
    |\c factory/qorus-api/data-provider/search-bulk-iterator|Returns a bulk record iterator object suitable for \
        input to a data pipeline for record-based data providers
    |\c factory/qorus-api/data-provider/update|Executes a "record update" action in a record-based data provider
    |<tt>@ref qorus_api_jobs_disable "factory/qorus-api/jobs/disable"</tt>|Disables a job
    |<tt>@ref qorus_api_jobs_enable "factory/qorus-api/jobs/enable"</tt>|Enables a job
    |\c factory/qorus-api/jobs/get-job-result|Returns the result info for a job
    |\c factory/qorus-api/jobs/info|Returns metadata and status information for a job
    |\c factory/qorus-api/jobs/reset|Resets a job
    |<tt>@ref qorus_api_jobs_run "factory/qorus-api/jobs/run"</tt>|Runs a job and returns the result
    |\c factory/qorus-api/jobs/set-active|Activates a job
    |\c factory/qorus-api/jobs/set-inactive|Deactivates a job
    |\c factory/qorus-api/jobs/list|Provides data provider children representing all Qorus jobs
    |\c factory/qorus-api/jobs/list/<job-name-or-id>/enable|Enables the given job
    |\c factory/qorus-api/jobs/list/<job-name-or-id>/disable|Disables the given job
    |\c factory/qorus-api/jobs/list/<job-name-or-id>/info|Returns metadata and status information for the given job
    |\c factory/qorus-api/jobs/list/<job-name-or-id>/reset|Resets the given job
    |<tt>@ref qorus_api_list_x_run "factory/qorus-api/jobs/list/<job-name-or-id>/run"</tt>|Runs the given job and returns the result
    |\c factory/qorus-api/jobs/list/<job-name-or-id>/set-active|Activates the given job
    |\c factory/qorus-api/jobs/list/<job-name-or-id>/set-inactive|Deactivates the given job
    |\c factory/qorus-api/services/call-method|Calls a service method and returns the result
    |<tt>@ref qorus_api_services_disable "factory/qorus-api/services/disable"</tt>|Disables a service
    |<tt>@ref qorus_api_services_enable "factory/qorus-api/services/enable"</tt>|Enables a service
    |\c factory/qorus-api/services/info|Returns metadata and status information for a service
    |\c factory/qorus-api/services/load|Loads and initializes a service
    |\c factory/qorus-api/services/reset|Resets a service
    |\c factory/qorus-api/services/set-autostart|Sets the autostart value for a service
    |\c factory/qorus-api/services/unload|Unloads a service
    |\c factory/qorus-api/services/list|Provides data provider children representing all Qorus services
    |\c factory/qorus-api/services/list/<service-name-or-id>/call-method|Calls a method in the given service and \
        returns the result
    |\c factory/qorus-api/services/list/<service-name-or-id>/disable|Disables the given service
    |\c factory/qorus-api/services/list/<service-name-or-id>/enable|Enables the given service
    |\c factory/qorus-api/services/list/<service-name-or-id>/info|Returns metadata and status information for the \
        given service
    |\c factory/qorus-api/services/list/<service-name-or-id>/load|Loads the given service
    |\c factory/qorus-api/services/list/<service-name-or-id>/reset|Resets the given service
    |\c factory/qorus-api/services/list/<service-name-or-id>/set-autostart|Sets the autostart value for the given \
        service
    |\c factory/qorus-api/services/list/<service-name-or-id>/unload|Unloads the given service
    |<tt>@ref qorus_api_util_break "factory/qorus-api/util/break"</tt>|Executes a break action in a \
        @ref fsm_block_state_flow_control "Finite State Machine loop"
    |<tt>@ref qorus_api_util_continue "factory/qorus-api/util/continue"</tt>|Executes a continue action in a \
        @ref fsm_block_state_flow_control "Finite State Machine loop"
    |<tt>@ref qorus_api_util_get_data "factory/qorus-api/util/get-data"</tt>|Returns data for onwards processing in \
        subsequent @ref finite_state_machines "Finite State Machine" states
    |\c factory/qorus-api/util/log-message|Logs a message in the current log file in a \
        @ref finite_state_machines "Finite State Machine"
    |<tt>@ref qorus_api_util_post_async_queue "factory/qorus-api/util/post-async-queue"</tt>|Posts a value on an \
        @ref step_queue "asynchronous queue" for an @ref asyncsteps "asynchronous step"
    |<tt>@ref qorus_api_util_post_sla_error "factory/qorus-api/util/post-sla-error"</tt>|Posts an error event \
        metric on an @ref sla_tracking "SLA"
    |<tt>@ref qorus_api_util_post_sla_success "factory/qorus-api/util/post-sla-success"</tt>|Posts a success event \
        metric on an @ref sla_tracking "SLA"
    |<tt>@ref qorus_api_util_post_sync_event "factory/qorus-api/util/post-sync-event"</tt>|Posts a \
        @ref wf_sync_event_objects "workflow synchronization event" to enable any \
        @ref step_event_type "workflow synchronization steps" waiting on the event to continue processing
    |<tt>factory/qorus-api/util/rest-request</tt>|Makes a REST request and returns the response
    |\c factory/qorus-api/util/throw-exception|Throws an exception in a \
        @ref finite_state_machines "Finite State Machine"
    |<tt>@ref qorus_api_util_workflow_bind_event "factory/qorus-api/util/workflow/bind-event"</tt>|Binds a \
        @ref wf_sync_event_objects "workflow synchronization event" to a \
        @ref step_event_type "workflow synchronization step"
    |<tt>@ref qorus_api_util_workflow_bind_event_unposted "factory/qorus-api/util/workflow/bind-event-unposted"</tt>|\
        Binds a @ref wf_sync_event_objects "workflow synchronization event" to a \
        @ref step_event_type "workflow synchronization step" only if the event is unposted
    |<tt>@ref qorus_api_util_workflow_bind_subworkflow "factory/qorus-api/util/workflow/bind-subworkflow"</tt>|Binds \
        a subworkflow to a @ref subworkflowsteps "subworkflow step"
    |<tt>@ref qorus_api_util_workflow_get_feedback "factory/qorus-api/util/workflow/get-feedback"</tt>|Retrieves \
        @ref workflow_feedback "workflow feedback data" from a @ref subworkflowsteps "subworkflow step" in the \
        parent workflow
    |<tt>@ref qorus_api_util_workflow_leave_feedback "factory/qorus-api/util/workflow/leave-feedback"</tt>|Leaves \
        @ref workflow_feedback "workflow feedback data" from a @ref subworkflowsteps "subworkflow step" for the \
        parent workflow
    |<tt>@ref qorus_api_util_workflow_skip_async_step "factory/qorus-api/util/workflow/skip-async-step"</tt>|Skips \
        binding an @ref step_queue "asynchronous queue" entry to an @ref asyncsteps "asynchronous step"
    |<tt>@ref qorus_api_util_workflow_skip_event "factory/qorus-api/util/workflow/skip-event"</tt>|Skips binding a \
        @ref wf_sync_event_objects "workflow synchronization event" to a \
        @ref step_event_type "workflow synchronization step"
    |<tt>@ref qorus_api_util_workflow_skip_subworkflow "factory/qorus-api/util/workflow/skip-subworkflow"</tt>|Skips \
        binding a subworkflow to a @ref subworkflowsteps "subworkflow step"
    |<tt>@ref qorus_api_util_workflow_submit_async_key "factory/qorus-api/util/workflow/submit-async-key"</tt>|Binds \
        a @ref step_queue "asynchronous queue" key to an @ref asyncsteps "asynchronous step"
    |<tt>@ref qorus_api_util_write_output "factory/qorus-api/util/write-output"</tt>|Writes output data according to \
        a template hash
    |\c factory/qorus-api/workflows/block-order|Blocks a workflow order
    |\c factory/qorus-api/workflows/cancel-order|Cancels a workflow order
    |<tt>@ref qorus_api_workflows_create_order "factory/qorus-api/workflows/create-order"</tt>|Creates a workflow order
    |\c factory/qorus-api/workflows/exec-async|Executes a workflow order in a synchronous workflow execution \
        instance with an asynchronous call (the call returns immediately)
    |\c factory/qorus-api/workflows/exec-sync|Executes a workflow order in a synchronous workflow execution \
        instance with a synchronous call (the call returns when the workflow order has a final status)
    |\c factory/qorus-api/workflows/get-order-info|Returns order information for a workflow order
    |\c factory/qorus-api/workflows/retry-order|Retries a workflow order
    |\c factory/qorus-api/workflows/unblock-order|Unblocks a workflow order and resets its previous status
    |\c factory/qorus-api/workflows/uncancel-order|Uncancels a workflow order and resets its previous status
    |<tt>@ref qorus_api_workflows_disable "factory/qorus-api/workflows/disable"</tt>|Disables a workflow
    |<tt>@ref qorus_api_workflows_enable "factory/qorus-api/workflows/enable"</tt>|Enables a workflow
    |\c factory/qorus-api/workflows/info|Returns metadata and status information for a workflow
    |\c factory/qorus-api/workflows/reset|Resets a workflow
    |\c factory/qorus-api/workflows/set-autostart|Sets the autostart value for a workflow
    |\c factory/qorus-api/workflows/list|Provides data provider children representing all Qorus workflows
    |\c factory/qorus-api/workflows/list/<workflow-name-or-id>/disable|Disables the given workflow
    |\c factory/qorus-api/workflows/list/<workflow-name-or-id>/enable|Enables the given workflow
    |\c factory/qorus-api/workflows/list/<workflow-name-or-id>/exec-async|Executes a workflow order for the given \
        workflow in a synchronous workflow execution instance with an asynchronous call (the call returns immediately)
    |\c factory/qorus-api/workflows/list/<workflow-name-or-id>/exec-sync|Executes a workflow order for the given \
        workflow in a synchronous workflow execution instance with a synchronous call (the call returns when the \
        workflow order has a final status)
    |\c factory/qorus-api/workflows/list/<workflow-name-or-id>/info|Returns metadata and status information for the \
        given workflow
    |\c factory/qorus-api/workflows/list/<workflow-name-or-id>/reset|Resets the given workflow
    |\c factory/qorus-api/workflows/list/<workflow-name-or-id>/set-autostart|Sets the autostart value for the given \
        workflow

    @subsubsection qorus_api_jobs_disable Qorus Data Provider API: Disable Job

    @par Summary
    Disables a job and returns information about the job and the action executed

    @par Path to Data Provider API
    \c factory/qorus-api/jobs/disable

    @par Arguments
    - \c job: the job ID or name

    @par Return Value
    - \c name (string): the job's name
    - \c version (string): the job's version
    - \c jobid (int): the job ID
    - \c info (string): a string giving the status of the operation

    @subsubsection qorus_api_jobs_enable Qorus Data Provider API: Enable Job

    @par Summary
    Enables a job and returns information about the job and the action executed

    @par Path to Data Provider API
    \c factory/qorus-api/jobs/enable

    @par Arguments
    - \c job: the job ID or name

    @par Return Value
    - \c name (string): the job's name
    - \c version (string): the job's version
    - \c jobid (int): the job ID
    - \c info (string): a string giving the status of the operation

    @subsubsection qorus_api_jobs_run Qorus Data Provider API: Run Job

    @par Summary
    Runs a job and returns the result

    @par Path to Data Provider API
    \c factory/qorus-api/jobs/run

    @par Arguments
    - \c job: the job ID or name

    @par Return Value
    - \c job_instanceid: the unique ID of the result of running the job
    - \c status: The job status (either @ref OMQ::StatComplete "COMPLETE" or @ref OMQ::StatError "ERROR")

    @subsubsection qorus_api_list_x_run Qorus Data Provider API: Run Implicit Job

    @par Summary
    Runs the job identified in the data provider path and returns the result

    @par Path to Data Provider API
    <tt>factory/qorus-api/jobs/list/<i>job-name-or-id</i>/run</tt>

    @par Arguments
    This API takes no arguments

    @par Return Value
    - \c job_instanceid: the unique ID of the result of running the job
    - \c status: The job status (either @ref OMQ::StatComplete "COMPLETE" or @ref OMQ::StatError "ERROR")

    @subsubsection qorus_api_services_disable Qorus Data Provider API: Disable Service

    @par Summary
    Disables a service and returns information about the service and the action executed

    @par Path to Data Provider API
    \c factory/qorus-api/services/disable

    @par Arguments
    - \c service: the service ID or name

    @par Return Value
    - \c name (string): the service's name
    - \c version (string): the service's version
    - \c serviceid (int): the service ID
    - \c info (string): a string giving the status of the operation

    @subsubsection qorus_api_services_enable Qorus Data Provider API: Enable Service

    @par Summary
    Enables a service and returns information about the service and the action executed

    @par Path to Data Provider API
    \c factory/qorus-api/services/enable

    @par Arguments
    - \c service: the service ID or name

    @par Return Value
    - \c name (string): the service's name
    - \c version (string): the joserviceb's version
    - \c serviceid (int): the service ID
    - \c info (string): a string giving the status of the operation

    @subsubsection qorus_api_workflows_create_order Qorus Data Provider API: Create Order

    @par Path to Data Provider API
    \c factory/qorus-api/workflow/create-order

    @par Summary
    Creates a workflow order for processing

    @par Arguments
    - \c workflow: The workflow name, name:version, or workflow ID for the order to be created
    - \c staticdata: The initial static data for the order
    - \c dynamicdata: The initial dynamic data for the order
    - \c external_order_instanceid: An optional external ID for the workflow order
    - \c sensitive_data: A hash of sensitive data information for the workflow; this key can only be used when
      submitting the data over a secure (encrypted) connection; the keys are sensitive data key types, values are
      hashes keyed by sensitive data values, and the hash values have the following keys:
        - \c aliases: (optional list of strings) zero or more string aliases for the sensitive data
        - \c data: (hash) the sensitive data hash itself
        - \c meta: (optional hash) a hash of metadata for the sensitive data with the following recommended keys
          (recommended keys are not enforced by the API itself):
          - \c PURPOSE: free-form information about the purpose of the sensitive data
          - \c CATEGORIES: free-form information about the categories of sensitive data
          - \c RECIPIENTS: free-form information about the recipients or recipient catories of sensitive data
          - \c STORAGE: free-form information about the storage time or rules for sensitive data
    - \c status: The initial order status (default if not present @ref OMQ::StatReady "READY"); must be either
      @ref OMQ::StatReady "READY" or @ref OMQ::StatBlocked "BLOCKED"
    - \c parent_workflow_instanceid: A loosely-coupled workflow that will be marked as the parent of this workflow
    - \c priority: The order priority from 0 - 999; priority 0 is the highest; 999 is the lowest
    - \c scheduled: The earliest date and time the order can be processed; if this date is given as a future date/time
      value and a @ref OMQ::StatReady "READY" tatus is given, then the initial status of the workflow order data
      instance will be automatically changed to @ref OMQ::StatScheduled "SCHEDULED"
    - \c global_unique_key: A hash giving one or more unique @ref wf_keylist "order keys" for the order (across all
      workflows regardless of workflowid, name, or version); keys are order key names and values are the string key
      values; if this key already exists for any order in the system, then the order creation will fail with a
      \c DUPLICATE-ORDER-KEY error; the hash key must be a valid @ref wf_keylist "order key", and the value is the
      unique key value; this value will also be created as an @ref wf_keylist "order key"
    - \c workflow_specific_unique_key: A hash giving one or more unique @ref wf_keylist "order keys" for the
      particular workflowid (which matches a unique name and workflow version); keys are order key names and values
      are the string key values; if any of the keys given already exists for an order with the target workflowid, then
      the order creation will fail with a \c DUPLICATE-ORDER-KEY error; the hash key must be a valid
      @ref wf_keylist "order key", and the value is the unique key value; this value will also be created as an
      @ref wf_keylist "order key"
    - \c workflow_unique_key: A hash giving one or more unique @ref wf_keylist "order keys" for the particular
      workflow by name only (across all workflows with the same name regardless of version); keys are order key names
      and values are the string key values; if this key already exists for a workflow order with the same name, then
      the order creation will fail with a \c DUPLICATE-ORDER-KEY error; the hash key must be a valid
      @ref wf_keylist "order key", and the value is the unique key value; this value will also be created as an
      @ref wf_keylist "order key"
    - \c orderkeys: A hash of @ref wf_keylist "order keys" for the order

    @subsubsection qorus_api_workflows_disable Qorus Data Provider API: Disable Workflow

    @par Summary
    Disables a workflow and returns information about the workflow and the action executed

    @par Path to Data Provider API
    \c factory/qorus-api/workflow/disable

    @par Arguments
    - \c workflow: the workflow ID or name

    @par Return Value
    - \c name (string): the workflow's name
    - \c version (string): the workflow's version
    - \c workflowid (int): the workflow ID
    - \c info (string): a string giving the status of the operation

    @subsubsection qorus_api_workflows_enable Qorus Data Provider API: Enable Workflow

    @par Summary
    Enables a workflow and returns information about the workflow and the action executed

    @par Path to Data Provider API
    \c factory/qorus-api/workflow/enable

    @par Arguments
    - \c workflow: the workflow ID or name

    @par Return Value
    - \c name (string): the workflow's name
    - \c version (string): the workflow's version
    - \c workflowid (int): the workflow ID
    - \c info (string): a string giving the status of the operation

    @subsubsection qorus_api_util_break Qorus Data Provider API: Break

    @par Path to Data Provider API
    \c factory/qorus-api/util/break

    @par Summary
    Executes a break action in a @ref fsm_block_state_flow_control "Finite State Machine loop"

    @par Arguments
    This API takes no arguments

    @subsubsection qorus_api_util_continue Qorus Data Provider API: Continue

    @par Path to Data Provider API
    \c factory/qorus-api/util/continue

    @par Summary
    Executes a continue action in a @ref fsm_block_state_flow_control "Finite State Machine loop"

    @par Arguments
    This API takes no arguments

    @subsubsection qorus_api_util_get_data Qorus Data Provider API: Get Data

    @par Path to Data Provider API
    \c factory/qorus-api/util/get-data

    @par Summary
    Returns data for onwards processing in subsequent @ref finite_state_machines "Finite State Machine" states.

    The argument can be of any type; as all API state arguments are subjected to automatic template substitution, this
    argument can also contain template strings.

    @subsubsection qorus_api_util_post_async_queue Qorus Data Provider API: Post Async Queue

    @par Path to Data Provider API
    \c factory/qorus-api/util/post-async-queue

    @par Summary
    Posts a value to an @ref step_queue "asynchronous workflow step queue"

    @par Arguments
    - \c queue: The name of the @ref step_queue "asynchronous queue"
    - \c data: data to post on the queue; must be in hash format (or @ref nothing)

    @par Details
    Updates a pending entry in an @ref step_queue "asynchronous step queue" with status
    @ref OMQ::QS_Waiting "WAITING" to @ref OMQ::QS_Received "RECEIVED".\n\n
    Data is stored serialized in YAML format, so that type information is preserved when passed to the step's
    @ref asyncbackendcode "asynchronous back-end code".

    @subsubsection qorus_api_util_post_sla_error Qorus Data Provider API: Post SLA Error Event

    @par Path to Data Provider API
    \c factory/qorus-api/util/post-sla-error

    @par Summary
    Posts an error event metric on an @ref sla_tracking "SLA"

    @par Arguments
    - \c sla: the name of the @ref sla_tracking "SLA"
    - \c value: The metric for the error event
    - \c err: the error code
    - \c desc: the error description

    @subsubsection qorus_api_util_post_sla_success Qorus Data Provider API: Post SLA Success Event

    @par Path to Data Provider API
    \c factory/qorus-api/util/post-sla-success

    @par Summary
    Posts a success event metric on an @ref sla_tracking "SLA"

    @par Arguments
    - \c sla: the name of the @ref sla_tracking "SLA"
    - \c value: The metric for the error event

    @subsubsection qorus_api_util_post_sync_event Qorus Data Provider API: Post Synchronization Event

    @par Path to Data Provider API
    \c factory/qorus-api/util/post-sync-event

    @par Summary
    Posts a @ref wf_sync_event_objects "workflow synchronization event" to enable any
    @ref step_event_type "workflow synchronization steps" waiting on the event to continue processing.

    @par Arguments
    - \c type: The @ref wf_sync_event_objects "workflow synchronization event type" for the event to post
    - \c key: The unique event key name of the event type to post

    @subsubsection qorus_api_util_workflow_bind_event Qorus Data Provider API: Bind Workflow Synchronization Event

    @par Path to Data Provider API
    \c factory/qorus-api/util/workflow/bind-event

    @par Summary
    Binds a @ref wf_sync_event_objects "workflow synchronization event" to a
    @ref step_event_type "workflow synchronization step".

    @note This API can only be called from a @ref step_event_type "workflow synchronization step"

    @subsubsection qorus_api_util_workflow_bind_event_unposted Qorus Data Provider API: Bind Workflow Synchronization Event Unposted

    @par Path to Data Provider API
    \c factory/qorus-api/util/workflow/bind-event-unposted

    @par Summary
    Binds a @ref wf_sync_event_objects "workflow synchronization event" to a
    @ref step_event_type "workflow synchronization step" but only if the event is still unposted.

    @note This API can only be called from a @ref step_event_type "workflow synchronization step"

    @subsubsection qorus_api_util_workflow_bind_subworkflow Qorus Data Provider API: Bind Subworkflow

    @par Path to Data Provider API
    \c factory/qorus-api/util/workflow/bind-subworkflow

    @par Summary
    Binds a subworkflow to a @ref subworkflowsteps "subworkflow step"

    @par Arguments
    - \c workflow: The workflow name, name:version, or workflow ID for the order to be created
    - \c staticdata: The initial static data for the order
    - \c dynamicdata: The initial dynamic data for the order
    - \c external_order_instanceid: An optional external ID for the workflow order
    - \c sensitive_data: A hash of sensitive data information for the workflow; this key can only be used when
      submitting the data over a secure (encrypted) connection; the keys are sensitive data key types, values are
      hashes keyed by sensitive data values, and the hash values have the following keys:
        - \c aliases: (optional list of strings) zero or more string aliases for the sensitive data
        - \c data: (hash) the sensitive data hash itself
        - \c meta: (optional hash) a hash of metadata for the sensitive data with the following recommended keys
          (recommended keys are not enforced by the API itself):
          - \c PURPOSE: free-form information about the purpose of the sensitive data
          - \c CATEGORIES: free-form information about the categories of sensitive data
          - \c RECIPIENTS: free-form information about the recipients or recipient catories of sensitive data
          - \c STORAGE: free-form information about the storage time or rules for sensitive data
    - \c parent_workflow_instanceid: A loosely-coupled workflow that will be marked as the parent of this workflow
    - \c priority: The order priority from 0 - 999; priority 0 is the highest; 999 is the lowest
    - \c scheduled: The earliest date and time the order can be processed; if this date is given as a future date/time
      value and a @ref OMQ::StatReady "READY" tatus is given, then the initial status of the workflow order data
      instance will be automatically changed to @ref OMQ::StatScheduled "SCHEDULED"
    - \c global_unique_key: A hash giving one or more unique @ref wf_keylist "order keys" for the order (across all
      workflows regardless of workflowid, name, or version); keys are order key names and values are the string key
      values; if this key already exists for any order in the system, then the order creation will fail with a
      \c DUPLICATE-ORDER-KEY error; the hash key must be a valid @ref wf_keylist "order key", and the value is the
      unique key value; this value will also be created as an @ref wf_keylist "order key"
    - \c workflow_specific_unique_key: A hash giving one or more unique @ref wf_keylist "order keys" for the
      particular workflowid (which matches a unique name and workflow version); keys are order key names and values
      are the string key values; if any of the keys given already exists for an order with the target workflowid, then
      the order creation will fail with a \c DUPLICATE-ORDER-KEY error; the hash key must be a valid
      @ref wf_keylist "order key", and the value is the unique key value; this value will also be created as an
      @ref wf_keylist "order key"
    - \c workflow_unique_key: A hash giving one or more unique @ref wf_keylist "order keys" for the particular
      workflow by name only (across all workflows with the same name regardless of version); keys are order key names
      and values are the string key values; if this key already exists for a workflow order with the same name, then
      the order creation will fail with a \c DUPLICATE-ORDER-KEY error; the hash key must be a valid
      @ref wf_keylist "order key", and the value is the unique key value; this value will also be created as an
      @ref wf_keylist "order key"
    - \c orderkeys: A hash of @ref wf_keylist "order keys" for the order

    @par Details
    This API is the alternative to calling @ref qorus_api_util_workflow_skip_subworkflow

    @note This API can only be called from a @ref subworkflowsteps "subworkflow step"

    @subsubsection qorus_api_util_workflow_get_feedback Qorus Data Provider API: Get Child Feedback

    @par Path to Data Provider API
    \c factory/qorus-api/util/workflow/get-feedback

    @par Summary
    This API retrieves @ref workflow_feedback "workflow feedback data" from a child order given the feedback key used
    by the child.

    @par Arguments
    - \c key: the key used by the child to leave @ref workflow_feedback "workflow feedback data"

    @par Details
    Internally this API is implemented with a call to
    @ref OMQ::UserApi::Workflow::WorkflowApi::getChildFeedback() "WorkflowApi::getChildFeedback()", so its
    behavior is the same.\n\n
    Child workflows can leave data to be retrieved by this API with @ref qorus_api_util_workflow_leave_feedback or with
    @ref OMQ::UserApi::Workflow::WorkflowApi::leaveParentFeedback() "WorkflowApi::leaveParentFeedback()".

    @note This API can only be called from an @ref subworkflowsteps "subworkflow step"

    @subsubsection qorus_api_util_workflow_leave_feedback Qorus Data Provider API: Leave Parent Feedback

    @par Path to Data Provider API
    \c factory/qorus-api/util/workflow/leave-feedback

    @par Summary
    This API leaves @ref workflow_feedback "workflow feedback data" in a child order for retrieval in the parent
    workflow.

    @par Arguments
    - \c key: the key used by the child to leave @ref workflow_feedback "workflow feedback data"

    @par Details
    Internally this API is implemented with a call to
    @ref OMQ::UserApi::Workflow::WorkflowApi::leaveParentFeedback() "WorkflowApi::leaveParentFeedback()", so its
    behavior is the same.\n\n
    The parent workflow can retrieve the data left by this API with @ref qorus_api_util_workflow_get_feedback or with
    @ref OMQ::UserApi::Workflow::WorkflowApi::getChildFeedback() "WorkflowApi::getChildFeedback()".

    @note This API can only be called from a child order created from a @ref subworkflowsteps "subworkflow step" in
    the parent.

    @subsubsection qorus_api_util_workflow_skip_async_step Qorus Data Provider API: Skip Async Step

    @par Path to Data Provider API
    \c factory/qorus-api/util/workflow/skip-async-step

    @par Summary
    This API will cause the execution of an @ref asyncsteps "asynchronous step" to be skipped.

    @par Arguments
    This API takes no arguments

    @par Details
    This API is the alternative to calling @ref qorus_api_util_workflow_submit_async_key

    @note This API can only be called from an @ref asyncsteps "asynchronous step"

    @subsubsection qorus_api_util_workflow_skip_event Qorus Data Provider API: Skip Workflow Synchronization Event Step

    @par Path to Data Provider API
    \c factory/qorus-api/util/workflow/skip-event

    @par Summary
    Skips binding a @ref wf_sync_event_objects "workflow synchronization event" to a
    @ref step_event_type "workflow synchronization step"

    @par Arguments
    This API takes no arguments

    @note This API can only be called from a @ref step_event_type "workflow synchronization step"

    @subsubsection qorus_api_util_workflow_skip_subworkflow Qorus Data Provider API: Skip Subworkflow

    @par Path to Data Provider API
    \c factory/qorus-api/util/workflow/skip-subworkflow

    @par Summary
    Skips binding a subworkflow to a @ref subworkflowsteps "subworkflow step"

    @par Arguments
    This API takes no arguments

    @par Details
    This API is the alternative to calling @ref qorus_api_util_workflow_bind_subworkflow

    @note This API can only be called from a @ref subworkflowsteps "subworkflow step"

    @subsubsection qorus_api_util_workflow_submit_async_key Qorus Data Provider API: Submit Workflow Async Key

    @par Path to Data Provider API
    \c factory/qorus-api/util/workflow/submit-async-key

    @par Summary
    Binds a @ref step_queue "asynchronous queue" key to an @ref asyncsteps "asynchronous step".

    @par Arguments
    - \c key: the key for the @ref step_queue "asynchronous queue" entry; must be unique in the
      @ref step_queue "queue"; this key along with the queue name must be used later to update the queue to cause the
      step to go to a @ref OMQ::StatComplete "COMPLETE" status.

    @par Details
    This API is the alternative to calling @ref qorus_api_util_workflow_skip_async_step

    @note This API can only be called from an @ref asyncsteps "asynchronous step"

    @subsubsection qorus_api_util_write_output Qorus Data Provider API: Write Output API Data Provider

    @par Path to Data Provider API
    \c factory/qorus-api/util/write-output

    @par Summary
    Writes output data to locations provided by the hash argument, which should be assigned a hash as follows.

    @par Argument Format
    \a key (data to write)  \a location (output location)

    @par YAML Argument Example
    @verbatim
\$local:input: \$dynamic:account
    @endverbatim

    @par Details
    This above argument would result in FSM input data being stored in the \c account key of workflow dynamic data
    when executed in a workflow context.\n\n
    Hash keys in the argument are subject to template substitution with
    @ref OMQ::UserApi::UserApi::expandTemplatedValue() "UserApi::expandTemplatedValue()" (where \c \$local:input
    represents input data to the current state); hash values provide the output locations to store the values
    according to @ref template_substitution_table "template substitution strings" marked as writable (\c W).\n\n
    Hash keys must be strings when passed to the internal API call, therefore any \c $ signs must be escaped.\n\n
    Hash values must be strings representing output locations, therefore any \c $ signs must also be escaped.

    @note
    - \c \$local:input represents FSM state input data
    - Template values in API call arguments are automatically evaluated before being passed to the data provider; for
      this reason, all \c $ signs must be escaped with a backslash as in the above example, so they are evaluated by
      the Qorus API call itself and not during standard template evaluation of API call arguments by Qorus.

    @note This API only works when called from a Qorus interface, as an interface context is needed for writing output
    data.

    @subsection fsm_search_single_states Finite State Machine Single Record Search States

    A single record search state uses the parameters configured in the state to execute a search for a single record
    in a record-based data provider, such a DB table or a platform that presents a table-like interface through the
    data provider API.

    These can be accessed through data provider factories, a datasource connection, a connection supporting a data
    provider, or a remote Qorus connection.

    @image html images/Qorus-IDE-4-FSM-Search-Single-State.png "Finite State Machine Single Record Search State" width=40%

    This state has no input type, meaning that it's compatible with all other states on input.  Input data is used
    only as local context (as <tt>$local:input</tt>) when resolving arguments given in the state itself.

    If the \c required_result option is @ref True "True", then a search returning no record causes a
    \c SEARCH-SINGLE-RESULT-ERROR exception to be raised.  In this case the output type is always the record type of
    the data provider.

    In case a result is not required, the output type can also be no value.

    @note Use @ref fsm_search_states when the search can return more than one record

    @subsection fsm_search_states Finite State Machine Multiple Record Search States

    A multiple record search state uses the parameters configured in the state to execute a search for a record set
    in a record-based data provider, such a DB table or a platform that presents a table-like interface through the
    data provider API.

    These can be accessed through data provider factories, a datasource connection, a connection supporting a data
    provider, or a remote Qorus connection.

    @image html images/images/Qorus-IDE-4-FSM-Search-State.png "Finite State Machine Multiple Record Search State" width=40%

    This state has no input type, meaning that it's compatible with all other states on input.  Input data is used
    only as local context (as <tt>$local:input</tt>) when resolving arguments given in the state itself.

    If the \c required_result option is @ref True "True", then a search returning no records causes a
    \c SEARCH-RESULT-ERROR exception to be raised.  In this case the output type is always the record type of
    the data provider.

    In case a result is not required, the output type can also be no value.

    @subsection fsm_update_states Finite State Machine Record Update States

    A record update state uses the parameters configured in the state to update records based on search criteria and
    update criteria; the updates are performed in the given record-based data provider, such a DB table or a platform
    that presents a table-like interface through the data provider API.

    These can be accessed through data provider factories, a datasource connection, a connection supporting a data
    provider, or a remote Qorus connection.

    @image html Qorus-IDE-4-FSM-Update-State.png "Finite State Machine Record Update State" width=40%

    This state has no input type, meaning that it's compatible with all other states on input.  Input data is used
    only as local context (as <tt>$local:input</tt>) when resolving arguments given in the state itself.

    If the \c required_result option is @ref True "True", then an update operation updating no records causes a
    \c UPDATE-RESULT-ERROR exception to be raised.

    In all cases the output type of this state is a hash with a single key: \c records_affected, where the value is
    the number of rows updated by the operation.

    @subsection fsm_delete_states Finite State Machine Record Delete States

    A record delete state uses the parameters configured in the state to delete records based on search criteria; the
    deletes are performed in the given record-based data provider, such a DB table or a platform that presents a
    table-like interface through the data provider API.

    These can be accessed through data provider factories, a datasource connection, a connection supporting a data
    provider, or a remote Qorus connection.

    @image html Qorus-IDE-4-FSM-Delete-State.png "Finite State Machine Record Delete State" width=40%

    This state has no input type, meaning that it's compatible with all other states on input.  Input data is used
    only as local context (as <tt>$local:input</tt>) when resolving arguments given in the state itself.

    If the \c required_result option is @ref True "True", then a delete operation deleting no records causes a
    \c DELETE-RESULT-ERROR exception to be raised.

    In all cases the output type of this state is a hash with a single key: \c records_affected, where the value is
    the number of rows deleted by the operation.

    @subsection fsm_create_states Finite State Machine Record Create States

    A record create state uses the parameters configured in the state to create records; new records are created in
    the given record-based data provider, such a DB table or a platform that presents a table-like interface through
    the data provider API.

    These can be accessed through data provider factories, a datasource connection, a connection supporting a data
    provider, or a remote Qorus connection.

    @image html Qorus-IDE-4-FSM-Create-State.png "Finite State Machine Record Create State" width=40%

    This state has no input type, meaning that it's compatible with all other states on input.  Input data is used
    only as local context (as <tt>$local:input</tt>) when resolving arguments given in the state itself.

    In all cases the output type of this state is the record type; the output value is the list of records created.

    @subsection fsm_block_states Finite State Machine Block States

    Block states support executing a group of states as a "block"; there are \c for, \c foreach, and \c while block
    states.

    A type of "local variable" is implemented for blocks in the @ref bb-tmpl-var expression; each block has
    its own copies of variables in this hash, also a type of "global variable" if implemented in the
    @ref bb-tmpl-transient expression; see the previous links and @ref bb_template_strings for more information.

    The output data for a block is the output data for the last execution of the block defined by the output data of
    the last state to be executed in the block.

    @subsubsection fsm_block_state_flow_control Flow Control in Finite State Machine Block States

    When executing finite state machine blocks, the block's flow can be controlled by the following special
    exceptions:
    - \c FSM-BREAK: if this exception is thrown, a \c break action is performed, and the flow will exit the current
      block being executed
    - \c FSM-CONTINUE: if this exception is thrown a \c continue action is performed, and the flow will start again
      from the initial state, if there is another loop to be made in the block, otherwise the flow exits the
      current block

    These exception can also be thrown with the following API data providers:
    @see
    - @ref qorus_api_util_break
    - @ref qorus_api_util_continue

    @subsubsection fsm_for_block_states Finite State Machine For Block States

    Finite state machine \c for blocks implement a loop driven by the following configuration:
    - \a condition: the condition expression; @ref fsm_boolean_evaluation "evaluated" immediately before each
      iteration of the loop is executed; the loop stops executing when this expression
      @ref fsm_boolean_evaluation "evaluates" to @ref False
    - \a init: the initialization expression; the value of this expression will be stored in the location identifed by
      \a init_var; this expression is evaluated once at the start of the loop
    - \a init_var: a string value giving the field name in the <tt>$var:</tt> hash where the value of the \a init
      expression is stored
    - \a language: either \c qore or \c python, giving the language for
      @ref fsm_boolean_evaluation "expression evaluation"
    - \a update: the update expression for the \c for loop; if present, it is evaluted after each iteration of the
      loop is executed and before the \a condition expression is evaluated for the next iteration

    All expressions (\a init, \a condition, and \a update) are first substituted with a call to
    @ref OMQ::UserApi::UserApi::expandTemplatedValue() "UserApi::expandTemplatedValue()".  If the value returned is a
    string, then it is evaluated with the language defined by \a language.  If the value is any other type, then that
    value is used as the value of the expression without further evaluation.

    For more information on the boolean evaluation of the condition template expression, see
    @ref fsm_boolean_evaluation.

    @note
    - Both \a init and \a init_var must be present or both are ignored
    - Both \a update and \a update_var must be present or both are ignored
    - \c qore is the default for the expression evaluation language as it is fully multithreaded

    @see @ref bb_template_strings

    @anchor fsm_for_block_state_data
    @par Finite State Machine For State Data Processing

    The output data for a \c for block is the output data for the last state executed in the block.

    @subsubsection fsm_foreach_block_states Finite State Machine Foreach Block States

    Finite state machine \c foreach blocks implement a loop driven by a value or a list of values driven by the
    following configuration:
    - \a loop: This expression is evaluated once at the start of the \c foreach loop, and the value returned is used
      to execute the loop and determine the data submitted to the initial state(s) in the block.  If the expression
      evaluates to a list, then the loop is executed with each element of list in turn as the data for the initial
      state(s) in the block.  If the expression evaluates to a single value, then the \c foreach loop is executed once
      for that value. If the expression evaluates to no value, then \c foreach loop execution is skipped.
    - \a language: either \c qore or \c python, giving the language for expression evaluation

    The \a loop expression is first substituted with a call to
    @ref OMQ::UserApi::UserApi::expandTemplatedValue() "UserApi::expandTemplatedValue()".  If the value returned is a
    string, then it is evaluated with the language defined by \a language.  If the value is any other type, then that
    value is used as the value of the expression without further evaluation.

    @note \c qore is the default expression evaluation language as it is fully multithreaded

    @anchor fsm_foreach_block_state_data
    @par Finite State Machine Foreach State Data Processing

    The output data for a \c foreach block is the output data for the last state executed in the block.

    @subsubsection fsm_while_block_states Finite State Machine While Block States

    Finite state machine \c while blocks implement a loop driven by the following configuration:
    - \a condition: the condition expression; @ref fsm_boolean_evaluation "evaluated" immediately before each
      iteration of the loop is executed; the loop stops executing when this expression
      @ref fsm_boolean_evaluation "evaluates" to @ref False
    - \a language: either \c qore or \c python, giving the language for
      @ref fsm_boolean_evaluation "expression evaluation"

    The \a condition expression is first substituted with a call to
    @ref OMQ::UserApi::UserApi::expandTemplatedValue() "UserApi::expandTemplatedValue()".  If the value returned is a
    string, then it is evaluated with the language defined by \a language.  If the value is any other type, then that
    value is used as the value of the expression without further evaluation.

    For more information on the boolean evaluation of the condition template expression, see
    @ref fsm_boolean_evaluation.

    @note \c qore is the default for the expression evaluation language as it is fully multithreaded

    @anchor fsm_while_block_state_data
    @par Finite State Machine While State Data Processing

    The output data for a \c while block is the output data for the last state executed in the block.

    @subsection fsm_if_states Finite State Machine If States

    The \c if state is a special state that has a condition and \c True and \c False transitions.  The condition is a
    string expression that is first processed with
    @ref OMQ::UserApi::UserApi::expandTemplatedValue() "UserApi::expandTemplatedValue()".  If the result of this
    expression is a string, then it is interpreted as an expression in the given language (either \c qore or
    \c python).

    The value is then converted to a \c bool, which then triggers the execution of either the \c True transition(s) or
    the \c False transition(s).

    Transitions in \c if states cannot be further qualified with conditions on each transition.

    For more information on the boolean evaluation of the condition template expression, see
    @ref fsm_boolean_evaluation.

    @subsubsection fsm_if_state_data Finite State Machine If State Data Processing

    Input data is passed through as-is to states transitioned through \c if states.

    @subsection fsm_transitions Finite State Machine State Transitions

    State transitions determine the flow of execution in finite state machines.  At the end of executing each state,
    transitions are evaluated and executed in order.   Each state transition (if not a transition from an
    @ref fsm_if_states "if state") can be configured with a condition, which if
    @ref fsm_boolean_evaluation "evaluated" to @ref True, causes the flow
    of execution to continue to the next state.  If there is no condition associated with the transition, then the
    transition is executed unconditionally.

    State transition conditions can be either a string expression or a @ref class_connectors "class connector";
    when the condition is evaluated, the result is converted to a boolean value as described
    @ref fsm_boolean_evaluation "here" which determines if the flow of execution continues to the next state or not.

    Transition expressions are first parsed with
    @ref OMQ::UserApi::UserApi::expandTemplatedValue() "UserApi::expandTemplatedValue()".  If the result of this
    expression is a string, then it is interpreted as an expression in the given language (either \c qore or
    \c python).

    In either case, the resulting value is converted to a \c bool to determine if the transition is followed or not.

    For more information on the boolean evaluation of the transition condition template expression, see
    @ref fsm_boolean_evaluation.

    @subsection fsm_error_transitions Finite State Machine State Error Transitions

    State transitions can also be configured with a string error value; if an exception is thrown during state
    execution, the exception error string is compared to the string error value, and if it matches, then execution
    continues in the target state.

    The error string is derived depending on the source language as follows:
    - \b %Python: the full error class name (ex: \c builtins.ValueError)
    - \b Java: the full error class name (ex: \c java.lang.NullPointerException)
    - \b %Qore: the error string code (ex: \c SOCKET-CONNECT-ERROR)

    @note An exact match to the actual exception class is made for %Python and Java; no subclass comparisons are made

    @subsubsection fsm_boolean_evaluation Finite State Machine Boolean Evaluation

    Finite state machine boolean evaluation is driven by two elements of configuration:
    - \a condition: a condition template expression
    - \a language: the evaluation language if \a condition evaluates to a string

    First, \a condition is evaluated with an internal call to
    @ref OMQ::UserApi::UserApi::expandTemplatedValue() "UserApi::expandTemplatedValue()".

    If the resulting value is a string, then it is evaluated with the language specified by \a language.

    If the resulting value is not a string, then it is evaluated per its data type according to the table below.

    @par Example 1
    In this example, the template is evaluated with a @ref fsm_state_input_data "local input context" with the
    following keys:
    @verbatim
{
    intent_name: "i.400.userID-correct",
    project_id: "02724364-f352-46a2-9279-083989c53360",
    session_id: "769113b8-ee2a-4495-acf3-b12bf4709790",
    timestamp: 1635493630000,
    timestamp_str: "Fri Oct 29 09:47:10 CEST+0200",
    parameters: {
        p_inbound_user_id: "SJ3ZA",
        yes: "ja"
    }
}
    @endverbatim
    The following template:
    @verbatim "$local:input.parameters.p_inbound_user_id".val() @endverbatim
    will be first subjected to template substitution, resulting in the following string:
    @verbatim "SJ3ZA".val() @endverbatim
    which will then be evaluated as a %Qore expression, resulting in the result \c True.
    @see @ref Qore::zzz8stringzzz9::val()

    @par Example 2
    If on the other hand, the following template would be evaluated in the same context as in the previous example:
    @verbatim "$local:input.parameters.p_outbound_user_id".val() @endverbatim
    This results in the following string after template substitution:
    @verbatim "".val() @endverbatim
    (because the \c "parameters" hash has no \c "p_outbound_user_id" key) which will then be evaluated as a %Qore
    expression, resulting in the result \c False.
    @see @ref Qore::zzz8stringzzz9::val()

    @par Example 3
    As an alternative to achieve the same results as in the first example, the following template string:
    @verbatim exists $qore-expr-value:{$local:input.parameters.p_inbound_user_id} @endverbatim
    will be first subjected to template substitution, resulting in the following string:
    @verbatim exists "SJ3ZA" @endverbatim
    which will then be evaluated as a %Qore expression, resulting in the result \c True.
    @see
    - @ref exists
    - @ref bb-tmpl-qore-expr-value

    @par Example 4
    If on the other hand, the following template would be evaluated in the same context as in the first example:
    @verbatim exists $qore-expr-value:{$local:input.parameters.p_outbound_user_id} @endverbatim
    This results in the following string after template substitution:
    @verbatim exists NOTHING @endverbatim
    (because the \c "parameters" hash has no \c "p_outbound_user_id" key) which will then be evaluated as a %Qore
    expression, resulting in the result \c False.
    @see
    - @ref exists
    - @ref bb-tmpl-qore-expr-value

    @note
    - To prohibit evaluation of a template value that results in a string, enclose the template in quotes; ex:
      \c "$local:version"
    - \c qore is the default expression evaluation language as it is fully multithreaded

    Once the template has been resolved, the value is processed according to its type as in the following table:

    @par Boolean Evaluation per Data Type
    |!Type|!Description
    |\c bool|value taken literally
    |\c string|@ref True if non empty and not \c "0", @ref False if empty or \c "0"
    |\c int, \c float, or \c number|@ref True if non zero, @ref False if zero
    |\c hash, \c list, \c binary|@ref True if non-empty, @ref False if empty
    |\c date|@ref True if not \c 1970-01-01Z or a zero duration, @ref False if \c 1970-01-01Z or a zero duration
    |\c nothing, \c null|@ref False

    @see @ref bb_template_strings
*/

/** @page data_pipelines Data Pipelines

    @tableofcontents

    @ref develguide "Back to the Developer's Guide Table of Contents"

    @section data_pipeline_intro Data Pipeline Introduction

    All Qorus integration objects are described by YAML metadata produced by our IDE, which is available as a free
    (as in free of charge and also open source) extension to
    <a href="https://code.visualstudio.com">Microsoft Visual Studio Code</a>, a multi-platform editor from Microsoft.
    The Qorus extension is called
    <a href="https://marketplace.visualstudio.com/items?itemName=qoretechnologies.qorus-vscode">Qorus Developer Tools</a>
    and can be installed directly from Visual Studio Code.

    @image html Qorus-IDE-4-Pipeline.png "Data Pipeline in the IDE" width=75%

    Data pipelines allow for complex and efficient processing of record-based data from a single input to an arbitrary
    number of outputs in an arbitrary number of processing queues.

    Data pipelines by default have a single processing queue (with queue ID 0); to split processing of a single input,
    the last element of a queue can be a list of queues, each of which taking the data record(s) and processing them
    in parallel with other queues at the same level.

    Besides the final element of a pipeline, which can be a series of queues for onwards parallel processing, each
    queue is a set of linear elements that takes data record input and outputs zero or more records to the next
    element in the pipeline.  Pipeline elements can:
    - transform data record(s)
    - filter data record(s)
    - generate new record(s)

    Note that all of the above operations can be performed at the same time on any given input record.

    Pipeline processing elements are made up of objects of the following types:
    - @ref data_pipeline_processors "processors"
    - @ref mapper-devel "mappers"

    In fact a @ref mapper-devel "mapper" is a specialized configuration-driven form of a
    @ref data_pipeline_processors "processor" that does data format conversions.

    @section data_pipeline_input Data Pipeline Input

    Data pipelines can process input data in one of three ways:
    - If an input provider was configured for the pipeline, the configuration for the input provider will provide the
      initial input data for the first elements in the pipeline
    - If no input provider was configured, then the current FSM state data can be submitted as the initial input data
      to the pipeline
    - The first element in the pipeline can ignore any input data provided by the above two mutually-exclusive options
      and submit its own data for further processing

    @note If an input data factory is configured, the current state data is available as <tt>$local:input</tt> when
    resolving factory options with
    @ref OMQ::UserApi::UserApi::expandTemplatedValue() "UserApi::expandTemplatedValue()".

    @section data_pipeline_processors Data Pipeline Processors

    A data pipeline processor is a @ref class_objects "Qorus class object" defined as a data processor (see
    @ref class_processor for more information).

    @section data_pipeline_bulk_processing Data Pipeline Bulk Processing

    Bulk processing is when a @ref data_pipeline_processors "data pipeline processor" is capable of processing data in
    "hash of lists" form.  This format is the most efficient way to process many records of data in a single
    operation which results in very fast and efficient processing for large amounts of data.
*/

/** @page other_objects Other Qorus Integration Objects

    @tableofcontents

    @ref develguide "Back to the Developer's Guide Table of Contents"

    @section other_objects_intro Introduction

    All Qorus integration objects are described by YAML metadata produced by our IDE, which is available as a free
    (as in free of charge and also open source) extension to
    <a href="https://code.visualstudio.com">Microsoft Visual Studio Code</a>, a multi-platform editor from Microsoft.
    The Qorus extension is called
    <a href="https://marketplace.visualstudio.com/items?itemName=qoretechnologies.qorus-vscode">Qorus Developer Tools</a>
    and can be installed directly from Visual Studio Code.

    @section class_objects Class Objects

    Class definition files containing YAML metadata and a reference to the source code file are used to create class
    objects in the Qorus schema that can then be used by other integration objects, such as workflows, services, jobs,
    mappers, or even other class objects.

    Class objects are the fundamental building block element of Qorus; they allow their code to be instrumented with
    @ref class_config_items "configuration" that should be designed to make them generically useful for many different
    use cases, and enable changes to be made with configuration rather than coding.

    Class definition files are parsed by the @ref oload "oload" program, which will create class objects in the Qorus
    database according to the definitions in the file.

    Classes have the following attributes:
    - @ref class_name
    - @ref class_version
    - @ref class_patch
    - @ref class_description
    - @ref class_author
    - @ref class_language
    - @ref class_source
    - @ref class_dependencies
    - @ref class_config_items
    - @ref class_connectors
    - @ref class_processor

    @subsection class_name Class Name

    The name of the class; the name and version together are unique identifiers for the class and are used to derive
    the classid (the single unique identifier for the class; it is generated from a database sequence when the class
    is loaded into the system via @ref oload "oload").

    Multiple classes with the same name and different versions can exist in the system at the same time.  Classes are
    referred to with their classid, which is derived from the name and version together (except in
    @ref library_objects, where the latest version of the class is used which is determined by the last creation date
    of the class object in the database, and not with a comparison of the version strings).

    @subsection class_version Class Version

    The version string for the class object; the name and version together are unique identifiers for the class and
    are used to derive the classid (the single unique identifier for the class; it is generated from a database
    sequence when the class is loaded into the system via @ref oload "oload").

    @note Two objects with the same \c name but different \c version values are different objects

    @subsection class_patch Class Patch

    A string "patch" label which can be used to show that a class was updated while not affecting the classid.

    @note The \c patch value can be updated without affecting references to other objects; the unique ID for the
    object is not updated when the \c patch value is updated

    @subsection class_description Class Description

    A description for the class; the description field supports markdown for formatted output in the UI and IDE.

    @subsection class_author Class Author

    The \c "author" value indicates the author of the class and will be returned with the class metadata in the
    REST API and also is displayed in the system UI.

    @subsection class_language Class Language

    The programming language for the class's source code; can be one of:
    - \c python
    - \c java
    - \c qore

    @subsection class_source Class Source

    The source code for the class implementation; must be in the programming language specified by @ref class_language

    The source can use other source code; see @ref class_dependencies

    @subsection class_dependencies Class Dependencies

    An optional list of classes that the class depends on; these other classes are also loaded into the interface's
    logic container when the class is listed as a dependency; in this way a single class can encapsulate multiple
    class object dependencies, which can simplify dependency management for complex class hierarchies and in
    interconnected code.

    @subsection class_config_items Class Configuration Items

    @ref devintro_no_code_config_items "Configuration items" are metadata describing configurable parameters that
    should define how the code of the class is executed at runtime.

    Configuration items have a name, a description (supporting markdown), a data type, and other attributes.

    Configuration item values can be set at three levels, the global level, the workflow level, and the configuration
    item level.  The value used is the lowest-level value set.

    The runtime value of a configuration item can be retrieved with the APIs in the following table:

    <b>Configuration Item Value APIs</b>
    |!API Type|!API|!Description
    |\b %Python|@ref OMQ::UserApi::Workflow::WorkflowApi::getConfigItemValue() "wfapi.getConfigItemValue()"|retrieves a single configuration item value
    |\b %Python|@ref OMQ::UserApi::Workflow::WorkflowApi::getConfigItemHash() "wfapi.getConfigItemHash()"|retrieves all configuration items
    |\b Java|@ref OMQ::UserApi::Workflow::WorkflowApi::getConfigItemValue() "WorkflowApi.getConfigItemValue()"|retrieves a single configuration item value
    |\b Java|@ref OMQ::UserApi::Workflow::WorkflowApi::getConfigItemHash() "WorkflowApi.getConfigItemHash()"|retrieves all configuration items
    |\b %Qore|@ref OMQ::UserApi::Workflow::WorkflowApi::getConfigItemValue() "WorkflowApi::getConfigItemValue()"|retrieves a single configuration item value
    |\b %Qore|@ref OMQ::UserApi::Workflow::WorkflowApi::getConfigItemHash() "WorkflowApi::getConfigItemHash()"|retrieves all configuration items

    @see @ref devintro_no_code_config_items

    @subsection class_connectors Class Connectors

    Class connectors are defined in class metadata and enable the class to be connected to other classes.  They can
    also declare input and output data types to ensure type-safe processing when processing data as well.

    Class connectors have the following attributes:

    <b>Class Connector Attributes</b>
    |!Key|!Mand.?|!Description
    |@ref class_connector_name "name"|Y|The name of the connector; this name will be used when choosing the connector
    |@ref class_connector_method "method"|Y|The name of the class method that will be called; this must correspond \
        to a real method in the class
    |@ref class_connector_type "type"|Y|The type of connector; describes how the connector can be used
    |@ref class_connector_input "input type"|N|The input data type for the connector
    |@ref class_connector_output "output type"|N|The output data type for the connector

    @subsubsection class_connector_name Class Connector Name

    The name of the connector used when choosing the connector in the IDE or displaying it in the UI.

    The connector name is stored in the YAML and is used to reference the connector in other objects.

    @note Changing the connector name will break references in other objects; the best practice is to use the same
    connector name as the connector method and to leave it unchanged.

    @subsubsection class_connector_method Class Connector Method

    The name of the class method that will be called; must correspond to a real method in the class.

    @par Connector Method Parameters
    Note that the input data for a class connector is always a single value; the method should declare at most one
    parameter corresponding to the @ref class_connector_input "input type", if any.
    \n\n
    If the class connector accepts input data but ignores the data, it should declare a single argument that accepts
    all values.
    \n\n
    If the class connector does not accept input data, it should not declare a parameter.

    @par Connector Method Return Value
    The return value for a connector should correspond to its @ref class_connector_output "output type", if any.

    @note The best practice is to use the same connector name as the connector method and to leave it unchanged;
    changing the connector method name will break any code referencing the connector method.

    @subsubsection class_connector_type Class Connector Type

    |!Connector Type|!Description
    |\c event|Event-based connectors provide an event source and can only be used in @ref implementingservices "services"
    |\c input|Input connectors can be connected to a preceding connector in a chain but provide no output data and \
        cannot have any further connectors after them
    |\c output|Output connectors do not accept any input data and must be the first connector in a chain, as they \
        cannot be connected to a previous connector.  They can produce output data.
    |\c input-output|A generic connector that can be connected anywhere in a chain
    |\c condition|A connector that returns a boolean value, meant to be used as the logic in a state transition in a \
        @ref finite_state_machines "finite state machine"

    @anchor event_connectors
    @par Event connectors
    Event connectors should be declared in a class that inherits one of the following classes:
    - \b %Python / \b Java / \b %Qore: @ref OMQ::Observable "Observable" or @ref OMQ::DelayedObservable "DelayedObservable"

    When the event must be raised, call the appropriate method as follows:
    - \b %Python / \b Java / \b %Qore: @ref OMQ::Observable::notifyObservers() "Observable::notifyObservers()"

    @subsubsection class_connector_input Class Connector Input

    Input connectors can be connected to a preceding connector in a chain but provide no output data and cannot have
    any further connectors after them.

    An input connector must be the last connector in a chain.

    Input connectors may ignore their input data.

    @subsubsection class_connector_output Class Connector Output

    Output connectors do not accept any input data and must be the first connector in a chain, as they cannot be
    connected to a previous connector.  They can (but do not necessarily have to) produce output data.

    @subsection class_processor Class Processor

    When a class declares processor compatibility, it allows the class object to be used in a
    @ref data_pipelines "data pipeline".

    In this case, the class must inherit one of the following classes depending on the source language:
    - \b %Python / \b %Qore: @ref DataProvider::AbstractDataProcessor "AbstractDataProcessor"
    - \b Java: @ref org.qore.lang.dataprovider.AbstractDataProcessor "AbstractDataProcessor"

    Class processors can be used to filter, generate, or transform input records in a
    @ref data_pipelines "data pipeline" and can also declare their input and output record types to ensure that
    type safety is enforced in the pipeline.

    @note @ref mappers "Mappers" are a special form of data processor that performs data transformations based on
    configuration.

    @par Example %Python Processor Class
    @code{.py}
from qore.DataProvider import AbstractDataProcessor

class ExamplePythonProcessor(AbstractDataProcessor):
    def __init__(self):
        super(AbstractDataProcessor, self).__init__()

    def submitImpl(self, data):
        UserApi.logDebug("processer called with data: %y", data)
        # return the same hash with "x-" prepended to each key
        return {("x-" + k): v for k, v in data.iteritems()}

    def supportsBulkApiImpl(self):
        return True
    @endcode

    @par Example Java Processor Class
    @code{.java}
import org.qore.lang.dataprovider.AbstractDataProcessor;

import qore.OMQ.UserApi.UserApi;

import java.util.Map;
import java.util.stream.Collectors;

class ExampleJavaProcessor extends AbstractDataProcessor {
    protected Object submitImpl(Object data) throws Throwable {
        UserApi.logInfo("processer called with data: %y", data);
        Hash rec = (Hash)data;
        // return the same hash with "x-" prepended to each key
        return rec.entrySet().stream().collect(
            Collectors.toMap(e -> "x-" + e.getKey(), Map.Entry::getValue)
        );
    }

    protected boolean supportsBulkApiImpl() {
        return true;
    }
}
    @endcode

    @par Example %Qore Processor Class
    @code{.py}
%new-style
%strict-args
%require-types
%enable-all-warnings

class ExampleQoreProcessor inherits AbstractDataProcessor {
    private auto submitImpl(auto rec) {
        UserApi::logInfo("processer called with data: %y", rec);
        # return the same hash with "x-" prepended to each key
        return map {"x-" + $1.key: $1.value}, rec.pairIterator();
    }

    private bool supportsBulkApiImpl() {
        return True;
    }
}
    @endcode

    @section library_objects Library Objects

    Library objects are code objects that are refenced by name only (meaning no version or ID) from other objects, to
    be loaded in to the target interface object's program container to provide additional code and configuration.

    The primary type of library object is the @ref class_objects "class".

    If mutiple versions of a library object are present in the system, then the last version of the object is used in
    interfaces that require it, whereas the last version is determined by the most recent creation date of the object
    in the database; no version comparison is performed.

    @note Since @ref class_objects "class objects" can depend on other @ref class_objects "class objects",
    establishing a dependency on any given class can result in an arbitrary number of additional classes being loaded
    into the requiring interface program container.

    @section queue_objects Asynchronous Queue Objects

    Queues provide the storage and delivery mechanism by which the results of executing an asynchronous event for an
    @ref asyncsteps "asynchronous step" are delivered to the right step instance.

    If a workflow has at least one @ref asyncsteps "asynchronous step", a queue must be defined.  A single queue can
    be used for any number of @ref asyncsteps "asynchronous steps", however the keys in a queue must be unique.

    @subsection updating_async_queues Updating Asynchronous Queue Entries

    When an asynchronous queue entry is updated, processing continues for the affected orders; at that time the
    updated queue data is sent to the waiting step's @ref asyncbackendcode "back end logic" for further processing.

    Queue entries for specific waiting asynchronous steps can be updated with the following APIs:
    - @ref qorus_api_util_post_async_queue
    - @ref rest_api_POST_latest_async-queues__queue__update

    @section group_objects Interface Group Objects

    Interface group files provide the metadata for an @ref rbacgroups "interface group".

    These groups can then be referenced by interface objects who can claim to be members of the group.

    @section wf_sync_event_objects Workflow Synchronization Event Objects

    Workflow synchronization event objects are required for @ref eventsteps "workflow synchronization event steps".
*/

/** @page definingconnections Defining Connections

    @tableofcontents

    @ref develguide "Back to the Developer's Guide Table of Contents"

    @section connectionfiles Connection Definition Files

    All Qorus integration objects are described by YAML metadata produced by our IDE, which is available as a free
    (as in free of charge and also open source) extension to
    <a href="https://code.visualstudio.com">Microsoft Visual Studio Code</a>, a multi-platform editor from Microsoft.
    The Qorus extension is called
    <a href="https://marketplace.visualstudio.com/items?itemName=qoretechnologies.qorus-vscode">Qorus Developer Tools</a>
    and can be installed directly from Visual Studio Code.

    @image html Qorus-IDE-4-Connection.png "Connections" width=75%

    @ref userconn "User connections", @ref dsconn, @ref remoteconn are defined in YAML connection files.

    Qorus user code should access external resources using user connections in all possible cases because such
    connections are @ref monitoring "monitored" and the interace is @ref conndeps "managed" (stopped and started) when
    the dependent connections become unavailable and again available (additionally, operational @ref alerts "alerts"
    are issued and cleared in these cases.

    When connections are made directly (for example, by using a @ref Qore::HTTPClient "HTTPClient" object directly
    instead of using a @ref userconn "user connection"), then the system does not monitor the connection's health,
    does not manage dependent interface status nor raise or clear alerts when the connection is unavailable or again
    available.

    Options can be set in the IDE for each connection as well.

    @image html Qorus-IDE-4-Connection-Options.png "Connection Options" width=75%

    @see @ref userconn
*/

/** @page mapper-devel Implementing Mappers

    @tableofcontents

    @ref develguide "Back to the Developer's Guide Table of Contents"

    @section mapper-devel-overview Mapper Development Overview

    @see @ref mappers for more information

    All Qorus integration objects are described by YAML metadata produced by our IDE, which is available as a free
    (as in free of charge and also open source) extension to
    <a href="https://code.visualstudio.com">Microsoft Visual Studio Code</a>, a multi-platform editor from Microsoft.
    The Qorus extension is called
    <a href="https://marketplace.visualstudio.com/items?itemName=qoretechnologies.qorus-vscode">Qorus Developer Tools</a>
    and can be installed directly from Visual Studio Code.

    %Mappers are developed in the IDE, loaded into the system schema with @ref oload "oload" and participate in
    releases built with @ref make-release "make-release".

    @image html Qorus-IDE-4-Mapper-Config.png "Mappers in the Qorus IDE" width=1000

    Each @ref mappers "mapper" has its own sandboxed @ref Qore::Program "Program" container that contains the mapping
    logic and any @ref mapper_library "library objects" imported into it.  %Mapper @ref Qore::Program "Program"
    objects have the following sandboxing restrictions set by default:
    - @ref no-top-level "%no-top-level"
    - @ref no-thread-control "%no-thread-control"
    - @ref no-process-control "%no-process-control"
    - @ref require-our "%require-our"

    For mapper library code, the following parse option is also set to restrict code from performing I/O or logging:
    - @ref lockdown "%lockdown"

    @note The following system options can cause additional options to be set by default:
    - @ref compat-broken-list-parsing
    - @ref compat-strict-bool-eval

    @see
    - @ref mapperapi for more information on mapper API including mapper @ref Qore::Program "Program" objects
    - @ref OMQ::MapperApi::MapperApi "MapperApi"
    - @ref mappers for more information

    Note that workflows, services, and jobs must declare mappers to be able to access them.  The following api call
    should be used to acquire a mapper in your interface code:
    - \b %Python: @ref OMQ::UserApi::UserApi::getMapper() "UserApi.getMapper()"
    - \b Java: @ref OMQ::UserApi::UserApi::getMapper() "UserApi.getMapper()"
    - \b %Qore: @ref OMQ::UserApi::UserApi::getMapper() "UserApi::getMapper()"

    @image html Qorus-IDE-4-Mapper.png "Mapper Diagram in the Qorus IDE" width=1000

    @see @ref mapper_library for more information.

    @section mapper-devel-files Mapper Files

    Mappers are defined as YAML metadata created by the Qorus IDE.

    Mappers have the following attributes:
    - @ref mapper_name
    - @ref mapper_version
    - @ref mapper_patch
    - @ref mapper_description
    - @ref mapper_options
    - @ref mapper_author
    - @ref mapper_library
    - @ref mapper_group
    - @ref mapper_context
    - @ref mapper_input
    - @ref mapper_output
    - @ref mapper_output_field_options

    @subsection mapper_name Mapper Name

    The name of the mapper; the name and version together are unique identifiers for the mapper and are used to derive
    the mapperid (which is generated when the mapper is loaded into the system via @ref oload "oload").

    @subsection mapper_version Mapper Version

    The version string for the mapper; the name and version together are unique identifiers for the mapper and are
    used to derive the mapperid (which is generated when the mapper is loaded into the system via @ref oload "oload").

    @subsection mapper_patch Mapper Patch

    A string "patch" label which can be used to show that a mapper was updated while not affecting the mapperid.

    The patch label is descriptive only and does not affect the mapper's ID.

    @subsection mapper_description Mapper Description

    A description for the mapper; the description field supports markdown for formatted output in the UI and IDE.

    @subsection mapper_options Mapper Options

    An optional hash of mapper options as in the following table

    |!Mapper Option|!Description
    |<tt><b>input_provider_search</b></tt>|The search criteria for the input provider; see the \a where_cond option \
        of @ref DataProvider::AbstractDataProvider::searchRecords() "AbstractDataProvider::searchRecords()" for more \
        information on this option
    |<tt><b>input_request</b></tt>|The arguments for input providers using the request/response API
    |<tt><b>input_request_options</b></tt>|Any options to input providers using the request/response API
    |<tt><b>input_response_error</b></tt>|a string indicating that input providers using the request/response API \
        should use the given error response message for the record format
    |<tt><b>input_search_options</b></tt>|The search options for the input provider; see the documentation for the \
        input data provider for more information on supported search options
    |<tt><b>output_nullable</b></tt>|Set all output fields as nullable
    |<tt><b>output_provider_bulk</b></tt>|If this option is used with a record-based output provider, then bulk \
        operations are used with the output provider, committing and flushing final data is performed automatically \
        by Qorus
    |<tt><b>output_provider_passive</b></tt>|If this option is set and a record-based or request-reply output \
        provider is set, then nothing will be written to the output provider when mapping; the output provider will \
        only be used to provide type information for the output record
    |<tt><b>output_provider_upsert</b></tt>|Set to @ref True if upsert operations instead of creation APIs should be \
        used with the output provider.  If \a output_provider_bulk is also set, this indicates that the internal \
        @ref DataProvider::AbstractDataProviderBulkOperation "AbstractDataProviderBulkOperation" object will use \
        upsert operations instead of insert operations
    |<tt><b>runtime</b></tt>|An initial runtime structure for @ref mapper_runtime_handling
    |<tt><b>trunc_all</b></tt>|If @ref True "True" (as evaluated by @ref Qore::parse_boolean() "parse_boolean()") \
        then all fields will be automatically and silently truncated if the output data exceeds the field's length

    @subsection mapper_author Mapper Author

    The optional author string for the mapper.

    @subsection mapper_library Mapper Library

    Mappers support @ref library_objects "library objects" that provide additional code for mapper fields using code
    to define the logic for the output mapping.

    @see @ref library_objects for more information

    @subsection mapper_group Mapper Groups

    Mappers can be members of @ref rbacgroups "interface groups" like other interface objects.

    @subsection mapper_context Mapper Context

    The mapper context provides information to Qorus about other contextual information that can be used in a mapper
    such as a @ref wf_static_data_type "workflow's static data type".

    @subsection mapper_input Mapper Input

    Mappers can declare input types that define the type of input data or an input provider that provides both the
    input data type and also a source for the data.

    @subsection mapper_output Mapper Output

    Mappers can declare output types that define the type of output data or an output provider that provides both the
    output data type and also a source for writing or processing the data.

    @subsection mapper_output_field_options Mapper Output Field Options

    Mapper output fields can be mapped from input fields or they can be derived from multiple fields, other contextual
    information, from a %Python or %Qore expression, or by a method call from a mapper code class.0

    This section will outline the use of mapper output field options.

    @image html Qorus-IDE-4-Mapper-Field-Config.png "IDE Mapper Output Field Options" width=1000

    @note REST API <tt>GET /api/latest/system/default_mapper_keys</tt> returns information about mapper output field
    keys

    @subsubsection mapper_output_field_option_code Mapper Output Field Option: code

    @par Synopsis

    <tt><b>code</b></tt> provides a reference to a mapper code method; the given method is called with an argument
    providing the currently mapped input field (if any) as well as the entire input hash.

    In this way any arbitrary logic can be used to populate the output field.

    @see @ref mapper_output_field_option_context

    @subsubsection mapper_output_field_option_constant Mapper Output Field Option: constant

    @par Synopsis

    <tt><b>constant</b></tt>: provides a fixed constant value to the output field; the type of the constant must
    correspond to the output field type.

    Complex values must be entered in YAML format; see @ref yaml_formatted_data for more information.

    @note If this mapper output field option is used, no other options can be set

    @subsubsection mapper_output_field_option_context Mapper Output Field Option: context

    @par Synopsis

    <tt><b>context</b></tt>: this field holds a string that is evaluated as a template string with
    @ref OMQ::UserApi::UserApi::expandTemplatedValue() "UserApi::expandTemplatedValue()" to provide the output field
    value.

    The <tt><b>$local:input</b></tt> template (corresponding to the \a local_context argument in the above method) is
    assigned to the input hash value, providing an easy way to reference input data values in the context string.

    Assume the following input record for the examples following the example data table.

    <b>Example Input Data Record</b>
    |!Input Field|!Input Field Value
    |\c id|\c "UfEydGZk2yn5Urk"
    |\c first_name|\c "Joline"
    |\c last_name|\c "Customer"
    |\c type|\c "Residential"

    <b>Mapper Output Field Context Option Example Table</b>
    |!Output Field Context Option Value|!Output Field Value
    |<tt>$local:input.id-$local:input.last_name</tt>|\c "UfEydGZk2yn5Urk-Customer"
    |<tt>$qore-expr:{"$local:input.last_name".upr()}</tt>|\c "CUSTOMER"
    |<tt>$qore-expr:{"$local:input.type" == "Business" ? 100 : 200}</tt>|\c 200

    @note For more complex output field value generation, use a
    @ref mapper_output_field_option_code "mapper code method"

    @see
    - @ref OMQ::UserApi::UserApi::expandTemplatedValue() "UserApi::expandTemplatedValue()"
    - @ref bb_template_strings
    - @ref mapper_output_field_option_code

    @subsubsection mapper_output_field_option_default Mapper Output Field Option: default

    @par Synopsis

    <tt><b>default</b></tt>: provides a default value to the output field if no mapping is present or the input
    mapping provides no value; the type of the default value must correspond to the output field type.

    Complex values must be entered in YAML format; see @ref yaml_formatted_data for more information.

    @subsubsection mapper_output_field_option_index Mapper Output Field Option: index

    @par Synopsis

    <tt><b>index</b></tt>: allows the current row number in the input data to be used as the output field value.  Row
    numbers start with row \c 0

    The value and the value type of this option determine the output value:
    - @ref int_type "int" values: the given value is added to the row number (where the first row is row \c 0), and
      the resulting value is used as the output field value
    - @ref string_type "string" values: the given string is prepended to the row number (where the first row is row \c
      0), and the resulting string value is used as the output field value
    - other value types: the result of the %Qore @ref plus_operator "+ operator" applied to the row number (where the
      first row is row \c 0) and the argument, and the resulting value is used as the output field value

    @subsubsection mapper_output_field_option_name Mapper Output Field Option: name

    @par Synopsis

    <tt><b>name</b></tt>: is used to specify a mapping from an input field; this output field is generated
    automatically by the IDE when an input field is mapped to an output field

    @subsubsection mapper_output_field_option_runtime Mapper Output Field Option: runtime

    @par Synopsis

    <tt><b>runtime</b></tt>: the name of a field in the "runtime" hash where the output field value should be taken
    from.

    @note use @ref mapper_output_field_option_context "context" instead

    @subsubsection mapper_output_field_option_submapper Mapper Output Field Option: submapper

    @par Synopsis

    <tt><b>submapper</b></tt>: the name or identifier of a submapper that will provide a list of values for this field

    @note
    - Provided for future use
    - Cannot be used with bulk APIs

    @subsubsection mapper_output_field_option_submapper_auto_input Mapper Output Field Option: submapper_auto_input

    @par Synopsis

    <tt><b>submapper_auto_input</b></tt>: provides use the input provider from the submapper for the output of the
    field; requires @ref mapper_output_field_option_submapper_options "submapper_options" to provide input configuration for
    the submapper

    @note
    - Provided for future use
    - Cannot be used with bulk APIs

    @subsubsection mapper_output_field_option_submapper_options Mapper Output Field Option: submapper_options

    @par Synopsis

    <tt><b>submapper_options</b></tt>: allows a parent mapper to affect the options of the submapper based on current
    data; use <tt>$local:input.&lt;field&gt;</tt> to refer to mapped data in the current parent mapper input row to
    affect submapper options.

    @note
    - Provided for future use
    - Cannot be used with bulk APIs

    @subsubsection mapper_output_field_option_trunc Mapper Output Field Option: trunc

    @par Synopsis

    <tt><b>trunc</b></tt>: a boolean flag that indicates if the input value should be automatically truncated if it is
    too large to fit in the output field.

    If this value is missing or @ref False, a \c STRING-TOO-LONG exception is raised in such cases.

    @subsubsection mapper_output_field_option_type_options Mapper Output Field Option: type_options

    @par Synopsis

    <tt><b>type_options</b></tt>: a hash of options as supported by the output data type

    @subsubsection mapper_output_field_option_use_input_record Mapper Output Field Option: use_input_record

    @par Synopsis

    <tt><b>use_input_record</b></tt>: when @ref True, the entire input record will be used as the value of the output
    field; only compatible with hash output fields.

    @note If this mapper output field option is used, no other options can be set

    @subsubsection mapper_output_field_option_template Mapper Output Field Option: template

    @par Synopsis

    <tt><b>template</b></tt>: if @ref True, the value of the input field will be used as a template; i.e.
    @ref OMQ::UserApi::UserApi::expandTemplatedValue() "UserApi::expandTemplatedValue()" will be called on the input
    value, and the result will be used as the output field's value.

    @subsubsection mapper_output_field_option_value_lookup Mapper Output Field Option: value_lookup

    @par Synopsis

    <tt><b>value_lookup</b></tt>: The given value map and value will be looked up and used as the output value; the
    format of this option is <i>value-map-name</i>.<i>value-map-key</i>.

    This option is equivalent to using \c context =
    <tt><b>$value-map:{</b></tt><i>value-map-name</i><tt><b>.</b></tt><i>value-map-key</i><tt><b>}</b></tt>
*/

/** @page typedefs Data Type Definitions

    @tableofcontents

    @ref develguide "Back to the Developer's Guide Table of Contents"

    @section typedef_intro Introduction to Data Type Definitions in Qorus

    Data types in Qorus are based on the @ref DataProvider::AbstractDataProviderType "AbstractDataProviderType" class
    in the @ref dataproviderintro "DataProvider" module.

    This class supports type-safe data exchanges in Qorus.

    @anchor typedef_depending_objects
    The following Qorus objects support data type definitions:
    - @ref class_objects "Classes" support @ref class_connectors "connectors" that have defined
      @ref class_connector_input "input" and @ref class_connector_output "output" types
    - @ref devintro_no_code_config_items "Config items" have a defined data type for the config item value
    - @ref data_pipelines "Data pipelines" support input and output types for each pipeline element
    - @ref finite_state_machines "Finite state machines / flows" support the definition of input and output types for
      the finite state machine itself, for each state, and for internal @ref fsm_block_states "blocks"
    - @ref mapper-devel "Mappers" provide a data transformation object from an input type to an output type, and each
      field in mapper input or output also has a defined type
    - @ref implementingservices "Services" support defined @ref service_api_manager "API handlers" that define and
      enforce request and response types on each @ref service_methods "service method" or ech service
      @ref finite_state_machines "finite state machine" used to serve API endpoints
    - @ref designimplworkflows "Workflows" allow for the @ref wf_static_data_type "static data type" to be defined

    @section typedef_paths Data Type Paths

    Qorus manages type definitions (with @ref DataProvider::DataProviderTypeCache "DataProviderTypeCache") with a
    unique path name to the type.

    <b>Example Builtin Qorus Data Types</b>
    |!Type Path|!Description
    |<tt>qore/bool</tt>|base @ref boolean "boolean" type; based on \
        @ref DataProvider::QoreBoolDataType "QoreBoolDataType"
    |<tt>qore/binary</tt>|base @ref binary "binary" type; based on \
        @ref DataProvider::QoreBinaryDataType "QoreBinaryDataType"
    |<tt>qore/date</tt>|base @ref date "date/time" type (can be absolute or relative); based on \
        @ref DataProvider::QoreDateDataType "QoreDateDataType"
    |<tt>qore/float</tt>|base @ref float "floating-point number" type; based on \
        @ref DataProvider::QoreFloatDataType "QoreFloatDataType"
    |<tt>qore/hash</tt>|base @ref hash "hash" type (set key-value pairs); based on \
        @ref DataProvider::HashDataType "HashDataType"
    |<tt>qore/int</tt>|base @ref integer "integer" type; based on \
        @ref DataProvider::QoreIntDataType "QoreIntDataType"
    |<tt>qore/number</tt>|base @ref number "arbitrary-precision number" type; based on \
        @ref DataProvider::QoreNumberDataType "QoreNumberDataType"
    |<tt>qore/string</tt>|base @ref string "string" type; based on \
        @ref DataProvider::QoreStringDataType "QoreStringDataType"
    |<tt>qoretechnologies/qorus-api/workflows/create-order/request</tt>|the data type required for a \
        @ref qorus_api_workflows_create_order "create-order" call
    |<tt>qoretechnologies/qorus-api/workflows/create-order/response</tt>|the data type returned from a \
        @ref qorus_api_workflows_create_order "create-order" call

    The type hierarchy is quite large; the above table provides only a representative sample of a subset of the types
    provided by Qorus.

    Types can be queried with the REST API with @ref rest_api_GET_latest_dataprovider_types, created with
    @ref rest_api_POST_latest_dataprovider_types, and compared with
    @ref rest_api_GET_latest_dataprovider_types______type__type_compare, for example.

    Additionally, types can be browsed with the UI as in the following image.

    @htmlonly
    <div class="image">
      <img src="Qorus-UI-Type-List.png" alt="Data Type List in the UI" style="width:75%;">
      <div class="caption">Data Type List in the UI</div>
    </div>
    @endhtmlonly

    Data type defails can be viewed with the UI as well as in the following image.

    @htmlonly
    <div class="image">
      <img src="Qorus-UI-Type-Details.png" alt="Data Type Details in the UI" style="width:75%;">
      <div class="caption">Data Type Details in the UI</div>
    </div>
    @endhtmlonly

    @section typedef_ide Data Type Definitions in the IDE

    In the IDE, custom, user-defined hash types can be defined, which can define the record type for record sets or
    the type of a simple hash, for example to defined input or output data for a
    @ref class_connectors "class connectors" or @ref finite_state_machines "finite state machine" state, block, or the
    FSM itself, or as the input or output of a @ref mapper-devel "mapper", etc.

    @image html Qorus-IDE-4-Type-Definition.png "Data Type Definitions in the IDE" width=75%

    The \c path of the data type will uniquely identify the type, and the user can then add the fields to the type to
    define a record or a simple hash for use elsewhere in @ref typedef_depending_objects "other Qorus objects".

    @image html Qorus-IDE-4-Type-Field-Details.png "Data Type Field Details in the IDE" width=50%
*/

/** @page valuemap-devel Implementing Value Maps

    @tableofcontents

    @ref develguide "Back to the Developer's Guide Table of Contents"

    @section value-map-api Value Map API

    User code implementation can use the following functions to access value maps:
    - @ref OMQ::UserApi::UserApi::getValueMap() "UserApi::getValueMap()"
    - @ref OMQ::UserApi::UserApi::getValueMaps() "UserApi::getValueMaps()"

    @section value-map-exceptions Value Map Error Handling and Missing Data

    @ref OMQ::UserApi::UserApi::getValueMap() "UserApi::getValueMap()" returns @ref nothing by default if there is no
    value for the given key, however an exception can be thrown if there is the \c "throws_exception" flag is set to
    @ref True.

    The exception error is \c VALUE-MAP-ERROR with description "value map 'name' does not contain value for key 'keyname'"

    @section value-map-oload Value Map Definition Files

    value maps can be defined and changed in the Qorus user interface or using the REST API.
    However, for large value maps it's much more useful to create value map files with the IDE and load
    them with @ref oload as a part of user code releases/deployments.

    value maps are defined in \c *.qvmap.yaml files.

    @subsection value-map-oload-attrs Value Map Definition File Attributes

    Value map definition file headers are as follows:
    - \c name: (required) the unique name of the value map; loading a new value map with an already existing name
      removes the old key-value mappings
    - [\c desc]: a description of the value map
    - [\c author]: a string identifying the author of the value map
    - [\c exception]: a flag determining the behavior of an invalid lookup (see @ref value-map-exceptions)
    - <tt>value type</tt>: (required) @ref value-map-datatypes
    - [<tt>date format</tt>]: When the \c valuetype is set to \c "date", \c "dateformat" defines a mask for converting
      string input values to real dates using the @ref Qore::date(string) function (see
      @ref date_mask "date format mask" for more information)
    - [\c group]: Allows @ref rbacgroups "interface groups" to be defined
    - [\c groups]: One or more @ref rbacgroups "interface groups" that the value map is a member of for access
      purposes (value maps cannot be enabled or disabled)
*/

/** @page implementingqorusobjectsusingyaml Implementing Qorus Objects Using YAML format

    @tableofcontents

    @ref develguide "Back to the Developer's Guide Table of Contents"

    @section yamldefinitionfiles YAML Definition Files of Qorus Objects

    All Qorus integration objects are described by YAML metadata produced by our IDE, which is available as a free
    (as in free of charge and also open source) extension to
    <a href="https://code.visualstudio.com">Microsoft Visual Studio Code</a>, a multi-platform editor from Microsoft.
    The Qorus extension is called
    <a href="https://marketplace.visualstudio.com/items?itemName=qoretechnologies.qorus-vscode">Qorus Developer Tools</a>
    and can be installed directly from Visual Studio Code.

    The IDE generates YAML files for Qorus objects.

    Qorus YAML definition files should have the extension <tt>*.yaml</tt> to identify the file's contents properly to
    the @ref oload "schema loader".

    YAML definition files are used to create Qorus object definitions in the Qorus schema.

    YAML schemas for Qorus object definition files:

    |!Object|!YAML Schema|!Example
    |@ref class_objects "Qorus classes"|<a href="class_schema.yaml">class_schema.yaml</a>|<a href="issue3102class.yaml">class.yaml</a>
    |@ref implementingservices "Qorus services"|<a href="service_schema.yaml">service_schema.yaml</a>|<a href="service.yaml">service.yaml</a>
    |@ref stepdefs "Qorus steps"|<a href="step_schema.yaml">step_schema.yaml</a>|<a href="issue3102step.yaml">step.yaml</a>
    |@ref implementingjobs "Qorus jobs"|<a href="job_schema.yaml">job_schema.yaml</a>|<a href="job.yaml">job.yaml</a>
    |@ref designimplworkflows "Qorus workflows"|<a href="workflow_schema.yaml">workflow_schema.yaml</a>|<a href="issue3102workflow.yaml">workflow.yaml</a>
    |\c Qorus workflow errors|<a href="errors_schema.yaml">errors_schema.yaml</a>|<a href="errors.yaml">errors.yaml</a>
    |@ref library_objects "Qorus functions"|<a href="function_schema.yaml">function_schema.yaml</a>|<a href="issue3102function.yaml">function.yaml</a>
    |@ref mapper-devel "Qorus mappers"|<a href="mapper_schema.yaml">mapper_schema.yaml</a>|<a href="issue3102mapper.yaml">mapper.yaml</a>
    |@ref valuemap-devel "Qorus value maps"|<a href="value-map_schema.yaml">value-map_schema.yaml</a>|<a href="value-map.yaml">value-map.yaml</a>
    |@ref library_objects "Qorus constants"|<a href="constant_schema.yaml">constant_schema.yaml</a>|<a href="constant.yaml">constant.yaml</a>
    |@ref wf_sync_event_objects "Qorus workflow events"|<a href="event_schema.yaml">event_schema.yaml</a>|<a href="event.yaml">event.yaml</a>
    |@ref queue_objects "Qorus queues"|<a href="queue_schema.yaml">queue_schema.yaml</a>|<a href="queue.yaml">queue.yaml</a>
    |@ref group_objects "Qorus groups"|<a href="group_schema.yaml">group_schema.yaml</a>|<a href="group.yaml">group.yaml</a>
    |@ref definingconnections "Qorus connections"|<a href="connection_schema.yaml">connection_schema.yaml</a>|<a href="connection.yaml">connection.yaml</a>
    |\c Qorus config item values|<a href="config-item-values_schema.yaml">config-item-values_schema.yaml</a>|<a href="config-item-values.yaml">config-item-values.yaml</a>
    |\c Qorus types|<a href="type_schema.yaml">type_schema.yaml</a>|<a href="type.yaml">type.yaml</a>
    |@ref data_pipelines "Qorus pipelines"|<a href="pipeline_schema.yaml">pipeline_schema.yaml</a>|<a href="pipeline.yaml">pipeline.yaml</a>
    |@ref finite_state_machines "Qorus finite state machines"|<a href="fsm_schema.yaml">fsm_schema.yaml</a>|<a href="fsm.yaml">fsm.yaml</a>

    YAML type definitions:
    |!Object|!YAML type definition
    |\c Qorus config item|<a href="config-item_definition.yaml">config-item_definition.yaml</a>
    |\c Qorus service method|<a href="service-method_definition.yaml">service-method_definition.yaml</a>
    |\c Qorus cron|<a href="cron_definition.yaml">cron_definition.yaml</a>
    |\c Qorus workflow error|<a href="error_definition.yaml">error_definition.yaml</a>
    |\c Qorus class connectors|<a href="class-connector_definition.yaml">class-connector_definition.yaml</a>
    |\c Qorus class processor|<a href="processor_definition.yaml">processor_definition.yaml</a>

    For Qorus objects that support user code there is a <tt>code</tt> tag that tells @ref oload where the source code
    is located.

    @note
    - It is recommended to have YAML definition files in the same directory with the user code
    - YAML definition files support only class-based user code for services, jobs, and workflows

    @section yaml_formatted_data YAML Formatted Data

    The IDE allows for complex data structures to be written in YAML; this allows lists, hashes, and nested data types
    to be defined consistently in the IDE.  Any valid YAML encoding syntax up to and including YAML 1.1 is supported
    in YAML data in the IDE (and in Qorus where YAML is parsed), including block style and YAML comments.

    YAML was chosen as it is extensible, very expressive, concise, and also human-readable.

    See the following table for supported data types and YAML encoded string examples.

    <b>%Qore YAML Data Types With Examples</b>
    |!%Qore Data Type|!Example|!Notes
    |@ref int_type "int"|\c 100|Lossless bidirectional conversion
    |@ref float_type "float"|\c 1.01 \n\c @nan@ \n\c @inf@|Lossless bidirectional conversion
    |@ref number_type "number"|\c 2.5n \n\c 10n{256} \n<tt>!number "@inf@n"</tt>\n<tt>!number "@nan@n"</tt>|Lossless \
        bidirectional conversion (full number with precision is serialized in the YAML string)
    |@ref string_type "string"|<tt>an implicit string</tt>\n\c "quoted string"|Lossless bidirectional conversion \
        only with UTF-8-encoded strings; non-UTF-8 encoding information is lost, YAML strings are always encoded in \
        UTF-8 encoding
    |@ref bool_type "bool"|\c true \n\c false|Lossless bidirectional conversion
    |@ref date_type "date" (relative / duration)|\c P2M3DT10H14u|Lossless bidirectional conversion
    |@ref date_type "date" (absolute)|\c 2010-05-05T15:35:02.100|Lossless bidirectional conversion for YAML \
        \c timestamp values up to microsecond resolution; fractional microsecond information is lost
    |@ref binary_type "binary"|<tt>!!binary "q80="</tt>|Lossless bidirectional conversion; must use canonical \
        YAML encoding using base64-encoded data for binary values
    |@ref nothing_type "nothing"|\c null|Lossless bidirectional conversion; note that %Qore's SQL @ref NULL "NULL" \
        value is serialized to YAML \c null and therefore is a lossy conversion
    |@ref type_type "list"|<tt>[1, two, 3.0]</tt>\n<tt>- 1\n- two\n- 3.0</tt>|Lossless bidirectional conversion
    |@ref type_type "hash"|<tt>{a: 1, b: two}</tt>\n<tt>a: 1 \nb: two</tt>|Lossless bidirectional conversion

    @par Example
    Given the following YAML document:
    @verbatim
doe: "a deer, a female deer"
ray: "a drop of golden sun"
pi: 3.14159
xmas: true
french-hens: 3
calling-birds:
  - huey
  - dewey
  - louie
  - fred
xmas-fifth-day:
  calling-birds: four
  french-hens: 3
  golden-rings: 5
  partridges:
    count: 1
    location: "a pear tree"
  turtle-doves: two
    @endverbatim
    \n
    Deserialized as %Qore data and logged with \c %N, the result is:
    @verbatim
hash: (7 members)
  doe : "a deer, a female deer"
  ray : "a drop of golden sun"
  pi : 3.14159
  xmas : True
  french-hens : 3
  calling-birds : list: (4 elements)
    [0]="huey"
    [1]="dewey"
    [2]="louie"
    [3]="fred"
  xmas-fifth-day : hash: (5 members)
    calling-birds : "four"
    french-hens : 3
    golden-rings : 5
    partridges : hash: (2 members)
      count : 1
      location : "a pear tree"
    turtle-doves : "two"
    @endverbatim

    @subsection yaml_references YAML References

    - <a href="https://yaml.org">https://yaml.org</a>
    - <a href="https://en.wikipedia.org/wiki/YAML">https://en.wikipedia.org/wiki/YAML</a>
    - <a href="https://qoretechnologies.com/manual/qorus/current/yaml/yaml/html/index.html">https://qoretechnologies.com/manual/qorus/current/yaml/yaml/html/index.html</a>
*/

/** @page devel-sqlcache SQL Object Cache API

    @tableofcontents

    @ref develguide "Back to the Developer's Guide Table of Contents"

    @section devel-sqlcache-intro Introduction to Development with the SQL Object Cache

    Using the @ref sqlutilintro "SqlUtil module" for DML is recommended for the following reasons:
    - the SQL generated is database-independent
    - database-specific optimizations can be automatically employed by @ref sqlutilintro "SqlUtil" without requiring programming expertise for the specific database being used
    - dynamic SQL can be eliminated and therefore the database server's SQL statement cache can be used more efficiently (if applicable)
    - SQL injection attacks can be prevented

    To perform DML using the @ref sqlutilintro "SqlUtil module", an @ref SqlUtil::AbstractTable "AbstractTable" object must be acquired;
    Qorus implements an SQL object cache for @ref SqlUtil::AbstractTable "AbstractTable" objects for DML to allow for efficient
    sharing of these objects, since the creation of an @ref SqlUtil::AbstractTable "AbstractTable" object is expensive in terms of CPU time
    and I/O bandwidth (many server round-trips are performed to query the server's data dictionary about the table's structure and
    associated attributes such as indexes, constraints, etc).

    @see @ref sql-cache for more information

    @section sql-cache-functions SQL Object Cache Function List

    - @ref OMQ::UserApi::UserApi::getSqlTable(): acquire an @ref SqlUtil::AbstractTable "AbstractTable" object for DML
    - @ref OMQ::UserApi::UserApi::getSqlCacheInfo(): get information about the cache
    - @ref OMQ::UserApi::UserApi::clearSqlTableCache(): purge @ref SqlUtil::AbstractTable "AbstractTable" objects from
      the SQL object cache
*/

/** @page schemamanagement User Schema Management

    @tableofcontents

    @ref develguide "Back to the Developer's Guide Table of Contents"

    @section schemamanagementintro Introduction to User Schema Management

    User schema module files allow Qorus developers to manage user schemas automatically by provided a user schema module file describing the schema.

    @ref oload "oload" and @ref schema-tool "schema-tool" both recognize the \c qsm extension and apply the configuration therein to the given schema.

    When @ref oload "oload" loads such a schema file, the schema will be automatically aligned in the target datasource as described by the user schema module.
    Furthermore @ref schema-tool "schema-tool" allows for manual schema creation and alignment as well as schema dropping of user schemas using the <tt>-V,--align-schema=ARG</tt>
    and <tt>--drop-schema=ARG</tt> options, respectively.

    @section schemamodulefile User Schema Module Files

    Qorus user schema module files are @ref user_modules "Qore user modules" that use the @ref schemaintro "Schema module" to provide the configuration and management of user schemas.

    A Qorus user schema module must have the extension \c qsm and should be located in the \c modules subdirectory of the \c user subdirectory.

    The user schema module must provide the following public (ie exported) functions:
    - <tt>public string sub get_datasource_name()</tt>: this function must return the name of the datasource to be used for schema management
    - <tt>AbstractSchema sub get_user_schema(AbstractDatasource ds, *string dts, *string its)</tt>: this function must return the schema object to be managed; the arguments to the function correspond to the arguments to the @ref Schema::AbstractSchema::constructor() "AbstractSchema::constructor()" method

    The @ref Schema::AbstractSchema "AbstractSchema" object returned by <tt>get_user_schema()</tt> represents the schema that will be managed.

    @subsection schemamoduleexample User Schema Module Example

    The following is an example of a user schema module file:
    @code{.py}
# -*- mode: qore; indent-tabs-mode: nil -*-
# @file InventoryExampleSchema.qsm Qorus Integration System inventory example user schema description module

%requires qore >= 1.12

module InventoryExampleSchema {
    version = "1.0";
    desc = "Qorus inventory example user schema module";
    author = "Qore Technologies <info@qoretechnologies.com>";
    url = "https://www.qoretechnologies.com";
}

# here we add fallback paths to the QORE_MODULE_DIR search path,
# in case QORE_MODULE_DIR is not set properly for Qorus
%append-module-path /var/opt/qorus/qlib:__8_OMQ_DIR/qlib:/opt/qorus/qlib

%requires Schema
%requires SqlUtil

%new-style
%require-types
%strict-args
%enable-all-warnings

# private namespace for private schema declarations
namespace Private {
    const GenericOptions = (
        "replace": True,
    );

    const IndexOptions = (
        "driver": (
            "oracle": (
                "compute_statistics": True,
            ),
        ),
    );

    const ColumnOptions = (
        "driver": (
            "oracle": ("character_semantics": True,),
        ),
    );

    const T_InventoryExample = (
        "columns": (
            "id": c_int(True, "PK ID field"),
            "filename": c_varchar(200, True, "input filename"),
            "uuid": c_varchar(40, True, "system-supplied UUID for the file"),
            "store_code": c_varchar(200, True, "input store code"),
            "product_code": c_varchar(50, True, "input product code / EAN"),
            "product_desc": c_varchar(200, True, "input product description"),
            "ordered": c_int(True),
            "available": c_int(True),
            "in_transit": c_int(True),
            "total": c_int(True),
            "qorus_wfiid": c_int(True),
        ),
        "primary_key": ("name": "pk_inventory_example", "columns": ("id")),
        "indexes": (
            "sk_inventory_example_filename": ("columns": ("filename")),
            "sk_inventory_example_uuid": ("columns": ("uuid")),
            "sk_inventory_example_q_wfiid": ("columns": ("qorus_wfiid")),
        ),
    );

    const Tables = (
        "inventory_example": T_InventoryExample,
    );

    const Sequences = (
        "seq_inventory_example": {},
    );
}

public namespace InventoryExampleSchema {
    public string sub get_datasource_name() {
        return "omquser";
    }

    public InventoryExampleSchema sub get_user_schema(AbstractDatasource ds, *string dts, *string its) {
        return new InventoryExampleSchema(ds, dts, its);
    }

    public class InventoryExampleSchema inherits AbstractSchema {
        public {
            const SchemaName = "InventoryExampleSchema";
            const SchemaVersion = "1.0";
        }

        constructor(AbstractDatasource ds, *string dts, *string its) :  AbstractSchema(ds, dts, its) {
        }

        private string getNameImpl() {
            return SchemaName;
        }

        private string getVersionImpl() {
            return SchemaVersion;
        }

        private *hash getTablesImpl() {
            return Tables;
        }

        private *hash getSequencesImpl() {
            return Sequences;
        }

        private *hash getIndexOptionsImpl() {
            return IndexOptions;
        }

        private *hash getGenericOptionsImpl() {
            return GenericOptions;
        }

        private *hash getColumnOptionsImpl() {
            return ColumnOptions;
        }
    }
}
    @endcode
*/

/** @page customqscripts Custom Release Scripts (qscripts)

    @tableofcontents

    @ref develguide "Back to the Developer's Guide Table of Contents"

    @section customqscriptsintro Introduction to Custom Release Scripts

    Custom release scripts allow Qorus developers to perform fine-tuned release tasks
    automatically running @ref oload or in standard deployment packages made by @ref make-release.

    @ref oload (also called internally in packages created by @ref make-release "make-release") recognizes
    the \c qscript file extension and the script is executed in the particular place  of the @ref oload "oload" run.

    @section Script Phases

    @par PRE

    File mask:
     - <tt>*-pre.qscript</tt>

    Scripts are run at the beginning of the deployment, nefore anything else.

    @par POST

    File mask:
     - <tt>*.qscript</tt> original, legacy qscripts
     - <tt>*-post.qscript</tt>

    Scripts are run after the deployment but before potential Qorus server objects are reloaded.

    @par POST_RELOAD

    File mask:
     - <tt>*-post_reload.qscript</tt>

    Scripts are run after the deployment and after potential Qorus server objects are reloaded.

    @section qscriptfile Custom Release Script Files

    Custom release scripts are regular scripts in any supported scripting language on the server platorm (i.e. shell,
    %Qore, %python, etc).  %Qore and %Python scripts have the added advantage of being able to use the Qorus client
    API as well.

    %Qore scripts are sandboxed into dedicated %Qore Program objects with Qorus option @ref defines imported.

    See @ref client

    Useful functions are available in @ref QorusQscriptUtil module

    <b>Example</b> - a script checking presence of some directory on filesystem with its creation:
    @code{.py}
#!/usr/bin/env qore
%new-style
%require-types
%strict-args
%enable-all-warnings

%requires QorusClientCore

QorusClient::initFast();

# defines from $OMQ_DIR/etc/options are available and respected
%ifdef AppXInstance

# ensure we will create a special directory under a filesystem user connection
Dir d = get_user_connection("fs-remote-2-ftp");
d.chdir("foo");
if (!d.exists()) {
    d.create();
    printf("created dir: %y\n", d.path());
}

%endif

    @endcode

    Example output:

    @verbatim
prompt% ls -l /appl/data/remote-2-ftp/
total 0
prompt% oload test.qscript
Running custom script: /home/qorus/src/qorus/work/test.qscript
created dir: /appl/data/remote-2-ftp/foo
prompt% ls -l /appl/data/remote-2-ftp/
total 0
drwxr-xr-x 2 qorus staff 68 Nov 11 22:14 foo
    @endverbatim
*/

/** @page ci_cd Continuous Integration and Continuous Delivery

    @tableofcontents

    @ref develguide "Back to the Developer's Guide Table of Contents"

    Qorus supports all aspects of Continuous Integration and Continuous Delivery:
    - automatic release packaging and installation
    - automatic test execution

    See the following sections for more information and references to details and examples.

    @section qorus_releases Qorus Release Packaging and Automatic installation

    @subsection qorus_release_overview Qorus Release Packaging Overview

    The @ref make-release "make-release" program is used to create Qorus releases.  Each release is an
    installable package that will automatically create the desired configuration in the target system.

    Each release has a label, which is the release name.  Qorus releases should be installed in <tt>$OMQ_DIR/user</tt>
    on the target server system.

    Two command-line options for @ref make-release "make-release" help package releases for proper installation on the
    target machine as follows:
    - <tt>-U=</tt><i>ARG</i>: this provides the source root directory for all files in the release; all release files
      should then be given as relative paths from this location on the source file system
    - <tt>-P=</tt><i>ARG</i>: this provides a target directory name under <tt>$OMQ_DIR</tt> on the target server,
      because all user release files should be written to <tt>$OMQ_DIR/user</tt> on the target server, in case the
      release directory does not begin with <tt>user/</tt>, it can be added here

    For example, assuming the following:
    - release label: \c project-A1234-v1.0
    - source files:
      - <tt>$HOME/src/qorus/project-A1234/my-service-v1.0.qsd.yaml</tt>
      - <tt>$HOME/src/qorus/project-A1234/my-service-v1.0.qsd.py</tt>
    - to be installed in the following target directory:
      - <tt>$OMQ_DIR/user/project-A1234</tt>

    Use the following command-line:
    @verbatim
make-release project-A1234-v1.0 -c -U ~/src/qorus -P user project-A1234/*
    @endverbatim

    This will create an installable package named \c qorus-user-project-A1234-v1.0.tar.bz2 in the directory pointed to
    by the \c QORUS_RELEASE_DIR environment variable (or in <tt>$HOME/releases</tt> if the environment variable is not
    set).

    @ref oload "oload" can be used to install this package or the appropriate REST API for remote deployments.

    @note Release packages created with \c make-release will be unarchived in <tt>$OMQ_DIR</tt>, because all user code
    should be placed in <tt>$OMQ_DIR/user</tt>, it is recommended to always use the <tt>-P=user</tt> option as
    described above to ensure that releases are stored in the proper location on the target filesystem.

    @see
    - @ref make-release
    - @ref installtarenvvars
    - @ref python_development_module_packaging

    @subsection qorus_release_components Qorus Release Components

    Qorus releases can contain any files necessary for the code to function in the target environment.  All Qorus
    interface object files can be included as well as the following:
    - @ref schemamanagementintro "Qorus schema modules" for automatically installing / upgrading DB schemas
    - @ref javadevelopment_classpath "jar and class" files for Java library code required by interfaces
    - @ref python_development_module_path "Python modules" for functionality required by interfaces
    - @ref service_file_resources "service file resources"
    - @ref customqscripts "qscripts" for automating setup or other installation actions
    - YAML, JSON, XML or other configuration or reference files needed for a release

    Qorus releases should be completely automated and should set up the target system consistently so that releases
    can be deployed automatically and ensure that the same exact configuration is present on each machine where it is
    installed.

    @section qorus_testing Qorus Testing

    A good testing strategy is critical for ensuring quality operations; to this end, Qorus supports testing from all
    supported languages.

    @subsection qorus_testing_enabling Enabling Test Execution

    By default the Qorus server does not allow tests to be executed.  To enable test execution by the Qorus server,
    set the @ref allow-test-execution option to \c true.

    To set this in a Docker instance, add a line like the following to your <tt>$OMQ_DIR/etc/options</tt> on the host
    (ex: <tt>qorus-etc/options</tt>):
    @verbatim
    qorus-client.allow-test-execution: true
    @endverbatim

    Additionally, you can execute a command like the following to enable testing in a Docker instance (make sure to
    use your own Qorus container name instead of \c qorus):
    @verbatim
    docker exec qorus bash -l -c "echo qorus-client.allow-test-execution: true >> $OMQ_DIR/etc/options"
    @endverbatim

    To enable running tests in <a href="https://kubernetes.io/">Kubernetes</a>, execute the following:
    @verbatim
    kubectl exec deploy/qorus-core -- bash -l -c "echo qorus-client.allow-test-execution: true >> $OMQ_DIR/etc/options"
    @endverbatim

    @note Qorus does not need to be restarted after setting this option; this is a client option and will take effect
    immediately

    @subsection qorus_test_devel Qorus Test Development

    Tests can be written in %Python, Java, and %Qore using Qorus's @ref qorusinterfacetest_module "QorusInterfaceTest"
    module to support Continuous Integration (along with
    @ref qorus_releases "automated release packaging and installation").

    Main test classes for the three main interface types are as follows:
    - @ref QorusInterfaceTest::QorusWorkflowTest "QorusWorkflowTest"
    - @ref QorusInterfaceTest::QorusServiceTest "QorusServiceTest"
    - @ref QorusInterfaceTest::QorusJobTest "QorusJobTest"

    See the links below for example test code and reference APIs.

    @see
    - @ref python_development_testing
    - @ref javadevelopment_testing
    - @ref qorusinterfacetest_module
*/

/** @page managed_by_operations Interface Parameters Managed by Operations

    @ref develguide "Back to the Developer's Guide Table of Contents"

    Some aspects of Qorus development are designed to be fine-tuned in operations, and the initial configuration
    delivered is treated as the initial default, and any changes to this configuration information using the
    system API are persistent, where future @ref oload "oload" operations of the interface will not overwrite the
    configuration supplied by operations.

    The following interface attributes and objects are treated in this way:
    - @ref job_config_items "Job configuration item values"
    - @ref job_remote "Job remote flag"
    - @ref job_schedule "Job schedules"
    - @ref service_autostart "Service autostart values"
    - @ref service_config_items "Service configuration item values"
    - @ref service_remote "Service remote flag"
    - @ref step_config_items "Step configuration item values"
    - @ref wf_autostart "Workflow autostart values"
    - @ref workflowconfigitems "Workflow configuration items"
    - @ref wf_remote "Workflow remote flag"
    - @ref wf_sla_threshold "Workflow SLA threshold values"
    - @ref definingconnections "User connection configurations"

    Note that @ref oload "oload" can be forced to override options changed in operations by using the \c -O option.
*/

/** @page debugging Debugging Qorus Interfaces

    @tableofcontents

    @ref develguide "Back to the Developer's Guide Table of Contents"

    The user code of Qorus interfaces may be debugged using %Qore's \c qdbg-remote command line utility, a debugger
    client program that uses the WebSocket protocol to connect to a remote Qorus server instance that serves as a
    WebSocket-based debug server.

    @note Only user code can be debugged by default.

    @section debugging_local_interfaces Debugging Local Interfaces

    To debug local interfaces, i.e. interfaces not running in separate processes but rather in @ref qorus-core (either
    for compatibility reasons or to reduce memory usage), use \c qdbg-remote to connect to @ref qorus-core using the
    instance's URL with the \c ws:// scheme and \c debug as the URI path

    @see @ref debug_uri_path_shortcut for environment variables to set to be able to use URL aliases for debugging

    The following is an example of debugging a local (i.e. non-@ref service_remote "remote") service called
    \c test-debug_service:
    @verbatim
$ qdbg-remote ws://localhost:8001/debug
connected to debug server "ws://localhost:8001/debug": Qorus Integration Engine v6.0.0_git (build 4742aa89eeb5514323bdadf3bcc67bb581206e7c) instance "qorus-6.0"; "help" for help
qdbg> ver
  client :
    class : DebugCommandLineRemote
  host :
    class : QorusWebSocketDebugProgramControl
qdbg> program list
    1 : qorus-core                      thr: 23 dbg: 0/0
    2 : Util.qm                         thr:  0 dbg: 0/0
    3 : Mime.qm                         thr:  0 dbg: 0/0
    .....
   50 : Qore::WebUtil::TextTemplateBase thr:  0 dbg: 0/0
   51 : prop:5.1                        thr:  0 dbg: 1/0
   52 : test-debug_service:1.0          thr:  0 dbg: 1/0
@endverbatim

    @section debugging_remote_interfaces Debugging Remote Interfaces

    To debug remote interfaces running in their own separate process, add the process name listed with
    @ref qctl "qctl ps" to the URI path as in the following example.

    For example to debug a @ref job_remote "remote job" named \c test-debug_job, first get the unique process name
    using @ref qctl "qctl ps" as in the following example:
@verbatim
$ qctl ps
active cluster processes:
  NAME                                NODE  HOST:PID    TYPE           QUEUE URL                 MEMORY STATUS
+ qorus-master                        node1 notey:31367 (qorus-master) tcp://127.0.0.1:40683  79.96 MiB OK
+ qorus-core                          node1 notey:31382 (qorus-core)   tcp://127.0.0.1:33093 323.82 MiB OK
+ qdsp-omq                            node1 notey:31398 (qdsp)         tcp://127.0.0.1:44477  97.51 MiB OK
+ qwf-TEST-DEBUG_WORKFLOW-v1.0-2      node1 notey:31936 (qwf)          tcp://127.0.0.1:45253 181.08 MiB OK
+ qjob-test-debug_job-v1.0-1          node1 notey:31784 (qjob)         tcp://127.0.0.1:46857 170.84 MiB OK
@endverbatim

    Then connect the debugger to the process using its Qorus process name \c qjob-test-debug_job-v1.0-1 as in the
    following example:

@verbatim
$ qdbg-remote ws://localhost:8001/debug/qjob-test-debug_job-v1.0-1
connected to debug server "ws://localhost:8001/debug/qjob-test-debug_job-v1.0-1": qjob-test-debug_job-v1.0-1; "help" for help
qdbg> ver
  client :
    class : DebugCommandLineRemote
  host :
    class : QorusDistributedDebugProgramControlSource
qdbg> program list
    1 : qjob                    thr:  5 dbg: 0/0
    2 : Util.qm                 thr:  0 dbg: 0/0
    3 : Mapper.qm               thr:  0 dbg: 0/0
    ...
   35 : PgsqlSqlUtil.qm         thr:  0 dbg: 0/0
   36 : test-debug_job:1.0      thr:  0 dbg: 1/0
@endverbatim

    @section debugging_explicit_source_code Providing Explicit Source Code Locations to the Qorus Debugger

    Qorus debug servers running in @ref qorus-core or in interface programs can also provide source code
    listings for running interfaces.  By default, the source code listings are procided as retrieved from the system
    DB schema.  If the source code for a running interface being debugged has been updated in the database without
    resetting the running interface program, then the source code listings provided by the Qorus debug servers will be
    out of date.

    The following example shows how the debugger server can be given an explicit source code location in case an
    interface currently being debugged has been updated in the database and the running interface was not reloaded:

@verbatim
qdbg> program 36
program context set to "36"
qdbg> program file /home/user/work/qore/qorus-devel/test/debug/test-debug_job-v1.0.qjob
sha1: 01f4a8cebffc08dc4546f6cee2a5b05258529704
 1: # -*- mode: qore; indent-tabs-mode: nil -*-
 2:
 3: # name: test-debug_job
 4: # version: 1.0
 5: # desc: Test debugging
 6: # author: Tomas Mandys
 7: # schedule: 0 2 * * *
 8: # define-group: Test-debug: Test debug
 9: # groups: Test-debug
10: # constants: test-debug_const
11: # functions: test-debug_func
12: # classes: test-debug_class
13: %require-types
14: %new-style
15:
16: sub run() {
17:         int max_ms = 10000;
18:         int i=0;
19:         int stamp = clock_getmillis();
20:         getHello();
21:         while (clock_getmillis() - stamp < max_ms) {
22:             #usleep(100);  # yield
23:             i++;
24:         }
25: }
26:
27: # END
@endverbatim

    @section debug_uri_path_shortcut Qorus Connection Provider Environment Variable for Debugging

    When \c QorusConnectionProvider is listed in the \c QORE_CONNECTION_PROVIDERS environment variable, the
    \c "qorus" alias can be used to connect to the local %Qorus instance as a shortcut for the local URL.

    @par Example \c QorusConnectionProvider Usage:
@verbatim
$ export QORE_CONNECTION_PROVIDERS=QorusConnectionProvider
$ qdbg-remote qorus
connected to debug server "ws://localhost:8001/debug": Qorus Integration Engine v6.0.0_git (build 4742aa89eeb5514323bdadf3bcc67bb581206e7c) instance "tma-6.0"; "help" for help
qdbg> quit
$ qdbg-remote qorus/qwf-TEST-DEBUG_WORKFLOW-v1.0-2
connected to debug server "ws://localhost:8001/debug/qwf-TEST-DEBUG_WORKFLOW-v1.0-2": qwf-TEST-DEBUG_WORKFLOW-v1.0-2; "help" for help
qdbg>
@endverbatim

    @note
    - All Qorus @ref remoteconn "remote connections" can be used as well as URL aliases; \c "qorus" is the automatic
      connection name that specifies the local Qorus server
    - In this case (and as a part of the setup of any Qorus installation), the Qorus module directory must be set in
      the \c QORE_MODULE_DIR environment variable as well to find the Qorus connection provider module
      \c QorusConnectionProvider.qm at runtime.

    @see
    - @ref installtarenvvars
    - <a href="https://github.com/qorelanguage/qore/wiki/Debugger-Tutorial">Qore debugging tutorial</a>
*/

/** @page commontasks Examples

    @tableofcontents

    @ref develguide "Back to the Developer's Guide Table of Contents"

    @section workdbs Working With Databases

    To work with a database, a @ref dsconn "datasource" must be defined and known by the system.

    For example, to acquire a shared @ref Qore::SQL::DatasourcePool "DatasourcePool" object for transaction management
    on the \c "billing" datasource, use the
    @ref OMQ::UserApi::UserApi::getDatasourcePool() "UserApi::getDatasourcePool()" method as in the following example:

    @code{.py}
# acquire a DatasourcePool object for datasource "billing"
DatasourcePool billing = UserApi::getDatasourcePool()("billing");
    @endcode

    If %Qore user code enters a transaction with either @ref Qore::SQL::Datasource "Datasource" or
    @ref Qore::SQL::DatasourcePool "DatasourcePool" objects and the thread is terminated (such as a workflow step or
    even a service call called from the network API) without closing the transaction, an exception will automatically
    be raised and the transaction will be rolled back.

    @subsection workdbs_highlevel_apis High-Level Database APIs

    To work with DB table data in a programmatic way, Qorus provides APIs that enable easy access to
    @ref SqlUtil::AbstractTable "AbstractTable" objects from the @ref sqlutilintro "SqlUtil" module, if the database
    driver is supported by @ref sqlutilintro "SqlUtil".

    The best API to use for working with DB table data is he @ref dataproviderintro "DataProvider" API, which provides
    generic APIs for working with enterprise integration patterns including with record-based data providers such as
    DB tables.

    @subsection execstoredprocs Executing Store Procedures and Functions

    The following is an example of executing a stored procedure on an Oracle database and retrieving the results:

    @code{.py}
# execute stored procedure "pkg.get_imsi" with iccid as argument,
# retrieving a hash as a result.
# The resulting hash will contain the following keys:
# imsi, status_code, error_code, error_desc

hash<auto> h = ds.exec("begin pkg.get_imsi(CRM', %v, :imsi, :status_code, :error_code, :error_desc); end;", iccid);
    @endcode

    The following is an example of executing a function in an Oracle database and retrieving the result (note that
    you have to declare the variable type in the SQL):

    @code{.py}
# execute function create_blacklist_entry() with msisdn as argument,
# retrieving a hash with a single key "code" as a result.
# note that the hash is dereferenced with ".code" after the exec()

string code = ds.exec("declare code varchar2(30) := null; begin :code = create_blacklist_entry(%v); end;", Type::String, msisdn).code;
    @endcode

    The %Qore Oracle driver needs to know the buffer type for all placeholder bind operations in advance.  The
    placeholders can be found in the SQL strings in the two examples above as the text prefixed by ":".  When no
    buffer type is given, the Oracle driver assumes a string buffer.  To declare another buffer type, use the %Qore
    Type constants as arguments in the position corresponding to the placeholder position in the SQL string.

    For example, here is an example similar to the first example above using different buffer types for the return
    values:

    @code{.py}
# execute stored procedure "pkg.get_imsi" with iccid as argument,
# retrieving a hash as a result.
# The resulting hash will contain the following keys:
# imsi, status_code, error_code, error_desc

hash<auto> h = ds.exec("begin pkg.get_imsi(CRM', %v, :date :blob, :clob, :integer); end;", iccid, Type::Date, Type::Binary, SQL::CLOB, Type::Integer);
    @endcode

    Note that the MySQL, PostgreSQL, Sybase, and FreeTDS drivers do not require placeholder buffer specifications when
    executing stored procedures.  For more examples of stored procedure calls and more information about connecting to
    other databases, see the <a href="../qore/lang/html/index.html">Qore Programming Language Reference Manual</a>.

    @section stream-api Work with Data Streaming

    The data streaming APIs provide high-level interfaces for the @ref datastreamprotocol
    without need of the low level protocol interaction.  @ref datastreamprotocol "DataStream"
    socket I/O always takes place in a background thread, which allows the main thread to handle
    data operations in parallel with network I/O.

    Streaming APIs are available for Qorus server objects (workflows, services, jobs) and also
    in the Qorus client.

    The following classes provide APIs to stream data to/from remote Qorus instances:
    - OMQ::DbRemoteSend
    - OMQ::DbRemoteReceive
    - OMQ::DbRemote
    - OMQ::FsRemote
    - OMQ::FsRemoteSend
    - OMQ::AbstractFsRemoteReceive

    @subsection stream-api-options Streaming API Constructor Options

    |!Key|!Default|!Description
    |\c block|\c 1000 (DB rows) or \c 16384 (FS bytes)|a block size for DataStream transmission chunks giving the \
        row count for DB streams or the bytes count for filesystem streams
    |\c encoding|\c "UTF-8"|the encoding of the target file; used in @ref OMQ::FsRemoteSend
    |\c loglevel|@ref OMQ::LL_INFO "LL_INFO"|the default logging level used in Qorus user code
    |\c mode|\c 0644|the file's creation mode as used in Qore::File::open2(); used in @ref OMQ::FsRemoteSend
    |\c queue_block_size|\c 2|the number of blocks to queue for sending before the main data thread will block; used \
        in @ref OMQ::DbRemoteSend and @ref OMQ::FsRemoteSend
    |\c queue_size|<tt>block * 2</tt>|the number of rows to queue before the main data thread will block; used in \
        @ref OMQ::DbRemoteReceive
    |\c select|\c NOTHING|@ref select_option_hash structure used in @ref OMQ::DbRemoteReceive
    |\c timeout|\c 60s|a timeout in milliseconds for HTTP operations (ex: \c 120s)

    @subsection stream-api-transmgt Streaming API Transaction Management

    A remote transaction can be performed in an external DB connected to a remote Qorus instance
    by using the @link ##sqlutil system.sqlutil service @endlink to begin the transaction and then
    commit or abort it.

    The @ref OMQ::DbRemoteSend and @ref OMQ::DbRemote classes will automatically start or continue a remote
    transaction by sending the \c "Qorus-Connection: Continue-Persistent" header when opening the stream.  The
    @ref OMQ::DbRemoteReceive class will do the same if the \c "transaction" option is set in the
    @ref OMQ::DbRemoteReceive::constructor() "constructor()" call.

    Additionally, a call to @ref OMQ::AbstractParallelStream::beginTransaction() can be made to explicitly start
    or continue a remote transaction in a remote database independently of any remote stream operations.

    Remote transactions must be explicitly committed with a call to the @ref sqlutil_streams "sqlutil commit stream"
    or to @ref OMQ::DbRemoteSend::commit() or @ref OMQ::DbRemoteReceive::commit() or @ref OMQ::DbRemote::commit()

    To abort a remote transaction, it's recommended to simply close the socket connection, particuarly because
    the HTTP connection could be in the middle of a stream action which would make HTTP messages impossible to send
    until the stream is completely sent or received.  When the connection is closed, any streams in progress are
    immediately terminated and the remote transaction is automatically rolled back.

    @see @ref sqlutil_transmgt for more information

    @subsection stream-api-db-remote Database: Single DML Statements

    @code{.py}
DbRemote db("my-remote", "omquser");
on_succes db.commit();
on_error db.rollback()
# get list of available tables
*list all_tables = db.list_tables();
# single insert
db.insert("my_table", ("id" : 11, "foo" : "bar"));
    @endcode

    @subsection stream-api-db-simple-send Database: Simple Data Sending

    @code{.py}
DbRemoteSend send("my-remote", "omquser", "insert", "my_table");
on_success send.commit();
on_error send.disconnect();
send.append( ("id" : 1, "column1" : "foo") );
    @endcode

    @code{.py}
%new-style
%require-types
%strict-args
%enable-all-warnings

%requires SqlUtil

sub rem_stream_send() {
    DatasourcePool dsstage = UserApi::getDatasourcePool("remote-1");
    on_success dsstage.commit();
    on_error dsstage.rollback();

    # just an sql logging
    string sql;
    on_exit UserApi::logInfo("sql: %s", sql);
    # select source data
    SqlUtil::AbstractTable t = UserApi::getSqlCache(dsstage, "erp_je_idt");
    hash sc_select = ( "columns" : ( "id", "entered_dr", "entered_cr" ), );

    SQLStatement stmt = t.getRowIterator(sc_select, \sql);

    DbRemoteSend out("test", "omquser", "insert", "erp_je_idt_test");
    on_success out.commit();
    on_error out.disconnect();

    out.append(stmt);
}
    @endcode

    @subsection stream-api-db-simple-recv Database: Simple Data Receiving

    @code{.py}
%new-style
%require-types
%strict-args
%enable-all-warnings

DbRemoteReceive recv("my-remote", "omquser", "select", "my_table");
while (auto d = recv.getData()) UserApi::logInfo("row: %y", d);
on_success send.commit();
on_error send.disconnect();
# rows will be logged out
    @endcode

    @code{.py}
%new-style
%require-types
%strict-args
%enable-all-warnings

sub rem_stream_recv() {
    DbRemoteReceive recv("test", "omquser", "select", "erp_je_idt_test");
    while (auto d = recv.getData()) UserApi::logInfo("row: %y", d);
}
    @endcode

    @subsection stream-api-db-complex-trans Database: Complex Transactions (mixed mode)

    @code{.py}
%new-style
%require-types
%strict-args
%enable-all-warnings

class SelectInsert {
    private {
        DbRemoteSend m_send;
        DbRemoteReceive m_recv;
    }

    constructor(string r) {
        m_recv = new DbRemoteReceive(r, "omquser", "select", "erp_je_idt_test", \received());
        m_send = new DbRemoteSend(r, "omquser", "insert", "erp_je_idt_test1");
        m_recv.receive();
    }

    commit() { m_send.commit(); }
    disconnect() { m_send.disconnect(); }

    nothing received(auto row) {
        UserApi::logInfo("received: %y", row);
        m_send.append(row);
    }
}

sub rem_stream_comb() {
    SelectInsert si("test");
    on_success si.commit();
    on_error si.disconnect();
}
    @endcode

    @subsection stream-api-fs-client Filesystem: Qorus client in action

    @code{.py}
%new-style
%require-types
%strict-args
%enable-all-warnings

%requires QorusClientCore

qorus_client_init2();

FsRemoteSend fs("test", "/tmp/qorus-client-stream.txt");
fs.append("lorem ipsum\n");
fs.commit();
    @endcode
*/
