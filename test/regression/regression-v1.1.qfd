# -*- mode: qore; indent-tabs-mode: nil -*-
# Qorus regression test function library

# type: GENERIC
# version: 1.0
# desc: dummy wf onetimeinit function
# author: Qore Technologies, s.r.o.
sub dummy_init() {
    UserApi::setOption(("test-opt": True));
}
# END

# type: GENERIC
# version: 1.1
# desc: regression test function
# name: regression1
# author: Qore Technologies, s.r.o.
# TAG: test: true
%new-style
%require-types

%requires SqlUtil
%requires RestClient
%requires DataStreamClient
%requires TableMapper
%requires BulkSqlUtil
%requires Schema
%requires FsUtil

# test java integration
%requires jni
%module-cmd(jni) set-compat-types false

const PollInterval = 250000;

# empty interface group
const TestEmptyGroup = "Test_Empty_Group_1";

# small interface group
const TestSmallGroup = "Test_Small_Group_1";

bool sub is_alpine_and_oracle() {
    return (ENV.MACHTYPE ?? "").find("alpine") > -1 && ENV.ORACLE_PWD;
}

sub stop_workflow(string name) {
    try {
        UserApi::callNetworkApi("omq.system.stop-workflow", name);
    } catch (hash<ExceptionInfo> ex) {
        # ignore "PARAMETER-ERROR" - it means that no instances of the workflow are running
        if (ex.err != "PARAMETER-ERROR")
            rethrow;
    }
}

sub wait_for_workflow_stop(softstring wfname_or_id, timeout max_wait = 15s) {
    date timeout = now_us() + max_wait;
    while (True) {
        int ec = UserApi::callRestApi("GET", "workflows/" + wfname_or_id + "/exec_count");
        if (!ec) {
            UserApi::logInfo("workflow %y has stopped; continuing test", wfname_or_id);
            break;
        }
        if (now_us() > timeout) {
            throw "WORKFLOW-TIMEOUT-ERROR", sprintf("workflow %y did not stop in the timeout period", wfname_or_id);
        }
        UserApi::usleep(100ms);
    }
}

sub wait_for_status(string testname, softstring wfiid, string status = OMQ::StatComplete, *softlist errors, *string stepname) {
    hash<auto> h;
    while (True) {
        h = omqservice.system.info.getWorkflowStatus2(wfiid);
        if (h.workflowstatus == status)
            break;

        if (exists errors && inlist(h.workflowstatus, errors))
            break;

        #UserApi::logDebug("%y wfiid %y status == %y (err: %y) h: %y", testname, wfiid, status, errors, h);

        # wait for status to change
        UserApi::usleep(PollInterval);
    }

    UserApi::logInfo("wfiid %d has status %y", wfiid, h.workflowstatus);

    if (stepname) {
        bool done;
        while (!done) {
            bool found;
            foreach hash sh in (h.step_instance.iterator()) {
                if (sh.name == stepname) {
                    if (sh.stepstatus == status) {
                        UserApi::logInfo("wfiid %d step %y has status %y", wfiid, stepname, status);
                        done = True;
                        break;
                    }
                    if (sh.stepstatus != OMQ::StatInProgress)
                        throw "STEP-STATUS-ERROR", sprintf("wfiid %d step %y expecting status %y; got %y", wfiid, stepname, status, sh.stepstatus);
                    found = True;
                }
            }

            UserApi::logInfo("wfiid %d step %y %sfound; sleeping %d us", wfiid, stepname, found ? "" : "not ", PollInterval);

            # wait for status to change
            UserApi::usleep(PollInterval);
            h = omqservice.system.info.getWorkflowStatus2(wfiid);
        }
    }

    test_value(h.workflowstatus, status, testname);
}

sub wait_for_resources(string service, timeout max_wait = 20s) {
    date start = now_us();
    date time_out = now_us() + max_wait;

    while (True) {
        hash<auto> sh = UserApi::callRestApi("GET", "services/" + service);
        if (sh.resources) {
            UserApi::logInfo("%s: service %y has %d resource%s; continuing; elapsed time: %y / max: %y",
                now_us().format("YYYY-MM-DD HH:mm:SS.xx"), service, sh.resources.size(),
                sh.resources.size() == 1 ? "" :"s", now_us() - start,
                milliseconds(max_wait));
            return;
        }

        if (now_us() > time_out) {
            throw "PROCESS-TIMEOUT-ERROR", sprintf("service %y did not get any resources in the timeout "
                "period; elapsed time: %y / max: %y", service, now_us() - start,
                milliseconds(max_wait));
        }
        # sleep for 1/4 of a second and check again
        UserApi::usleep(250ms);
    }
}

sub regression1() {
    QorusSystemRestHelper qrest();

    regression1_intern(qrest);

    # detach function test, block and unblock test; must be the last test in the workflow
    bug_287_290_351();
    # DO NOT ADD ANY TEST HERE (see the note with bug_287_290_351())
}

sub regression1_intern(QorusSystemRestHelper qrest) {
    hash<auto> simpletest_config = setup_simpletest();

    # do sqlutil tests if there is an "omquser" datasource
    bool has_omquser;
    try {
        qrest.get("remote/datasources/omquser/up");
        has_omquser = True;
    } catch (hash<ExceptionInfo> ex) {
        if (ex.err != "REST-CLASS-ERROR" && ex.err != "DATASTREAM-CLIENT-RECEIVE-ERROR") {
            rethrow;
        }
        UserApi::logInfo("no omquser datasource; skipping tests that require the omquser datasource");
        has_omquser = False;
    }

    issue_3433();

    issue_3226();

    issue_3313();

    issue_3247();

    issue_3120();

    issue_3243();

    issue_3198();

    issue_3190();

    issue_3161();

    issue_3157();

    issue_3158();

    issue_3096();

    issue_3051();

    issue_3053();

    issue_3054();

    issue_3052();

    issue_3032_3033();

    issue_3022();

    issue_2819();

    issue_2790();

    if (has_omquser) {
        issue_2833();
    }

    issue_2858(simpletest_config);

    issue_2812(simpletest_config);

    issue_2815();

    issue_2804();

    issue_2783();

    issue_2770();

    issue_2765();

    issue_2734();

    issue_2724();

    issue_2688();

    issue_2682();

    issue_2677();

    issue_2669();

    issue_2662();

    issue_2649();

    issue_2647(simpletest_config);

    issue_2646();

    issue_2603();

    issue_2618(simpletest_config);

    issue_1705();

    issue_2365();

    issue_2586();

    issue_2580();

    issue_2558();

    issue_2547();

    issue_2526();

    issue_2466();

    issue_3050();

    issue_2534();

    issue_2495();

    issue_2295_1(simpletest_config);

    issue_2295_2(simpletest_config);

    issue_2425();

    issue_2318();

    issue_2349();

    issue_2312();

    issue_2308();

    issue_2294();

    issue_2299();

    issue_1700(qrest);

    issue_2247();

    issue_2235();

    issue_2228();

    issue_2211(qrest);

    issue_2187();

    issue_2067();

    bug_2159();

    bug_2108(qrest);

    issue_1995();

    bug_1996(qrest);

    # check for REST authentication credentials in dynamicdata
    *hash<auto> dd = WorkflowApi::getDynamicData();
    if (dd.auth) {
        # set the REST username and password from the "auth" key
        (*string user, *string pass) = (dd.auth =~ x/([^:]+):(.*)/);
        qrest.setUserPassword(user, pass);
        # delete the "auth" key from dynamic data
        WorkflowApi::updateDynamicData(dd - "auth");
    }

    bug_1953(qrest);

    issue_2145();

    bug_1820_1825(qrest);

    # skip sensitive data tests if there are no encryption keys
    bool has_sd = UserApi::getQorusOptions("sensitive-data-key").toBool();

    if (has_sd) {
        feature_1407(qrest);
    }

    bug_1561(qrest);

    bug_1760(qrest);

    # test issue 2152
    issue_2152();

    # test bug 1339
    bug_1339(qrest);

    # test WorkflowApi::appendOrderKeys()
    feature_1336();

    # test bug 1326
    bug_1326(qrest);

    # test feature 1248
    feature_1248();

    # test feature 1302
    feature_1302();

    # test bugs 1277 and 1605
    bug_1277_1605(qrest);

    # test stream connection overlap detection
    test_stream_connection_overlap(qrest);

    # test bug 1252
    bug_1252(qrest);

    if (has_omquser) {
        # there is a race condition in this test
        #bug_1545(qrest);

        sqlutil_tests(qrest);
    }

    # test bug 1152
    bug_1152();

    # test datasource apis
    test_datasource_apis();

    # test bug 1119
    bug_1119(qrest);

    # test bug 938
    bug_938(qrest);

    # test garbage collection with circular references
    if (HAVE_DETERMINISTIC_GC)
        test_gc();

    # test bug 852
    bug_852();

    # test REST error APIs
    test_rest_errors(qrest);

    # test value sets
    vsets_tests();

    # fs tests
    fs_tests(qrest);

    # bug 815
    bug_815();

    # do soap tests
    soap_tests(UserApi::qorusGetLocalUrl());

    # bug 785
    bug_785();

    # bug 548_549
    bug_548_549();

    # bug 544
    bug_544();

    # bug 511
    bug_511();

    # test bug 1199
    bug_1199(qrest);

    # make sure all instances of FEEDBACK-TEST are stopped
    stop_workflow("FEEDBACK-TEST");

    # check child feedback
    # bug 1238: check multiple keys
    test_value(WorkflowApi::getDynamicData("one"), WorkflowApi::getChildFeedback("one"), "feedback-1");
    test_value(WorkflowApi::getDynamicData("two"), WorkflowApi::getChildFeedback("two"), "feedback-2");

    date start = now_us();
    UserApi::sleep(1);
    test_value((now_us() - start) >= 1s, True, "UserApi::sleep");
    start = now_us();
    UserApi::usleep(100ms);
    assert_ge(100ms, now_us() - start, "UserApi::usleep");
    *int aid = UserApi::auditUserEvent("REGRESSION-WORKFLOW-EVENT");
    test_value(type(aid), UserApi::auditCheckEventString(OMQ::AES_USER_EVENT) ? Type::Int : Type::NothingType, "audit-1");

    hash h = UserApi::callNetworkApi("omq.system.get-status");
    test_value(h."instance-key", UserApi::getSystemInfo()."instance-key", "get-status");

    h = UserApi::callNetworkApi("omq.system.help", "add-user");
    test_value(type(h."omq.system.add-user".description), Type::String, "add-user");

    h = WorkflowApi::getWorkflowInstanceData();
    test_value(h.name, "REGRESSION-TEST", "getWorkflowInstanceData 1");
    test_value(type(h.priority), Type::Int, "getWorkflowInstanceData 2");
    test_value(type(h.started), Type::Date, "getWorkflowInstanceData 3");
    if (h.instancemode == "NORMAL")
        UserApi::logInfo("skipping status test for non-synchronous execution");
    else
        test_value(h.status, OMQ::StatInProgress, "getWorkflowInstanceData 4");
    test_value(h.dbstatus, OMQ::StatInProgress, "getWorkflowInstanceData 5");
    test_value(h.workflow_instanceid.toInt(), WorkflowApi::getWfiid(), "WorkflowApi::getWfiid");

    # test for issue #2085; ensure that empty URI arguments are ignored
    h = UserApi::callRestApi("GET", "orders?workflow_instanceid=" + h.workflow_instanceid + "&maxmodified=")[0];

    # stop all instances of DUMMY-TEST
    stop_workflow("DUMMY-TEST");

    # run 2nd schedule and reschedule test
    schedule2_test();

    # run priority test
    int id = priority_test();

    # bug 278 test
    bug_278(id, qrest);

    # http service binding tests
    http_tests(qrest.getURL().substr(0, -4));

    # ftp service binding tests
    ftp_tests();

    # bug 302 test
    bug_302();

    # bug 324 tests
    bug_324();

    # bug 342 test
    bug_342();

    # bug 356 test
    bug_356();

    # bug 368: calling omq.system.job.run*() causes qorus to crash immediately
    bug_368();

    bug_1552(qrest);

    bug_1719(qrest);

    bug_1879(qrest);
}

sub wait_for_process_call(string proc_id, string call, timeout max_wait = 15s) {
    date start = now_us();
    date timeout = now_us() + max_wait;
    while (True) {
        string str = backquote("qctl threads " + proc_id);
        if (regex(str, call)) {
            UserApi::logInfo("proc %y in in call %y; continuing; elapsed time: %y / max: %y", proc_id, call,
                now_us() - start, milliseconds(max_wait));
            break;
        }
        if (now_us() > timeout) {
            throw "PROCESS-TIMEOUT-ERROR", sprintf("proc %y did not call %y in the timeout period; elapsed time: %y / "
                "max: %y", proc_id, call, now_us() - start, milliseconds(max_wait));
        }
        # sleep for 1/4 of a second and check again
        UserApi::usleep(250ms);
    }
}

sub wait_for_service_status(string service, string status, timeout max_wait = 15s) {
    date start = now_us();
    date timeout = start + max_wait;
    while (True) {
        string current_status;
        try {
            current_status = UserApi::callRestApi("GET", "/services/" + service + "/status");
        } catch (hash<ExceptionInfo> ex) {
            if (ex.err == "CLIENT-DEAD" || ex.err == "CLIENT-TERMINATED" || ex.err == "CLIENT-ABORTED") {
                UserApi::logInfo("service %y has aborted; status is \"unloaded\"", service);
                current_status = "dead";
            } else {
                rethrow;
            }
        }
        if (current_status == status) {
            UserApi::logInfo("service %y has status %y; continuing; elapsed time: %y / max: %y", service, status,
                now_us() - start, milliseconds(max_wait));
            break;
        }
        if (now_us() > timeout) {
            throw "SERVICE-TIMEOUT-ERROR", sprintf("service %y did not get status %y in the timeout period "
                "(status: %y); elapsed time: %y / max: %y", service, status, current_status, now_us() - start,
                milliseconds(max_wait));
        }
        # sleep for 1/4 of a second and check again
        UserApi::usleep(250ms);
    }
}

sub wait_for_process_not_pid(string proc_id, int pid, timeout max_wait = 15s) {
    date start = now_us();
    date timeout = now_us() + max_wait;
    while (True) {
        *hash<auto> proc_info;
        try {
            proc_info = UserApi::callRestApi("GET", "system/processes/" + proc_id);
        } catch (hash<ExceptionInfo> ex) {
            # 404 Not Found = no process; ignore
            if ((ex.arg.ex.arg ?? ex.arg) != 404) {
                #UserApi::logError("ex.arg: %N", ex.arg);
                rethrow;
            }
        }
        if (proc_info && proc_info.pid != pid) {
            UserApi::logInfo("proc %y restarted with PID %d; continuing; elapsed time: %y / max: %y", proc_id,
                proc_info.pid, now_us() - start, milliseconds(max_wait));
            break;
        }
        if (now_us() > timeout) {
            throw "PROCESS-TIMEOUT-ERROR", sprintf("process %y did not get a new PID in the timeout period "
                "(info: %y); elapsed time: %y / max: %y", proc_id, proc_info, now_us() - start,
                milliseconds(max_wait));
        }
        # sleep for 1/4 of a second and check again
        UserApi::usleep(250ms);
    }
}

string sub wait_get_process_id(string interface, string type, timeout max_wait = 15s) {
    string uri_path = interface + "/" + type;
    date start = now_us();
    date timeout = now_us() + max_wait;
    while (True) {
        try {
            # get the process ID
            string proc_id;
            if (type == "services") {
                proc_id = UserApi::callRestApi("GET", uri_path + "/processes")[0].id;
            } else {
                proc_id = UserApi::callRestApi("GET", uri_path + "/process/id");
            }
            UserApi::logInfo("got proc ID %y for %y; continuing; elapsed time: %y / max: %y", proc_id, uri_path,
                now_us() - start, milliseconds(max_wait));
            return proc_id;
        } catch (hash<ExceptionInfo> ex) {
            # 404 Not Found = no process; ignore
            if ((ex.arg.typeCode() == NT_INT ? ex.arg : ex.arg.ex.arg) != 404) {
                rethrow;
            }
        }
        if (now_us() > timeout) {
            throw "PROCESS-TIMEOUT-ERROR", sprintf("no process info became available for %y in the timeout period; "
                "elapsed time: %y / max: %y", uri_path, now_us() - start, milliseconds(max_wait));
        }
        # sleep for 1/4 of a second and check again
        UserApi::usleep(250ms);
    }
}

hash<auto> sub setup_simpletest() {
    # get workflow config
    hash<auto> wfh = UserApi::callRestApi("GET", "workflows/SIMPLETEST");

    # make sure SIMPLETEST has remote = True and autostart = 0
    if (wfh.autostart != 0) {
        UserApi::callRestApi("PUT", "workflows/SIMPLETEST/setAutostart", {"autostart": 0});
    }
    if (!wfh.remote) {
        UserApi::callRestApi("PUT", "workflows/SIMPLETEST/setRemote", {"remote": True});
    }

    # make sure SIMPLETEST runs without errors
    UserApi::callRestApi("PUT", "workflows/SIMPLETEST/setOptions", {"options": {"no-errors": True}});

    return wfh;
}

sub issue_3433() {
    AbstractDataProviderType type = UserApi::getTypeFromPath("type/qore/sftp/event");
    assert_eq("hash<auto>", type.getBaseTypeName());
    type = UserApi::getTypeFromPath("type/qore/sftp/event/filepath");
    assert_eq("string", type.getBaseTypeName());
    assert_throws("DATA-TYPE-ERROR", \UserApi::getTypeFromPath(), "invalid");
    assert_throws("DATA-TYPE-ERROR", \UserApi::getTypeFromPath(), "datasource/xxxx_invalid");
}

sub issue_3226() {
    # set tags manually in case they have been changed
    hash<auto> tags = {
        "tag1": "value1",
        "tag2": 2,
        "tag3": "3",
    };
    *hash<auto> ctags = UserApi::callRestApi("GET", "remote/user/conn-test/tags");
    if (ctags != tags) {
        UserApi::callRestApi("PUT", "remote/user/conn-test", {"tags": tags});
    }

    ctags = UserApi::getUserConnectionTags("conn-test");
    assert_eq(tags, ctags);
}

sub issue_3313() {
    hash<auto> h = UserApi::callRestApi("POST", "workflows/ISSUE-3313?action=execSynchronous", {"staticdata": {"a": 0}});
    assert_eq(OMQ::StatComplete, h.status);
}

sub issue_3247() {
    assert_eq(1, omqservice.user."issue-3247".getValue());
}

sub issue_3120_run_tests() {
    UserApi::callRestApi("PUT", "jobs/MultiInterfaceTest/enable");
    hash<auto> h = UserApi::callRestApi("PUT", "jobs/MultiInterfaceTest/run");
    assert_eq(OMQ::StatComplete, h.status);
    UserApi::callRestApi("PUT", "services/MultiInterfaceTest/enable");
    assert_eq(1, omqservice.user.MultiInterfaceTest.other());

    UserApi::callRestApi("PUT", "workflows/MULTI-DEV-MOD-TEST/enable");
    h = UserApi::callRestApi("POST", "workflows/MULTI-DEV-MOD-TEST/execSynchronous", {"staticdata": {}});
    assert_eq(OMQ::StatComplete, h.status);
}

sub issue_3120_set_remote(bool remote) {
    UserApi::callRestApi("PUT", "workflows/MULTI-DEV-MOD-TEST/setRemote", {"remote": remote});
    UserApi::callRestApi("PUT", "services/MultiInterfaceTest/setRemote", {"remote": remote});
    UserApi::callRestApi("PUT", "jobs/MultiInterfaceTest/setRemote", {"remote": remote});
}

sub issue_3120() {
    # make sure interfaces are set as remote
    issue_3120_set_remote(True);
    issue_3120_run_tests();

    # make sure interfaces are set as local
    issue_3120_set_remote(False);
    issue_3120_run_tests();
}

sub issue_3243() {
    UserApi::callRestApi("PUT", "services/issue-3243/config/issue-3243-svc-config-item-2", {"value": 1});
    hash<auto> info = UserApi::callRestApi("GET", "services/issue-3243/config/issue-3243-svc-config-item-2");
    assert_eq("any", info.type);
    assert_eq(1, info.value);
    assert_eq("int", info.currentType);

    UserApi::callRestApi("PUT", "services/issue-3243/config/issue-3243-svc-config-item-2", {"value": "string"});
    info = UserApi::callRestApi("GET", "services/issue-3243/config/issue-3243-svc-config-item-2");
    assert_eq("string", info.value);
    assert_eq("string", info.currentType);
}

sub issue_3198() {
    {
        on_exit UserApi::callRestApi("PUT", "services/issue-3198/unload");
        assert_eq("test", omqservice.user."issue-3198".mapIt({"input": "test"}).output);
    }
    {
        hash<auto> job_result = UserApi::callRestApi("PUT", "jobs/issue-3198/run");
        assert_eq(OMQ::StatComplete, job_result.status);
        assert_eq("test", UserApi::callRestApi("GET", "jobresults/" + job_result.job_instanceid + "/info/output"));
    }
}

sub issue_3190() {
    # get current options
    *hash<auto> opts = UserApi::callRestApi("GET", "remote/user/conn-test").opts;
    # restore options on exit
    on_exit {
        if (opts) {
            UserApi::callRestApi("PUT", "remote/user/conn-test", {"opts": opts});
        }
    }
    # set options
    hash<auto> new_opts = {"timeout": 1};
    UserApi::callRestApi("PUT", "remote/user/conn-test", {"opts": new_opts});
    assert_eq(new_opts, UserApi::callRestApi("GET", "remote/user/conn-test/opts"){keys new_opts});
    # clear options
    UserApi::callRestApi("PUT", "remote/user/conn-test", {"opts": {}});
    assert_eq({"timeout": 45000}, UserApi::callRestApi("GET", "remote/user/conn-test").opts{keys new_opts});
}

sub issue_3161() {
    string ver = get_random_string();
    assert_throws("REST-ERROR", \UserApi::callRestApi(), ("GET", "services/info:" + ver));
    assert_throws("JOB-ERROR", \UserApi::callRestApi(), ("GET", "jobs/qorus-sensitive-data:" + ver));

    ver = UserApi::callRestApi("GET", "services/info/version");
    assert_eq(Type::Hash, UserApi::callRestApi("GET", "services/info:" + ver).type());
    ver = UserApi::callRestApi("GET", "jobs/qorus-sensitive-data/version");
    assert_eq(Type::Hash, UserApi::callRestApi("GET", "jobs/qorus-sensitive-data:" + ver).type());
}

sub issue_3157() {
    # test for 404 error
    try {
        UserApi::callRestApi("POST", "errors");
        assert_eq(True, False);
    } catch (hash<ExceptionInfo> ex) {
        if (ex.err != "REST-ERROR" || (ex.arg.typeCode() == NT_INT ? ex.arg : ex.arg.ex.arg) != 400) {
            UserApi::logInfo("%s", get_exception_string(ex));
        }
        #UserApi::logInfo("%s", get_exception_string(ex));
        assert_eq(400, ex.arg.typeCode() == NT_INT ? ex.arg : ex.arg.ex.arg);
        assert_eq("REST-ERROR", ex.err);
        assert_eq(True, ex.desc =~ /missing.required.*parameter/);
    }

    string new_error = sprintf("%s.%s", get_random_string(), get_random_string());
    assert_eq("CREATED-GLOBAL", UserApi::callRestApi("POST", "errors", {"error": new_error}));
    assert_eq("OK", UserApi::callRestApi("DELETE", "errors/" + new_error));
}

sub issue_3158() {
    *hash<auto> appender = UserApi::callRestApi("GET", "system/defaultLoggerAppenders")[0];
    if (!appender.params.encoding) {
        UserApi::logInfo("skipping test for issue #3158; default appender has no encoding: %y", appender);
        return;
    }

    assert_throws("INVALID-APPENDER-ENCODING", \UserApi::callRestApi(), ("PUT", "system/defaultLoggerAppenders", {
        "id": appender.appenderid,
        "encoding": "issue-3158-invalid-encoding",
    }));
}

sub issue_3096() {
    try {
        # make sure the service is attempted to be loaded before testing the REST API
        UserApi::callRestApi("PUT", "services/issue-3096/setAutostart", {"autostart": True});
    } catch (hash<ExceptionInfo> ex) {
        # ignore exception
    }
    on_exit {
        UserApi::callRestApi("PUT", "services/issue-3096/setAutostart", {"autostart": False});
    }

    # ensure that services can be read
    assert_eq(Type::List, UserApi::callRestApi("GET", "services?short=1").type());
}

sub issue_3051() {
    auto resp = UserApi::callRestApi("PUT", "system/config/test-item", {"value": "test-value"});
    UserApi::logInfo("issue_3051: RESP: %y", resp);
    Mapper mapper = UserApi::getMapper("mapper-api-test");
    softint wfiid = WorkflowApi::getWfiid();
    hash<auto> expected_value = {
        "config-item-1": "test-value",
        "ctx-1": wfiid,
        "template-1": "string-" + wfiid,
    };
    assert_eq({
        "config-item-1": "test-value",
        "ctx-1": wfiid,
        "template-1": "string-" + wfiid,
    }, mapper.mapData({"input-1": "string-$local:workflow_instanceid"}));
}

sub issue_3053() {
    UserApi::callRestApi("PUT", "workflows/ASYNC-TEST/enable");
    UserApi::callRestApi("PUT", "workflows/ASYNC-TEST/setAutostart", {"autostart": 1});
    on_error {
        UserApi::callRestApi("PUT", "workflows/ASYNC-TEST/setAutostart", {"autostart": 0});
    }

    softint wfiid = UserApi::callRestApi("POST", "workflows/ASYNC-TEST/createOrder", {"staticdata": {
        "key": get_random_string(80),
    }}).workflow_instanceid;
    UserApi::logInfo("created ASYNC-TEST wfiid %d", wfiid);
    # cancel the order on exit
    on_exit {
        UserApi::callRestApi("PUT", "orders/" + wfiid + "/cancel");
    }

    # wait for order to have ASYNC-WAITING status
    wait_for_status("issue-3053-1", wfiid, OMQ::StatAsyncWaiting, (OMQ::StatError, OMQ::StatComplete));

    # set an order note
    UserApi::callRestApi("POST", "orders/" + wfiid + "/notes", {"note": "test"});

    # stop the workflow while the order is cached
    UserApi::callRestApi("PUT", "workflows/ASYNC-TEST/setAutostart", {"autostart": 0});

    # verify that note is present
    assert_eq("test", UserApi::callRestApi("GET", "orders/" + wfiid + "/notes")[0].note);
}

sub issue_3052() {
    # ensure that the service is loaded before running the test
    UserApi::callRestApi("PUT", "services/issue-3052/load");
    on_exit {
        UserApi::callRestApi("PUT", "services/issue-3052/unload");
    }

    hash<auto> info;
    hash hdr = {
        "x-api-key": "abc12345",
    };

    string url = UserApi::qorusGetLocalUrl();
    if (url =~ /:[0-9]{3,5}/) {
        hash h = parse_url(url);
        url = h.host;
    }
    url += ":30520";

    {
        RestClient rest({
            "url": url + "/issue3052",
        });
        assert_throws("REST-RESPONSE-ERROR", "401.*unauthorized.*invalidkey",
            \rest.get(), ("/a", NOTHING, \info, hdr + {"x-api-key": "def"}));
        auto result = rest.get("/a", NOTHING, \info, hdr);
        assert_eq(200, result.status_code);
        assert_eq("/issue3052/a", result.body);
    }

    {
        RestClient rest({
            "url": url + "/issue3052/v2",
        });
        assert_throws("REST-RESPONSE-ERROR", "401.*unauthorized.*invalidkey v2",
            \rest.get(), ("/a", NOTHING, \info, hdr + {"x-api-key": "def"}));
        auto result = rest.get("/a", NOTHING, \info, hdr);
        assert_eq(200, result.status_code);
        assert_eq("/issue3052/v2/a", result.body);
    }

    UserApi::callRestApi("PUT", "services/issue-3052/load");
    UserApi::callRestApi("PUT", "services/issue-3052/unload");
    UserApi::callRestApi("PUT", "services/issue-3052/load");
}

sub issue_3022() {
    UserApi::callRestApi("PUT", "services/issue-3022/load");
    UserApi::callRestApi("PUT", "services/issue-3022-remote/load");
    on_exit UserApi::callRestApi("PUT", "services/issue-3022-remote/unload");
    on_exit UserApi::callRestApi("PUT", "services/issue-3022/unload");

    hash<auto> info;
    hash hdr = {
        "x-api-key": "abc12345",
        "x-api-auth": "loremipsum"
    };

    string url = UserApi::qorusGetLocalUrl();
    if (url =~ /:[0-9]{3,5}/) {
        hash h = parse_url(url);
        url = h.host;
    }

    {
        RestClient rest({"url": url + ":30220/issue3022"});
        assert_throws("REST-RESPONSE-ERROR", "401.*unauthorized.*missingkey", \rest.get(), ("/a", NOTHING, \info, hdr - "x-api-key"));
        assert_throws("REST-RESPONSE-ERROR", "401.*unauthorized.*invalidkey", \rest.get(), ("/a", NOTHING, \info, hdr + {"x-api-key": "def"}));
        assert_throws("REST-RESPONSE-ERROR", "403.*xxforbidden", \rest.get(), ("/a", NOTHING, \info, hdr - "x-api-auth"));
        auto result = rest.get("/a", NOTHING, \info, hdr);
        assert_eq(200, result.status_code);
        assert_eq("okok", result.body);
    }

    {
        RestClient rest({"url": url + ":30221/issue3022"});
        assert_throws("REST-RESPONSE-ERROR", "401.*unauthorized.*missingkey", \rest.get(), ("/a", NOTHING, \info, hdr - "x-api-key"));
        assert_throws("REST-RESPONSE-ERROR", "401.*unauthorized.*invalidkey", \rest.get(), ("/a", NOTHING, \info, hdr + {"x-api-key": "def"}));
        assert_throws("REST-RESPONSE-ERROR", "403.*xxforbidden", \rest.get(), ("/a", NOTHING, \info, hdr - "x-api-auth"));
        auto result = rest.get("/a", NOTHING, \info, hdr);
        assert_eq(200, result.status_code);
        assert_eq("okok", result.body);
    }
}

sub issue_2819() {
    # kill the omq process and ensure that qorus continues normally
    UserApi::callRestApi("POST", "system/processes/qdsp-omq/kill");
    assert_eq(True, True);
}

sub issue_2790() {
    # get a hash of all loopback qorus connections
    *hash<string, bool> rh = map {$1.name: True}, UserApi::callRestApi("GET", "remote/qorus"), $1.loopback;
    # make sure none appear as remote connections in the system/health response
    assert_eq(False, (map $1, UserApi::callRestApi("GET", "system/health/remote"), rh{$1.name}).val());
}

sub issue_2815() {
    UserApi::callRestApi("PUT", "jobs/test/setActive", {"active": False});
    UserApi::callRestApi("PUT", "jobs/test/setExpiry", {"date": now_us() - 1D});
    on_exit {
        UserApi::callRestApi("PUT", "jobs/test/setExpiry", {"date": NOTHING});
    }

    assert_throws("JOB-ERROR", \UserApi::callRestApi(), ("PUT", "jobs/test/setActive", {"active": True}));
}

DatasourcePool sub wait_for_updated_pool(DatasourcePool dsp, string qdsp_hash) {
    date now = now_us();

    dsp = UserApi::getDatasourcePool("omquser", False);
    UserApi::logInfo("got new qdsp client %y", dsp.uniqueHash());

    while (True) {
        try {
            string qdsp_new_hash = dsp.getInfo()."pool-hash";
            if (qdsp_new_hash != qdsp_hash) {
                UserApi::logInfo("qdsp %y updated; continuing", dsp.getConfigString());
                return dsp;
            }
            date now1 = now_us();
            if ((now1 - now) > 15s) {
                throw "DSP-TIMEOUT", sprintf("datasourced %y did not get updated in the timeout period", dsp.getConfigString());
            }
            UserApi::logInfo("qdsp %y not yet updated; sleeping 1 second", dsp.getConfigString());
        } catch (hash<ExceptionInfo> ex) {
            if (ex.err != "CLIENT-DEAD" && ex.err != "CLIENT-TERMINATED" && ex.err != "CLIENT-ABORTED") {
                rethrow;
            }
            UserApi::logInfo("resetting datasource due to error: %s: %s", ex.err, ex.desc);
            UserApi::callRestApi("PUT", "remote/datasources/" + dsp.getServerName() + "/reset");
            dsp = UserApi::getDatasourcePool("omquser", False);
        }
        UserApi::sleep(1s);
    }
    return dsp;
}

sub issue_2833() {
    # only run this test with debug builds of Qorus
    if (!UserApi::isInternalSystemDebuggingEnabled()) {
        UserApi::logInfo("cannot run qdsp crash test with non-debugging builds of Qorus; skipping test for issue #2833");
        return;
    }

    # ensure that the datasource pool exists
    DatasourcePool dsp = UserApi::getDatasourcePool("omquser", False);
    UserApi::logInfo("got qdsp client %y", dsp.uniqueHash());

    *string qdsp_hash = dsp.getInfo()."pool-hash";

    # have the qdsp process abort while restarting after a reset
    # create a 0-length signal file telling the qdsp process to terminate in the constructor
    string signal_file = sprintf("%s/%s-omquser-constructor", tmp_location(), UserApi::getSystemInfo()."instance-key");
    {
        File f();
        f.open2(signal_file, O_CREAT | O_WRONLY | O_TRUNC);
    }
    # the signal file will be unlinked by the qdsp process if the test works properly
    on_error unlink(signal_file);
    UserApi::logInfo("issue #2833 reset test: created signal file %y", signal_file);

    # kill the qdsp process
    hash<auto> h = UserApi::callRestApi("POST", "system/processes/qdsp-omquser/kill");
    assert_eq("OK", h.status);
    assert_eq(0, h.code);

    # wait for datasource to be marked down
    {
        date now = now_us();
        while (True) {
            hash<auto> omquser_info = UserApi::callRestApi("GET", "remote/datasources/omquser");
            if (!omquser_info."shared-pool") {
                UserApi::logInfo("omquser datasource pool has been removed");
                break;
            }
            if ((now_us() - now) > 20s) {
                throw "QDSP-TIMEOUT", "the pool for qdsp-omquser did not get removed in the timeout period";
            }
            UserApi::usleep(250ms);
        }
    }

    # reset the datasource
    UserApi::callRestApi("PUT", "remote/datasources/omquser/reset");

    # verify that it's up
    assert_eq(True, UserApi::callRestApi("GET", "remote/datasources/omquser/up"));

    # get a new pool object and verify that it works
    dsp = wait_for_updated_pool(dsp, qdsp_hash);
    auto server_version_info = dsp.getServerVersion();
    UserApi::logInfo("omquser server version: %y", server_version_info);
    assert_eq(True, exists server_version_info);
}

sub issue_2858(hash<auto> simpletest_config) {
    UserApi::callRestApi("PUT", "workflows/SIMPLETEST/stop");
    hash<auto> h = UserApi::callRestApi("PUT", "workflows/SIMPLETEST/start");
    assert_eq(1, h.exec.size());

    string ok = UserApi::callRestApi("PUT", "workflows/SIMPLETEST/stop");
    assert_eq("OK", ok);

    assert_eq(0, UserApi::callRestApi("GET", "workflows/SIMPLETEST/exec_count"));
}

sub issue_2812(hash<auto> simpletest_config) {
    # only run this test with debug builds of Qorus
    if (!UserApi::isInternalSystemDebuggingEnabled()) {
        UserApi::logInfo("cannot run workflow crash test with non-debugging builds of Qorus; skipping test for issue #2812");
        return;
    }

    # make sure SIMPLETEST has autostart = 1
    UserApi::callRestApi("PUT", "workflows/SIMPLETEST/setAutostart", {"autostart": 1});
    on_exit {
        UserApi::callRestApi("PUT", "workflows/SIMPLETEST/setAutostart", {"autostart": 0});
    }

    string proc_id = sprintf("qwf-SIMPLETEST-v1.0-%d", simpletest_config.workflowid);

    # wait for qwf process to start
    wait_for_process_not_pid(proc_id, -1);

    # have the wf abort while restarting after a reset
    # create a 0-length signal file telling the qwf process to terminate in the setupComplete call
    string signal_file = sprintf("%s/%s-%s-%s-%s-setOption", tmp_location(), UserApi::getSystemInfo()."instance-key",
        simpletest_config.name, simpletest_config.version, simpletest_config.workflowid);
    {
        File f();
        f.open2(signal_file, O_CREAT | O_WRONLY | O_TRUNC);
    }
    # the signal file will be unlinked by the qwf process if the test works properly
    on_error unlink(signal_file);
    UserApi::logInfo("issue #2812 reset test: created signal file %y", signal_file);

    UserApi::callRestApi("PUT", "workflows/SIMPLETEST/reset");

    assert_eq(True, True);
}

sub issue_2804() {
    # make sure the service is running remotely
    UserApi::callRestApi("PUT", "services/issue-2804/setRemote", {"remote": True});
    # load the service
    UserApi::callRestApi("PUT", "services/issue-2804/load");

    wait_for_service_status("issue-2804", "unloaded");

    assert_throws("LOCK-ERROR", \UserApi::callRestApi(), ("PUT", "services/issue-2804/test/call"));
}

sub issue_2783() {
    try {
        UserApi::callRestApi("GET", "workflows/invalid-workflow-" + get_random_string());
        assert_eq(True, False);
    } catch (hash<ExceptionInfo> ex) {
        assert_eq(404, ex.arg.typeCode() == NT_INT ? ex.arg : ex.arg.ex.arg);
    }
}

sub issue_2770() {
    # make sure we can set the retry delay on a running remote workflow
    UserApi::callRestApi("PUT", "workflows/SIMPLETEST/setRemote", {"remote": True});
    UserApi::callRestApi("PUT", "workflows/SIMPLETEST/setAutostart", {"autostart": 1});
    on_exit {
        UserApi::callRestApi("PUT", "workflows/SIMPLETEST/setAutostart", {"autostart": 0});
    }
    UserApi::callRestApi("PUT", "workflows/SIMPLETEST/enable");

    # this call will throw an exception without the fix
    UserApi::callRestApi("PUT", "workflows/SIMPLETEST/setOptions", {"options": {"recover_delay": NOTHING}});
    assert_eq(True, True);
}

sub issue_2765() {
    # make sure we can change the remote status of workflows
    bool remote = UserApi::callRestApi("GET", "workflows/SIMPLETEST/remote");
    UserApi::callRestApi("PUT", "workflows/SIMPLETEST/setRemote", {"remote": !remote});
    assert_eq(True, True);
    if (remote) {
        UserApi::callRestApi("PUT", "workflows/SIMPLETEST/setRemote", {"remote": remote});
    }

    # make sure we can change the remote status of services
    remote = UserApi::callRestApi("GET", "services/http-test/remote");
    UserApi::callRestApi("PUT", "services/http-test/setRemote", {"remote": !remote});
    assert_eq(True, True);
    if (remote) {
        UserApi::callRestApi("PUT", "services/http-test/setRemote", {"remote": remote});
    }

    # make sure we can change the remote status of jobs
    remote = UserApi::callRestApi("GET", "jobs/test/remote");
    UserApi::callRestApi("PUT", "jobs/test/setRemote", {"remote": !remote});
    assert_eq(True, True);
    if (remote) {
        UserApi::callRestApi("PUT", "jobs/test/setRemote", {"remote": remote});
    }
}

sub issue_2734() {
    # make sure http-test is not loaded
    UserApi::callRestApi("PUT", "services/http-test/unload");

    # load it in the background
    system("qrest put services/http-test/load &");

    string status;
    while (True) {
        # keep trying to get the service info to trigger the race
        status = UserApi::callRestApi("GET", "services/http-test/status");
        if (status == "loaded") {
            break;
        }
        # repeat with no delay
    }

    assert_eq("loaded", status);
}

sub issue_2724() {
    WorkflowApi::stepWarning("TEST-WARNING", "this is a test: %s", "test1");
    WorkflowApi::stepWarning("TEST-WARNING", "this is a test: %s", "test2");
}

sub issue_2688() {
    try {
        UserApi::callRestApi("DELETE", "groups/DEFAULT");
        assert_eq(True, False);
    } catch (hash<ExceptionInfo> ex) {
        assert_eq(403, ex.arg.typeCode() == NT_INT ? ex.arg : ex.arg.ex.arg);
    }

    # make sure SIMPLETEST is stopped
    UserApi::callRestApi("PUT", "workflows/SIMPLETEST/setAutostart", {"autostart": 0});

    # wait for process to stop if running
    {
        *hash<auto> proc_info = UserApi::callRestApi("GET", "workflows/SIMPLETEST/process");
        if (proc_info) {
            wait_for_process_not_pid(proc_info.id, proc_info.pid);
        }
    }

    try {
        UserApi::callRestApi("POST", "workflows/SIMPLETEST/kill");
        assert_eq(True, False);
    } catch (hash<ExceptionInfo> ex) {
        assert_eq(404, ex.arg.typeCode() == NT_INT ? ex.arg : ex.arg.ex.arg);
    }
}

sub issue_2682() {
    bool remote = UserApi::callRestApi("GET", "services/ClassTest/remote");
    hash<auto> ex;
    try {
        UserApi::callRestApi("PUT", "services/ClassTest/throwException/call");
    } catch (hash<ExceptionInfo> ex0) {
        ex = remote
            ? ex0.arg.ex
            : ex0;
    }

    assert_eq(Type::String, ex.source.type());
    assert_eq(Type::Int, ex.offset.type());
}

sub issue_2677() {
    UserApi::callRestApi("PUT", "services/issue-2677/config/deadlock", {"value": True});
    on_exit {
        UserApi::callRestApi("PUT", "services/issue-2677/config/deadlock", {"value": False});
        # unload on exit
        UserApi::callRestApi("PUT", "services/issue-2677/unload");
    }

    # ensure the service is loaded
    UserApi::callRestApi("PUT", "services/issue-2677/load");

    # get the process ID
    string proc_id = UserApi::callRestApi("GET", "services/issue-2677/processes")[0].id;

    # start the stop operation in the background
    UserApi::callRestApi("PUT", "services/issue-2677-helper/do_stop/call");
    # unload the issue-2677-helper when done
    on_exit {
        UserApi::callRestApi("PUT", "services/issue-2677-helper/unload");
    }

    wait_for_process_call(proc_id, "Counter::waitForZero");

    # kill the service
    system("qctl kill " + proc_id);

    # wait for service status to be set to unloaded
    wait_for_service_status("issue-2677", "unloaded");

    assert_eq("unloaded", UserApi::callRestApi("GET", "services/issue-2677/status"));

    # now try again with a reset
    # ensure the service is loaded
    UserApi::callRestApi("PUT", "services/issue-2677/load");

    # start the stop operation in the background
    UserApi::callRestApi("PUT", "services/issue-2677-helper/do_reset/call");

    wait_for_process_call(proc_id, "Counter::waitForZero");

    # kill the service
    system("qctl kill " + proc_id);

    # wait for service to load again
    wait_for_service_status("issue-2677", "running");
}

sub issue_2669() {
    # test workflows without killing; killing tests are performed in issue #2669
    # get workflow config
    hash<auto> wfh = UserApi::callRestApi("GET", "workflows/SIMPLETEST");

    {
        # make sure SIMPLETEST has remote = True and autostart = 1
        if (wfh.autostart != 1) {
            UserApi::callRestApi("PUT", "workflows/SIMPLETEST/setAutostart", {"autostart": 1});
        }
        on_exit {
            UserApi::callRestApi("PUT", "workflows/SIMPLETEST/setAutostart", {"autostart": 0});
        }
        if (!wfh.remote) {
            UserApi::callRestApi("PUT", "workflows/SIMPLETEST/setRemote", {"remote": True});
        }
        # make sure SIMPLETEST runs without errors
        UserApi::callRestApi("PUT", "workflows/SIMPLETEST/setOptions", {"options": {"no-errors": True}});

        # reset the workflow
        UserApi::callRestApi("PUT", "workflows/SIMPLETEST/reset");

        softint wfiid = UserApi::callRestApi("POST", "workflows/SIMPLETEST/createOrder",
            {"staticdata": {}}).workflow_instanceid;
        UserApi::logInfo("created SIMPLETEST wfiid %d", wfiid);

        wait_for_status("2669-reset-test-1", wfiid, StatComplete, StatError);

        int stepid = UserApi::callRestApi("GET", "steps/test_function_1/stepid");
        assert_eq(NOTHING, parse_yaml(UserApi::callRestApi("GET", "orders/" + wfiid + "/yamlStepData",
            {"stepid": stepid, "ind": 0})));
    }

    # now perform the same test with autostart = 0
    UserApi::callRestApi("PUT", "workflows/SIMPLETEST/start");
    on_exit {
        UserApi::callRestApi("PUT", "workflows/SIMPLETEST/stop");
    }

    # reset the workflow
    UserApi::callRestApi("PUT", "workflows/SIMPLETEST/reset");

    softint wfiid = UserApi::callRestApi("POST", "workflows/SIMPLETEST/createOrder",
        {"staticdata": {}}).workflow_instanceid;
    UserApi::logInfo("created SIMPLETEST wfiid %d", wfiid);

    # make sure wf is running
    if (!UserApi::callRestApi("GET", "workflows/SIMPLETEST/exec_count")) {
        UserApi::callRestApi("PUT", "workflows/SIMPLETEST/start");
    }

    wait_for_status("2669-reset-test-2", wfiid, StatComplete, StatError);
}

sub issue_2662() {
    # first make sure the error definition is correct; correct it if necessary
    hash<auto> h = UserApi::callRestApi("GET", "errors/global/BUSINESS-ERROR");
    if (h.status != OMQ::StatError) {
        UserApi::callRestApi("PUT", "errors/global/BUSINESS-ERROR", {"status": OMQ::StatError});
    }

    # make sure that updating to an invalid status results in an exception
    assert_throws("ERROR-UPDATE-ERROR", \UserApi::callRestApi(), ("PUT", "errors/global/BUSINESS-ERROR", {"status": "x"}));
    # make sure that adding a retry delay to an error with an ERROR status results in an exception
    assert_throws("ERROR-UPDATE-ERROR", \UserApi::callRestApi(), ("PUT", "errors/global/BUSINESS-ERROR", {"retry_delay_secs": 1}));
}

sub issue_2649() {
    # get SIMPLETEST info
    hash<auto> wfh = UserApi::callRestApi("GET", "workflows/SIMPLETEST");

    string name = get_random_string();
    hash<auto> h = {
        "error": name,
        "business_flag": True,
        "description": get_random_string(),
        "retry_delay_secs": 100,
        "severity": OMQ::ES_Major,
        "status": OMQ::StatRetry,
    };

    hash<auto> result_hash = h + {
        "manually_updated": False,
        "type": "workflow",
        "workflowname": wfh.name,
        "workflowversion": wfh.version,
        "workflowid": wfh.workflowid,
    };

    {
        string result = UserApi::callRestApi("POST", "errors/workflow/SIMPLETEST", h);
        assert_eq("CREATED-WORKFLOW", result);
        on_exit {
            result = UserApi::callRestApi("DELETE", "errors/workflow/SIMPLETEST/" + name);
            assert_eq("OK", result);
        }
        hash<auto> eh = UserApi::callRestApi("GET", "errors/workflow/SIMPLETEST/" + name);
        assert_eq(result_hash, eh);
        eh = UserApi::callRestApi("GET", "errors/" + name);
        assert_eq(result_hash, eh);
    }

    {
        string result = UserApi::callRestApi("POST", "errors/workflow/SIMPLETEST/createOrUpdate", h);
        assert_eq("CREATED-WORKFLOW", result);
        on_exit {
            result = UserApi::callRestApi("DELETE", "errors/workflow/SIMPLETEST/" + name);
            assert_eq("OK", result);
        }
        hash<auto> eh = UserApi::callRestApi("GET", "errors/workflow/SIMPLETEST/" + name);
        assert_eq(result_hash, eh);
        eh = UserApi::callRestApi("GET", "errors/" + name);
        assert_eq(result_hash, eh);
    }

    {
        string result = UserApi::callRestApi("POST", "workflows/SIMPLETEST/errors", h);
        assert_eq("CREATED-WORKFLOW", result);
        on_exit {
            result = UserApi::callRestApi("DELETE", "workflows/SIMPLETEST/errors/" + name);
            assert_eq("OK", result);
        }
        hash<auto> eh = UserApi::callRestApi("GET", "workflows/SIMPLETEST/errors/" + name);
        assert_eq(result_hash, eh);
        eh = UserApi::callRestApi("GET", "errors/" + name);
        assert_eq(result_hash, eh);
    }

    {
        string result = UserApi::callRestApi("POST", "workflows/SIMPLETEST/errors/createOrUpdate", h);
        assert_eq("CREATED-WORKFLOW", result);
        on_exit {
            result = UserApi::callRestApi("DELETE", "workflows/SIMPLETEST/errors/" + name);
            assert_eq("OK", result);
        }
        hash<auto> eh = UserApi::callRestApi("GET", "workflows/SIMPLETEST/errors/" + name);
        assert_eq(result_hash, eh);
        eh = UserApi::callRestApi("GET", "errors/" + name);
        assert_eq(result_hash, eh);
    }
}

sub issue_2647(hash<auto> simpletest_config) {
    # only run this test with debug builds of Qorus
    if (!UserApi::isInternalSystemDebuggingEnabled()) {
        UserApi::logInfo("cannot run workflow crash test with non-debugging builds of Qorus; skipping test for issue #2647");
        return;
    }

    # get workflow config
    hash<auto> wfh = UserApi::callRestApi("GET", "workflows/SIMPLETEST");

    {
        # make sure SIMPLETEST has remote = True and autostart = 1
        UserApi::callRestApi("PUT", "workflows/SIMPLETEST/setAutostart", {"autostart": 1});
        on_exit {
            UserApi::callRestApi("PUT", "workflows/SIMPLETEST/setAutostart", {"autostart": 0});
        }

        # create a 0-length signal file telling the qwf process to terminate in the stopAndDeleteWorkflowQueue call
        string signal_file = sprintf("%s/%s-%s-%s-%s-stopAndDeleteWorkflowQueue", tmp_location(),
            UserApi::getSystemInfo()."instance-key", simpletest_config.name, simpletest_config.version,
            simpletest_config.workflowid);
        {
            File f();
            f.open2(signal_file, O_CREAT | O_WRONLY | O_TRUNC);
        }
        # the signal file will be unlinked by the qwf process if the test works properly
        on_error unlink(signal_file);
        UserApi::logInfo("issue #2647 reset test 1: created signal file %y", signal_file);
        # reset the workflow
        UserApi::callRestApi("PUT", "workflows/SIMPLETEST/reset");

        softint wfiid = UserApi::callRestApi("POST", "workflows/SIMPLETEST/createOrder",
            {"staticdata": {}}).workflow_instanceid;
        UserApi::logInfo("created SIMPLETEST wfiid %d", wfiid);

        wait_for_status("2647-reset-test-1", wfiid, StatComplete, StatError);

        # now try it with an abort when the process restarts
        # create a 0-length signal file telling the qwf process to terminate in the setupComplete call
        signal_file = sprintf("%s/%s-%s-%s-%s-setupComplete", tmp_location(), UserApi::getSystemInfo()."instance-key",
            simpletest_config.name, simpletest_config.version, simpletest_config.workflowid);
        {
            File f();
            f.open2(signal_file, O_CREAT | O_WRONLY | O_TRUNC);
        }
        # the signal file will be unlinked by the qwf process if the test works properly
        on_error unlink(signal_file);
        UserApi::logInfo("issue #2647 reset test 2: created signal file %y", signal_file);

        # reset the workflow
        UserApi::callRestApi("PUT", "workflows/SIMPLETEST/reset");

        wfiid = UserApi::callRestApi("POST", "workflows/SIMPLETEST/createOrder",
            {"staticdata": {}}).workflow_instanceid;
        UserApi::logInfo("created SIMPLETEST wfiid %d", wfiid);

        wait_for_status("2647-reset-test-2", wfiid, StatComplete, StatError);

        # issue #2647: do stop test
        # create a 0-length signal file telling the qwf process to terminate in the stopAndDeleteWorkflowQueue call
        signal_file = sprintf("%s/%s-%s-%s-%s-stopAndDeleteWorkflowQueue", tmp_location(),
            UserApi::getSystemInfo()."instance-key", simpletest_config.name, simpletest_config.version,
            simpletest_config.workflowid);
        {
            File f();
            f.open2(signal_file, O_CREAT | O_WRONLY | O_TRUNC);
        }
        # the signal file will be unlinked by the qwf process if the test works properly
        on_error unlink(signal_file);
        UserApi::logInfo("issue #2647 stop test 1: created signal file %y", signal_file);
    }

    # when a workflow has autostart = 0 and dies after restarting, it will not be started again
    # so we wait for it to stop, and then start it to process the order we submitted above
    wait_for_workflow_stop(simpletest_config.workflowid, 20s);

    # now perform the same test with autostart = 0
    UserApi::callRestApi("PUT", "workflows/SIMPLETEST/start");
    on_exit {
        UserApi::callRestApi("PUT", "workflows/SIMPLETEST/stop");
    }

    {
        # create a 0-length signal file telling the qwf process to terminate in the stopAndDeleteWorkflowQueue call
        string signal_file = sprintf("%s/%s-%s-%s-%s-stopAndDeleteWorkflowQueue", tmp_location(),
            UserApi::getSystemInfo()."instance-key", simpletest_config.name, simpletest_config.version,
            simpletest_config.workflowid);
        {
            File f();
            f.open2(signal_file, O_CREAT | O_WRONLY | O_TRUNC);
        }
        # the signal file will be unlinked by the qwf process if the test works properly
        on_error unlink(signal_file);
        UserApi::logInfo("issue #2647 reset test 3: created signal file %y", signal_file);
        # reset the workflow
        UserApi::callRestApi("PUT", "workflows/SIMPLETEST/reset");

        softint wfiid = UserApi::callRestApi("POST", "workflows/SIMPLETEST/createOrder",
            {"staticdata": {}}).workflow_instanceid;
        UserApi::logInfo("created SIMPLETEST wfiid %d", wfiid);

        # make sure wf is running
        if (!UserApi::callRestApi("GET", "workflows/SIMPLETEST/exec_count")) {
            UserApi::callRestApi("PUT", "workflows/SIMPLETEST/start");
        }

        wait_for_status("2647-reset-test-3", wfiid, StatComplete, StatError);

        # now try it with an abort when the process restarts
        # create a 0-length signal file telling the qwf process to terminate in the setupComplete call
        signal_file = sprintf("%s/%s-%s-%s-%s-setupComplete", tmp_location(), UserApi::getSystemInfo()."instance-key",
            simpletest_config.name, simpletest_config.version, simpletest_config.workflowid);
        {
            File f();
            f.open2(signal_file, O_CREAT | O_WRONLY | O_TRUNC);
        }
        # the signal file will be unlinked by the qwf process if the test works properly
        on_error unlink(signal_file);
        UserApi::logInfo("issue #2647 reset test 4: created signal file %y", signal_file);

        # reset the workflow
        UserApi::callRestApi("PUT", "workflows/SIMPLETEST/reset");

        wfiid = UserApi::callRestApi("POST", "workflows/SIMPLETEST/createOrder",
            {"staticdata": {}}).workflow_instanceid;
        UserApi::logInfo("created SIMPLETEST wfiid %d", wfiid);

        # when a workflow has autostart = 0 and dies after restarting, it will not be started again
        # so we wait for it to stop, and then start it to process the order we submitted above
        wait_for_workflow_stop(simpletest_config.workflowid, 20s);

        # start the workflow; it will be stopped when this block exits
        UserApi::callRestApi("PUT", "workflows/SIMPLETEST/start");

        wait_for_status("2647-reset-test-4", wfiid, StatComplete, StatError);
    }
}

sub issue_2646() {
    assert_eq("string", UserApi::callRestApi("GET", "services/DevModulesTest/config/global-string-test/type"));
    assert_eq("string", UserApi::callRestApi("GET", "jobs/DevModulesTest/config/global-string-test/type"));
}

sub issue_2603() {
    # only run this test with debug builds of Qorus
    if (!UserApi::isInternalSystemDebuggingEnabled()) {
        UserApi::logInfo("cannot run workflow crash test with non-debugging builds of Qorus; skipping test for issue #2603");
        return;
    }

    # make sure the http-test service will run remotely & is not running now
    UserApi::callRestApi("PUT", "services/http-test/setRemote", {"remote": True});
    UserApi::callRestApi("PUT", "services/http-test/setAutostart", {"autostart": False});
    UserApi::callRestApi("PUT", "services/http-test/unload");

    # get service config
    hash<auto> svch = UserApi::callRestApi("GET", "services/http-test");

    # create a 0-length signal file telling the qsvc process to terminate in the stopIntern() call
    string signal_file = sprintf("%s/%s-%s-%s-%s-%s-init", tmp_location(), UserApi::getSystemInfo()."instance-key",
        svch.type, svch.name, svch.version, svch.serviceid);
    {
        File f();
        f.open2(signal_file, O_CREAT | O_WRONLY | O_TRUNC);
    }
    # the signal file will be unlinked by the qsvc process if the test works properly
    on_error unlink(signal_file);
    UserApi::logInfo("issue #2603 manual test: created signal file %y", signal_file);

    # load and unload the service
    try {
        UserApi::callRestApi("PUT", "services/http-test/load");
        assert_eq(True, False);
    } catch (hash<ExceptionInfo> ex) {
        if (ex.err != "PROCESS-START-ERROR" && ex.err != "CLIENT-DEAD" && ex.err != "CLIENT-TERMINATED"
            && ex.err != "CLIENT-ABORTED" && ex.err != "SERVICE-INIT-ERROR") {
            UserApi::logInfo("ERROR: %s", get_exception_string(ex));
        }
        assert_eq(True, (ex.err == "PROCESS-START-ERROR" || ex.err == "CLIENT-DEAD" || ex.err == "CLIENT-TERMINATED"
            || ex.err == "CLIENT-ABORTED" || ex.err == "SERVICE-INIT-ERROR"));
    }

    assert_eq("unloaded", UserApi::callRestApi("GET", "services/http-test/status"));

    # now test what happens when the qsvc process dies before signaling it's queue
    signal_file = sprintf("%s/%s-%s-%s-%s-%s-constructor-1", tmp_location(), UserApi::getSystemInfo()."instance-key",
        svch.type, svch.name, svch.version, svch.serviceid);
    {
        File f();
        f.open2(signal_file, O_CREAT | O_WRONLY | O_TRUNC);
    }

    # load and unload the service
    try {
        UserApi::callRestApi("PUT", "services/http-test/load");
        assert_eq(True, False);
    } catch (hash<ExceptionInfo> ex) {
        if (ex.err != "PROCESS-START-ERROR" && ex.err != "CLIENT-DEAD" && ex.err != "CLIENT-TERMINATED"
            && ex.err != "CLIENT-ABORTED" && ex.err != "SERVICE-INIT-ERROR") {
            UserApi::logInfo("ERROR: %s", get_exception_string(ex));
        }
        assert_eq(True, (ex.err == "PROCESS-START-ERROR" || ex.err == "CLIENT-DEAD" || ex.err == "CLIENT-TERMINATED"
            || ex.err == "CLIENT-ABORTED" || ex.err == "SERVICE-INIT-ERROR"));
    }

    assert_eq("unloaded", UserApi::callRestApi("GET", "services/http-test/status"));

    # now test what happens when the qsvc process dies after signaling it's queue
    signal_file = sprintf("%s/%s-%s-%s-%s-%s-constructor-2", tmp_location(), UserApi::getSystemInfo()."instance-key",
        svch.type, svch.name, svch.version, svch.serviceid);
    {
        File f();
        f.open2(signal_file, O_CREAT | O_WRONLY | O_TRUNC);
    }

    # load and unload the service
    try {
        # issue #2603: depending on when qorus-master sees that the process is dead, it may or may not throw a
        # PROCESS-START-ERROR here
        UserApi::callRestApi("PUT", "services/http-test/load");
        UserApi::callRestApi("PUT", "services/http-test/unload");
    } catch (hash<ExceptionInfo> ex) {
        if (ex.err != "PROCESS-START-ERROR") {
            UserApi::logInfo("%s", get_exception_string(ex));
        }
        assert_eq("PROCESS-START-ERROR", ex.err);
    }
    assert_eq("unloaded", UserApi::callRestApi("GET", "services/http-test/status"));
}

sub issue_3054() {
    # ensure queuename is always present in the stepmap
    assert_eq("user-interaction-test-1", UserApi::callRestApi("GET", "steps/user-interaction-test-1/queuename"));
}

sub issue_2618(hash<auto> simpletest_config) {
    # only run this test with debug builds of Qorus
    if (!UserApi::isInternalSystemDebuggingEnabled()) {
        UserApi::logInfo("cannot run workflow crash test with non-debugging builds of Qorus; skipping test for issue #2618");
        return;
    }

    # create a 0-length signal file telling the qwf process to terminate in the setupComplete call
    string signal_file = sprintf("%s/%s-%s-%s-%s-setupComplete", tmp_location(), UserApi::getSystemInfo()."instance-key",
        simpletest_config.name, simpletest_config.version, simpletest_config.workflowid);
    {
        File f();
        f.open2(signal_file, O_CREAT | O_WRONLY | O_TRUNC);
    }
    # the signal file will be unlinked by the qwf process if the test works properly
    on_error unlink(signal_file);
    UserApi::logInfo("issue #2618 manual test: created signal file %y", signal_file);

    # start workflow; test for exception
    assert_throws("WORKFLOW-REMOTE-START-ERROR", \UserApi::callRestApi(), ("PUT", "workflows/SIMPLETEST/start"));
}

sub issue_1705() {
    list<auto> l = (1, "two", 3);
    auto val = UserApi::callRestApi("PUT", "services/ClassTest/echo/call", {"args": (l,),});
    assert_eq(l, val);

    assert_throws("REST-ERROR", \UserApi::callRestApi(), ("PUT", "services/ClassTest/error/call"));
}

sub issue_2365() {
    assert_throws("SERVICE-SETREMOTE-ERROR", \UserApi::callRestApi(), ("PUT", "/services/sqlutil/setRemote", {"remote": True}));
}

sub issue_2586() {
    # find a loopback remote connection
    *string remote = get_loopback();
    if (!remote) {
        UserApi::logInfo("no loopback connections for ping tests; skipping");
        return;
    }
    UserApi::logInfo("using remote loopback connection %y", remote);

    hash<auto> h = UserApi::callRestApi("PUT", "remote/qorus/" + remote + "/ping");
    assert_eq(Type::String, h.result.type());
}

sub issue_2558() {
    # only run this test with debug builds of Qorus
    if (!UserApi::isInternalSystemDebuggingEnabled()) {
        UserApi::logInfo("cannot run service crash test with non-debugging builds of Qorus; skipping test for issue #2558");
        return;
    }

    # make sure the http-test service will run remotely & is not running now
    UserApi::callRestApi("PUT", "services/http-test/setRemote", {"remote": True});
    UserApi::callRestApi("PUT", "services/http-test/setAutostart", {"autostart": False});
    UserApi::callRestApi("PUT", "services/http-test/unload");

    # get service config
    hash<auto> svch = UserApi::callRestApi("GET", "services/http-test");

    # create a 0-length signal file telling the qsvc process to terminate in the doRemoteSetup() call
    string signal_file = sprintf("%s/%s-%s-%s-%s-%s-doRemoteSetup", tmp_location(), UserApi::getSystemInfo()."instance-key",
        svch.type, svch.name, svch.version, svch.serviceid);
    {
        File f();
        f.open2(signal_file, O_CREAT | O_WRONLY | O_TRUNC);
    }
    # the signal file will be unlinked by the qsvc process if the test works properly
    on_error unlink(signal_file);
    UserApi::logInfo("issue #2558 manual test: created signal file %y", signal_file);

    # load and unload the service
    assert_throws("PROCESS-START-ERROR", \UserApi::callRestApi(), ("PUT", "services/http-test/load"));

    assert_eq("unloaded", UserApi::callRestApi("GET", "services/http-test/status"));
}

sub issue_2318() {
    # only run this test with debug builds of Qorus
    if (!UserApi::isInternalSystemDebuggingEnabled()) {
        UserApi::logInfo("cannot run service crash test with non-debugging builds of Qorus; skipping test for issue #2318");
        return;
    }

    # make sure the http-test service will run remotely & is not running now
    UserApi::callRestApi("PUT", "services/http-test/setRemote", {"remote": True});
    UserApi::callRestApi("PUT", "services/http-test/setAutostart", {"autostart": False});
    UserApi::callRestApi("PUT", "services/http-test/unload");

    # get service config
    hash<auto> svch = UserApi::callRestApi("GET", "services/http-test");

    # create a 0-length signal file telling the qsvc process to terminate in the stopIntern() call
    string signal_file = sprintf("%s/%s-%s-%s-%s-%s-stopIntern", tmp_location(),
        UserApi::getSystemInfo()."instance-key", svch.type, svch.name, svch.version, svch.serviceid);
    {
        File f();
        f.open2(signal_file, O_CREAT | O_WRONLY | O_TRUNC);
    }
    # the signal file will be unlinked by the qsvc process if the test works properly
    on_error unlink(signal_file);
    UserApi::logInfo("issue #2318 manual test: created signal file %y", signal_file);

    # load and unload the service
    UserApi::callRestApi("PUT", "services/http-test/load");
    UserApi::callRestApi("PUT", "services/http-test/unload");

    assert_eq("unloaded", UserApi::callRestApi("GET", "services/http-test/status"));
}

sub issue_2425() {
    # get workflow config
    hash<auto> wfh = UserApi::callRestApi("GET", "workflows/SIMPLETEST");
    # make sure that we can change a workflow's remote status while it's running locally and then reset it
    if (wfh.remote) {
        UserApi::callRestApi("PUT", "workflows/SIMPLETEST/setRemote", {"remote": False});
    }
    on_exit {
        if (wfh.remote) {
            UserApi::callRestApi("PUT", "workflows/SIMPLETEST/setRemote", {"remote": True});
        }
    }

    # make sure it's running (locally)
    UserApi::callRestApi("PUT", "workflows/SIMPLETEST/setAutostart", {"autostart": 1});
    UserApi::logInfo("updated SIMPLETEST with autostart = 1");
    on_exit {
        UserApi::callRestApi("PUT", "workflows/SIMPLETEST/setAutostart", {"autostart": 0});
    }

    # update the remote value to 1 in the DB
    # get omq datasource for test
    {
        Datasource ds(UserApi::callRestApi("GET", "system/options/systemdb/value"));

        on_error ds.rollback();
        on_success ds.commit();

        ds.exec("update workflows set remote = 1 where workflowid = %v", wfh.workflowid.toInt());
    }
    UserApi::logInfo("updated DB with with remote = 1");

    # reset metadata
    UserApi::callRestApi("PUT", "system/metadata/reload", {"workflows": (wfh.workflowid,)});
    UserApi::logInfo("reset metadata; waiting for process");

    # ensure that the process is running
    hash<auto> wfh0;
    while (True) {
        wfh0 = UserApi::callRestApi("GET", "workflows/SIMPLETEST");
        if (wfh0.process) {
            break;
        }
        UserApi::usleep(250ms);
    }

    assert_eq(True, wfh0.remote);
}

sub issue_2295_1(hash<auto> simpletest_config) {
    # only run this test with debug builds of Qorus
    if (!UserApi::isInternalSystemDebuggingEnabled()) {
        UserApi::logInfo("cannot run workflow crash test with non-debugging builds of Qorus; skipping test for issue #2295");
        return;
    }

    # create a 0-length signal file telling the qwf process to terminate in the inlineInit call
    string signal_file = sprintf("%s/%s-%s-%s-%s-inlineInit", tmp_location(), UserApi::getSystemInfo()."instance-key",
        simpletest_config.name, simpletest_config.version, simpletest_config.workflowid);
    {
        File f();
        f.open2(signal_file, O_CREAT | O_WRONLY | O_TRUNC);
    }
    # the signal file will be unlinked by the qwf process if the test works properly
    on_error unlink(signal_file);
    UserApi::logInfo("issue #2295 manual test: created signal file %y", signal_file);

    # start workflow; test for exception
    assert_throws("WORKFLOW-REMOTE-START-ERROR", \UserApi::callRestApi(), ("PUT", "workflows/SIMPLETEST/start"));
}

sub issue_2295_2(hash<auto> simpletest_config) {
    # only run this test with debug builds of Qorus
    if (!UserApi::isInternalSystemDebuggingEnabled()) {
        UserApi::logInfo("cannot run workflow crash test with non-debugging builds of Qorus; skipping test for issue #2295");
        return;
    }

    # create a 0-length signal file telling the qwf process to terminate in the inlineInit call
    string signal_file = sprintf("%s/%s-%s-%s-%s-inlineInit", tmp_location(), UserApi::getSystemInfo()."instance-key",
        simpletest_config.name, simpletest_config.version, simpletest_config.workflowid);
    # the signal file will be unlinked by the qwf process if the test works properly
    on_error unlink(signal_file);
    UserApi::logInfo("issue #2295 autostart test: created signal file %y", signal_file);

    # make sure SIMPLETEST has autostart = 1
    UserApi::callRestApi("PUT", "workflows/SIMPLETEST/setAutostart", {"autostart": 1});
    on_exit UserApi::callRestApi("PUT", "workflows/SIMPLETEST/setAutostart", {"autostart": 0});

    # wait until SIMPLETEST is running normally
    # issue #2642: make sure no errors happen when executing SIMPLETEST
    UserApi::callRestApi("PUT", "workflows/SIMPLETEST/setOptions", {"options": {"no-errors": True}});
    softint wfiid = UserApi::callRestApi("POST", "workflows/SIMPLETEST/createOrder", {"staticdata": {}}).workflow_instanceid;
    UserApi::logInfo("created SIMPLETEST wfiid %d", wfiid);
    wait_for_status("2295-autostart-test", wfiid);
}

sub issue_2349() {
    if (!UserApi::callRestApi("GET", "services/rest-test/remote")) {
        UserApi::logInfo("SKIPPING ISSUE 2349 tests - set rest-test remote = true: qrest put "
            "services/rest-test/setRemote remote=1");
        return;
    }
    UserApi::callRestApi("PUT", "services/rest-test/load");

    # have the rest-test service kill itself in the next "wait" call
    omqservice.user."rest-test".kill_on_wait();

    DataStreamClient rest({
        "url": UserApi::qorusGetLocalUrl(),
    });

    hash<auto> info;
    assert_throws("DESERIALIZATION-ERROR", \rest.put(), ("/rest-test/wait", NOTHING, \info));
    #UserApi::logDebug("info: %N", info);
    assert_eq(500, info."response-headers".status_code);
    assert_eq("Internal Server Error", info."response-headers".status_message);
}

sub issue_2312() {
    if (!UserApi::callRestApi("GET", "services/rest-test/remote")) {
        UserApi::logInfo("SKIPPING ISSUE 2312 tests - set rest-test remote = true: qrest put "
            "services/rest-test/setRemote remote=1");
        return;
    }
    UserApi::callRestApi("PUT", "services/rest-test/load");

    # wait for resources
    wait_for_resources("rest-test");

    DataStreamClient rest({
        "url": UserApi::qorusGetLocalUrl(),
    });
    hash<auto> h = rest.get("/rest-test");
    assert_eq(("test", "wait"), h.body);
    assert_throws("DATASTREAM-CLIENT-RECEIVE-ERROR", \rest.del(), "/rest-test");
    h = rest.get("/rest-test/test", {"a": "arg"});
    assert_eq({"method": "GET", "info": "OK", "args": {"a": "arg"}}, h.body);
    h = rest.put("/rest-test/test", {"a": "arg"});
    assert_eq({"method": "PUT", "info": "OK", "args": {"a": "arg"}}, h.body);
    h = rest.post("/rest-test/test", {"a": "arg"});
    assert_eq({"method": "POST", "info": "OK", "args": {"a": "arg"}}, h.body);
    h = rest.del("/rest-test/test", {"a": "arg"});
    assert_eq({"method": "DELETE", "info": "OK", "args": {"a": "arg"}}, h.body);

    # test issue #3216
    {
        hash<auto> h = rest.get("/rest-test/test/issue3216").body;
        assert_eq({"test": True}, h);
        if (h.fullType() != "hash<auto>") {
            UserApi::logInfo("h: %y", h.fullType());
        }
        assert_eq("hash<auto>", h.fullType());
    }

    # test streams
    list<auto> rl;
    code recv = sub (auto d) {
        rl += d;
    };
    *string errstr;
    code ecb = sub (*string err) {
        errstr = err;
    };
    hash<auto> info;
    # recv tests
    rest.recvDataStream(recv, ecb, "GET", "/rest-test/test?action=stream;stream=test", NOTHING, 20s, \info);
    assert_eq(("\"test", "-string\""), rl);
    remove rl;
    rest.recvDataStream(recv, ecb, "GET", "/rest-test/test?action=stream;stream=echo", (1, 2, 3), 20s, \info);
    assert_eq((1, 2, 3), rl);
    # send tests

    int cnt = 0;
    list<auto> l = ("one", 2.0, 3n);
    code send = auto sub () {
        return l[cnt++];
    };
    h = rest.sendDataStream(send, "POST", "/rest-test/test?action=stream;stream=echo", 20s, \info);
    assert_eq(200, h.status_code);
    assert_eq(l, h.body);

    remove rl;
    cnt = 0;
    rest.sendRecvDataStream(send, recv, ecb, "PUT", "/rest-test/test?action=stream;stream=echo", 20s, \info);
    assert_eq(l, rl);
}

sub issue_2308() {
    # get current SLA value
    int sla = UserApi::callRestApi("GET", "workflows/REGRESSION-TEST/sla_threshold");
    # restore it on exit
    on_exit UserApi::callRestApi("PUT", "workflows/REGRESSION-TEST/setSla?sla=" + sla);

    # make sure we change the SLA for the test
    int new_sla = 90;
    if (sla == new_sla) {
        new_sla -= 10;
    }
    # temporarily set new SLA value to 90 seconds
    UserApi::callRestApi("PUT", "workflows/REGRESSION-TEST/setSla?sla=" + new_sla);
    assert_eq(new_sla, UserApi::callRestApi("GET", "workflows/REGRESSION-TEST/sla_threshold"));
}

sub issue_2294() {
    hash<auto> h = UserApi::callRestApi("POST", "workflows/RETRY-TEST/execSynchronous", {"staticdata": {"a": 0}});
    assert_eq(OMQ::StatComplete, h.status);
    assert_eq(True, h.dynamicdata.retry);
}

sub issue_1700(QorusSystemRestHelper qrest) {
    list<auto> l;
    code recv = sub (auto d) {
        l += d;
    };
    *string errstr;
    code ecb = sub (*string err) {
        errstr = err;
    };
    hash<auto> info;
    qrest.recvDataStream(recv, ecb, "GET", "services/stream-test?action=stream;stream=recv", NOTHING, 20s, \info);
    #UserApi::logDebug("issue_1700(): recv l: %y", l);
    #UserApi::logDebug("issue_1700(): recv info: %y", info);
    assert_eq(NOTHING, errstr);
    assert_eq(200, info."response-headers".status_code);
    assert_eq(("string-1", "string-2", "string-3",), l);

    int cnt = 0;
    code send = auto sub () {
        return l[cnt++];
    };
    hash<auto> h = qrest.sendDataStream(send, "POST", "services/stream-test?action=stream;stream=send", 20s, \info);
    #UserApi::logDebug("issue_1700(): send h: %y", h);
    #UserApi::logDebug("issue_1700(): send info: %y", info);
    assert_eq(200, h.status_code);
    assert_eq(True, info.chunked);
}

sub issue_2247() {
    # skip RECOVERY-TEST if the workflow is not remote
    if (!UserApi::callRestApi("GET", "workflows/RECOVERY-TEST/remote")) {
        UserApi::logInfo("skipping issue 2247 for non-remote workflow");
        return;
    }

    # ensure RECOVERY-TEST is running
    UserApi::callRestApi("PUT", "/workflows/RECOVERY-TEST/setAutostart", {"autostart": 1});
    # stop the RECOVERY-TEST workflow on exit
    on_exit
        UserApi::callRestApi("PUT", "/workflows/RECOVERY-TEST/setAutostart", {"autostart": 0});

    # create a RECOVERY-TEST workflow order
    hash h = {"staticdata": {"a": 1}};
    softstring wfiid = UserApi::createOrder("RECOVERY-TEST", NOTHING, h);

    # get workflow ID
    softstring wfid = UserApi::callRestApi("GET", "workflows/RECOVERY-TEST/workflowid");

    # wait until the RECOVERY-TEST workflow order is in progress
    wait_for_status("issue 2247-1", wfiid, OMQ::StatInProgress, (OMQ::StatError, OMQ::StatComplete), "recovery_1");

    # kill the RECOVERY-TEST qwf process
    system(ENV.OMQ_DIR + "/bin/qctl kill qwf-RECOVERY-TEST-v1.0-" + wfid);

    # wait for the process to start again
    wait_for_status("issue 2247-2", wfiid, OMQ::StatRetry, OMQ::StatError);

    # retry the order
    UserApi::callRestApi("PUT", "orders/" + wfiid + "/retry");

    # issue #2903: verify the stepid type
    assert_eq(Type::Int, UserApi::callRestApi("GET", "orders/" + wfiid + "/StepInstances")[0].stepid.type());

    # wait for the qwf process to be restarted, the workflow to be recovered and process to COMPLETE
    wait_for_status("issue 2247-3", wfiid, OMQ::StatComplete, OMQ::StatError);
}

sub issue_2547() {
    if (PlatformOS == "Windows") {
        UserApi::logInfo("skipping test for issue #2547 as the server is running on Windows");
        return;
    }

    # make sure that WAIT-TEST will run remotely
    if (!UserApi::callRestApi("GET", "workflows/WAIT-TEST/remote")) {
        UserApi::callRestApi("PUT", "workflows/WAIT-TEST/setRemote", {"remote": True});
    }

    # get the process ID using the workflow ID
    string proc_id = sprintf("qwf-WAIT-TEST-v1.0-%d", UserApi::callRestApi("GET", "workflows/WAIT-TEST/workflowid"));

    # start executing WAIT-TEST in the background
    system("qrest post workflows/WAIT-TEST/execSynchronous staticdata='(a=a)'&");

    date now = now_us();
    # wait for workflow to run
    while (True) {
        hash<auto> h = UserApi::callRestApi("GET", "workflows/WAIT-TEST");
        if (!h.exec[0].log_url) {
            if ((now_us() - now) > 20s) {
                throw "ERROR", sprintf("test for issue #2547 failed as the WAIT-TEST workflow did not start in time");
            }
            UserApi::usleep(250ms);
            continue;
        }
        break;
    }

    now = now_us();
    # wait for workflow to sleep
    while (True) {
        string str = backquote("qctl threads " + proc_id);
        if (str =~ /sleep/) {
            UserApi::logInfo("killing process %y", proc_id);
            system("qctl kill " + proc_id);
            UserApi::logInfo("killed; waiting for wf exec instances to be cleared");
            break;
        }
        if ((now_us() - now) > 20s) {
            throw "ERROR", sprintf("test for issue #2547 failed as the WAIT-TEST workflow did not sleep in time");
        }
        #UserApi::logDebug("str: %s", str);
        UserApi::usleep(250ms);
    }

    # make sure execution instances have been removed
    wait_for_workflow_stop("WAIT-TEST");

    # execute again with zero seconds wait time
    hash<auto> h = UserApi::callRestApi("POST", "workflows/WAIT-TEST/execSynchronous", {"staticdata": {"wait": 0}});
    assert_eq(OMQ::StatComplete, h.status);
}

sub issue_2526() {
    # load issue-2526 service
    bool is_remote = UserApi::callRestApi("GET", "services/issue-2526").remote;
    on_exit {
        if (!is_remote) {
            UserApi::callRestApi("PUT", "services/issue-2526/setRemote?remote=0");
        }
    }
    # it must be remote for this test
    if (!is_remote) {
        UserApi::callRestApi("PUT", "services/issue-2526/setRemote?remote=1");
    }

    omqservice.user."issue-2526".init();
    on_exit UserApi::callRestApi("PUT", "services/issue-2526/unload");
    assert_throws("CLIENT-ABORTED", sub () {omqservice.user."issue-2526".die();});
}

sub issue_2466() {
    # start workflows
    UserApi::callRestApi("PUT", "workflows/REF-TEST/start");
    on_exit UserApi::callRestApi("PUT", "workflows/REF-TEST/stop");
    UserApi::callRestApi("PUT", "workflows/SWF-TEST/start");
    on_exit UserApi::callRestApi("PUT", "workflows/SWF-TEST/stop");

    hash<auto> oh = {
        "staticdata": {"a" : 1},
    };
    softint wfiid = UserApi::createOrder("REF-TEST", NOTHING, oh);
    UserApi::logInfo("created REF-TEST wfiid %d", wfiid);

    wait_for_status("issue-2466-1", wfiid, OMQ::StatComplete, OMQ::StatError);
}

sub issue_3050() {
    # make inactive
    UserApi::callRestApi("PUT", "jobs/test/setActive", {"active": False});
    # disable job test
    UserApi::callRestApi("PUT", "jobs/test/disable");
    on_exit UserApi::callRestApi("PUT", "jobs/test/enable");

    # reenable job
    hash<auto> h = UserApi::callRestApi("PUT", "jobs/test/setActive", {"active": True});
    assert_eq(False, h.active);
    assert_eq(True, h.db_active);
}

sub issue_3032_3033() {
    UserApi::callRestApi("PUT", "workflows/GDPR-WF-TEST?action=setAutostart", {"autostart": 1});
    on_exit {
        UserApi::callRestApi("PUT", "workflows/GDPR-WF-TEST?action=setAutostart", {"autostart": 1});
    }
    hash<auto> oh = {
        "staticdata": {
            "do-swf": True,
        },
        "sensitive_data": {
            "key1": {
                "val1": {
                    "data": {"a": 1},
                    "aliases": "alias0",
                },
            },
            "key2": {
                "val2": {
                    "data": {"b": 2},
                    "aliases": "alias1",
                },
            },
        },
    };
    softint wfiid = UserApi::createOrder("GDPR-WF-TEST", NOTHING, oh);
    UserApi::logDebug("created wfiid %d", wfiid);
    wait_for_status("bug-3032-3033", wfiid, OMQ::StatComplete, OMQ::StatError);
}

sub issue_2580() {
    hash<auto> search_hash = {
        "keyvalue": rand(),
    };
    # this call will throw an exception with PostgreSQL if the bug is not fixed
    omqservice.system.info.searchWorkflowInstances(search_hash);
    assert_eq(True, True);
}

sub issue_2534() {
    hash<auto> h = UserApi::callNetworkApi("omq.system.get-global-errors");
    assert_eq(Type::Hash, h.type());
    # this call will fail if the bug is not fixed
    h = UserApi::callNetworkApi("omq.system.get-global-errors");
    assert_eq(Type::Hash, h.type());
}

sub issue_2495() {
    # ensure that the workflow is stopped
    UserApi::callRestApi("PUT", "workflows/TEST-ISSUE-2495/stop");

    # test batch queueing: create a workflow order
    hash oh = {
        "staticdata": {"a" : 1},
    };
    {
        softint wfiid = UserApi::createOrder("TEST-ISSUE-2495", NOTHING, oh);
        UserApi::logInfo("created TEST-ISSUE-2495 wfiid %d", wfiid);

        # start TEST-ISSUE-2495
        UserApi::callRestApi("PUT", "workflows/TEST-ISSUE-2495/start");
        on_exit {
            UserApi::callRestApi("PUT", "workflows/TEST-ISSUE-2495/stop");
        }

        wait_for_status("issue-2495-1", wfiid, OMQ::StatComplete, OMQ::StatError);

        # test online queueing: create a workflow order while the workflow is running
        wfiid = UserApi::createOrder("TEST-ISSUE-2495", NOTHING, oh);
        UserApi::logInfo("created TEST-ISSUE-2495 wfiid %d", wfiid);
        wait_for_status("issue-2495-2", wfiid, OMQ::StatComplete, OMQ::StatError);
    }

    # test synchronous queueing
    oh.parent_workflow_instanceid = WorkflowApi::getWfiid();
    hash<auto> h = UserApi::callRestApi("POST", "workflows/TEST-ISSUE-2495/execSynchronous", oh);
    assert_eq(OMQ::StatComplete, h.status);
}

sub issue_2299() {
    # create a test key
    string str = get_random_string(10);

    # no duplicate error is thrown; duplicate keys are removed with WorkflowApi::appendOrderKeys()
    WorkflowApi::appendOrderKeys({"test-2299": (str, str)});

    WorkflowApi::setOrderKeys({"test-2299": str});
    assert_eq(str, WorkflowApi::getOrderKeys(){"test-2299"});

    assert_throws("DUPLICATE-KEY-VALUE", \WorkflowApi::setOrderKeys(), {"test-2299": (str, str)});
    assert_throws("INVALID-WORKFLOW-KEY", \WorkflowApi::setOrderKeys(), {"invalid-test": str});
    assert_throws("SET-ORDER-KEYS-ERROR", \WorkflowApi::setOrderKeys(), {"test-2299": {}});
    assert_throws("SET-ORDER-KEYS-ERROR", \WorkflowApi::appendOrderKeys(), {"test-2299": {}});

    # no duplicate error is thrown; duplicate keys are removed with WorkflowApi::appendOrderKeys()
    WorkflowApi::appendOrderKeys({"test-2299": str});

    assert_eq(str, WorkflowApi::getOrderKeys(){"test-2299"});
}

sub issue_2235() {
    # ensure that the issue-2235-test group is disabled
    string str = UserApi::callRestApi("PUT", "/groups/issue-2235-test/disable");
    assert_eq("OK", str);
    on_exit UserApi::callRestApi("PUT", "/groups/issue-2235-test/enable");

    # ensure that the issue-2235 service has autostart = true
    # ignore the GROUP-DISABLED error
    try {
        UserApi::callRestApi("PUT", "services/issue-2235/setAutostart?autostart=true");
    } catch (hash<ExceptionInfo> ex) {
        if (ex.err != "GROUP-DISABLED") {
            rethrow;
        }
    }
    on_exit {
        UserApi::callRestApi("PUT", "services/issue-2235/setAutostart?autostart=false");
    }

    # wait until the issue-2235 service is not loaded
    while (True) {
        str = UserApi::callRestApi("GET", "/services/issue-2235/status");
        if (str == "unloaded") {
            break;
        }
        UserApi::usleep(250ms);
    }
    assert_eq("unloaded", str);

    # remove the service from the group
    hash h = UserApi::callRestApi("PUT", "/groups/issue-2235-test/update?services=-issue-2235");
    assert_eq("-issue-2235", h.services);

    {
        on_exit {
            # add the service back to the group
            h = UserApi::callRestApi("PUT", "/groups/issue-2235-test/update?services=+issue-2235");
            assert_eq("+issue-2235", h.services);
        }

        # wait until the issue-2235 service is loaded
        wait_for_service_status("issue-2235", "loaded");
    }

    # wait until the issue-2235 service is not loaded again
    wait_for_service_status("issue-2235", "unloaded");
}

sub issue_2228() {
    hash h = UserApi::callRestApi("GET", "/orders?limit=1")[0];
    UserApi::logInfo("checking wfiid %d for %s", h.workflow_instanceid, h.name);
    hash wh = UserApi::callRestApi("GET", "/workflows/" + h.name + "/orders/" + h.workflow_instanceid);
    assert_eq(h.workflow_instanceid, wh.workflow_instanceid);
}

sub issue_2211(QorusSystemRestHelper qrest) {
    string dp = qrest.getDefaultPath();
    UserApi::logInfo("got default path: %y", dp);
    qrest.setDefaultPath("api/v3");
    on_exit qrest.setDefaultPath(dp);
    hash h = qrest.get("public/info");
    assert_eq(Type::String, h."instance-key".type());
}

sub issue_2187() {
    # load http-test service
    UserApi::callRestApi("PUT", "/services/http-test/load");
    hash<auto> h = UserApi::callRestApi("GET", "/services/http-test/resources");

    # get only listener resources with wildcard binds
    hash<auto> lh = map {$1.key: $1.value.info}, h.pairIterator(),
        $1.value.type == "HttpListener" && $1.value.info.bind =~ /:0$/;

    foreach hash<auto> rh in (lh.iterator()) {
        int port = (rh.url =~ x/:([0-9]+)$/)[0].toInt();
        assert_eq(True, port > 0, sprintf("issue-2187 resource %y url %y port %y", rh.name, rh.url, port));
        if (rh.ssl) {
            assert_eq("https", parse_url(rh.url).protocol, sprintf("issue-2187 HTTPS URL test: %s", rh.url));
        }
    }

    # test for issue #2643
    h = UserApi::callRestApi("GET", "system/userhttp/Test Header")[0];
    assert_eq({
        "title": "Test Title",
        "service": "http-test",
        "version": "1.0",
        "group": "Test Header",
    }, h - ("url", "serviceid"));
}

sub issue_2067() {
    hash<auto> oh = (
        "staticdata": ("a": "a"),
        "orderkeys": ("test1": ("a", "a")),
    );

    assert_throws("DUPLICATE-ORDER-KEY-ERROR", \UserApi::callRestApi(), ("POST", "/workflows/DUMMY-TEST/createOrder", oh));
}

sub issue_2152() {
    # save current properties
    hash<auto> props = UserApi::callRestApi("GET", "system/props");
    #UserApi::logDebug("props: %N", props);

    # generate random props
    hash<auto> rp = map {get_random_string(): get_random_string()}, xrange(4);
    assert_throws("PROP-ERROR", \UserApi::callRestApi(), ("PUT", "system/props/replaceAll", ("props": rp)));

    # correct argument structure for real call
    rp = map {get_random_string(): rp}, xrange(4);

    UserApi::callRestApi("PUT", "system/props/replaceAll", ("props": rp));
    on_exit
        UserApi::callRestApi("PUT", "system/props/replaceAll", ("props": props));

    hash<auto> tp = UserApi::callRestApi("GET", "system/props");
    assert_eq(rp, tp - "omq");
    assert_throws("SYSTEM-PROPERTY-ERROR", \UserApi::callRestApi(), ("PUT", "system/props/replaceAll", {}));
    assert_throws("PROP-ERROR", \UserApi::callRestApi(), ("PUT", "system/props/replaceAll", ("props": ("x": ("x": get_random_string(4001))))));
}

sub bug_2159() {
    assert_throws("MAP-ERROR", \UserApi::getMapper(), "invalid-test-mapper");
    # also tests issue #2301
    hash<auto> h = UserApi::callRestApi("GET", "/mappers/invalid-test-mapper");
    assert_eq("invalid-test-mapper", h.name);
}

sub bug_2108(QorusSystemRestHelper qrest) {
    hash<auto> wfh = WorkflowApi::getWorkflowMetadata();

    auto rv = omqservice.system.info.getOrderInfoFromKey(wfh.name, wfh.version, get_random_string(), get_random_string());
    test_value(rv, (), "issue-2108");
}

sub issue_1995() {
    {
        # create an SLA
        hash<auto> slah = (
            "name": get_random_string(),
            "units": "seconds",
            "description": "test",
        );
        hash<auto> h = UserApi::callRestApi("POST", "/slas", slah);
        on_exit
            UserApi::callRestApi("DELETE", "/slas/" + slah.name);
        UserApi::logInfo("created SLA %d %y", h.slaid, h.name);
        test_value(h.name, slah.name, "issue-1995-1");
        test_value(h.units, slah.units, "issue-1995-2");
        test_value(h.description, slah.description, "issue-1995-3");
        test_value(h.slaid.type(), Type::Int, "issue-1995-4");

        # ensure that a performance query with no events returns an empty list
        {
            list<auto> l = UserApi::callRestApi("GET", "/slas/" + slah.name + "/performance");
            assert_eq(1, l.size());
            assert_eq(NOTHING, l[0].mindate);
        }

        # test creation with the same arguments
        hash<auto> h2 = UserApi::callRestApi("POST", "/slas", slah);
        test_value(h2.name, slah.name, "issue-1995-5");
        test_value(h2.units, slah.units, "issue-1995-6");
        test_value(h2.description, slah.description, "issue-1995-7");
        test_value(h2.slaid, h.slaid, "issue-1995-8");

        UserApi::postSlaEventSuccess(h.name, 20.4);
        UserApi::postSlaEventSuccess(h.name, 24.8);
        UserApi::postSlaEventError(h.name, 1.1, "TEST-ERR", "desc");
        # verify that no events are present yet
        list<auto> l = UserApi::callRestApi("GET", "/slas/" + h.name + "/events");
        #UserApi::logDebug("l: %N", l);
        test_value(l.size(), 0, "issue-1995-search-1");
        UserApi::flushSlaEvents();
        # verify that events are present now
        l = UserApi::callRestApi("GET", "/slas/" + h.name + "/events");
        test_value(l.size(), 3, "issue-1995-search-2");
        l = UserApi::callRestApi("GET", "/slas/" + h.name + "/performance");
        #UserApi::logDebug("l: %N", l);
        test_value(l.size(), 1, "issue-1995-search-3");
        assert_eq(Type::Date, l[0].mindate.type());
        assert_eq(Type::Date, l[0].maxdate.type());
        assert_eq(Type::Number, l[0].minprocessing.type());
        assert_eq(Type::Number, l[0].avgprocessing.type());
        assert_eq(Type::Number, l[0].maxprocessing.type());
        assert_eq(Type::Number, l[0].successratio.type());

        # attach SLA to http-test.test
        h2 = UserApi::callRestApi("PUT", "/slas/" + h.name + "/setMethod", ("service": "http-test", "method": "test"));
        assert_eq(h.slaid, h2.slaid);
        assert_eq("http-test", h2.service);
        assert_eq("test", h2.method);

        # verify that the method has the SLA attached
        h2 = UserApi::callRestApi("GET", "/services/http-test");
        foreach hash<auto> mh in (h2.methods) {
            if (mh.name == "test") {
                h2 = mh;
                break;
            }
        }
        assert_eq(Type::Int, h2.service_methodid.type());
        assert_eq(h.name, h2.sla);

        # verify that the SLA reflects the method
        hash<auto> slah2 = UserApi::callRestApi("GET", "slas/" + h.name);
        assert_eq(1, slah2.methods.size());
        assert_eq("http-test", slah2.methods[0].service_name);
        assert_eq("test", slah2.methods[0].method_name);

        # call method with SLA attached
        h2 = omqservice.user."http-test".test();
        UserApi::flushSlaEvents();
        # verify that events are present now
        l = UserApi::callRestApi("GET", "/slas/" + h.name + "/events");
        #UserApi::logDebug("l: %N", l);
        test_value(l.size(), 4, "issue-1995-search-3");

        # attach the SLA to a job
        h2 = UserApi::callRestApi("PUT", "/slas/" + h.name + "/setJob", ("job": "test-shortrun"));
        assert_eq(h.slaid, h2.slaid);
        assert_eq("test-shortrun", h2.job);

        # verify that the job has the SLA attached
        h2 = UserApi::callRestApi("GET", "/jobs/test-shortrun");
        assert_eq(h.name, h2.sla);

        # verify that the SLA reflects the job
        slah2 = UserApi::callRestApi("GET", "slas/" + h.name);
        assert_eq(1, slah2.jobs.size());
        assert_eq("test-shortrun", slah2.jobs[0].name);

        # run the job with SLA attached
        h2 = UserApi::callNetworkApi("omq.system.job.run", "test-shortrun");
        UserApi::flushSlaEvents();
        # verify that events are present now
        l = UserApi::callRestApi("GET", "/slas/" + h.name + "/events");
        #UserApi::logDebug("l: %N", l);
        # FIXME: workaround for issue #2582
        assert_eq(True, l.size() >= 5);

        # remove the SLA from the job
        h2 = UserApi::callRestApi("PUT", "/slas/" + h.name + "/removeJob", ("job": "test-shortrun"));
        assert_eq(h.slaid, h2.slaid);
        assert_eq("test-shortrun", h2.job);
        assert_eq(True, h2.removed);

        # verify that the job does not have the SLA attached
        h2 = UserApi::callRestApi("GET", "/jobs/test-shortrun");
        assert_eq(Type::Int, h2.jobid.type());
        assert_eq(NOTHING, h2.sla);

        # verify that the SLA does not reflect the job
        slah2 = UserApi::callRestApi("GET", "slas/" + h.name);
        assert_eq(0, slah2.jobs.size());

        # remove the SLA from the service method
        h2 = UserApi::callRestApi("PUT", "/slas/" + h.name + "/removeMethod", ("service": "http-test", "method": "test"));
        assert_eq(h.slaid, h2.slaid);
        assert_eq("http-test", h2.service);
        assert_eq("test", h2.method);
        assert_eq(True, h2.removed);

        # verify that the method does not have the SLA attached
        h2 = UserApi::callRestApi("GET", "/services/http-test");
        foreach hash<auto> mh in (h2.methods) {
            if (mh.name == "test") {
                h2 = mh;
                break;
            }
        }
        assert_eq(Type::Int, h2.service_methodid.type());
        assert_eq(NOTHING, h2.sla);

        # verify that the SLA has already been removed
        h2 = UserApi::callRestApi("PUT", "/slas/" + h.name + "/removeMethod", ("service": "http-test", "method": "test"));
        assert_eq(h.slaid, h2.slaid);
        assert_eq("http-test", h2.service);
        assert_eq("test", h2.method);
        assert_eq(False, h2.removed);
    }

    {
        # verify that the method no longer has the SLA attached
        hash<auto> h = UserApi::callRestApi("GET", "/services/http-test");
        foreach hash<auto> mh in (h.methods) {
            if (mh.name == "test") {
                h = mh;
                break;
            }
        }
        assert_eq(Type::Int, h.service_methodid.type());
        assert_eq(NOTHING, h.sla);
    }

    {
        # create an SLA
        hash<auto> slah = (
            "name": get_random_string(),
            "units": "seconds",
            "description": "test",
        );

        # set system option "sla-max-sync-secs" to 1
        int secs = UserApi::getOption("sla-max-sync-secs");
        UserApi::callRestApi("PUT", "system/options/set", ("options": ("sla-max-sync-secs": 1)));
        on_exit
            UserApi::callRestApi("PUT", "system/options/set", ("options": ("sla-max-sync-secs": secs)));

        hash<auto> h = UserApi::callRestApi("POST", "/slas", slah);
        on_exit
            UserApi::callRestApi("DELETE", "/slas/" + slah.name);
        UserApi::logInfo("created SLA %d %y", h.slaid, h.name);
        test_value(h.name, slah.name, "issue-1995-2-1");
        test_value(h.units, slah.units, "issue-1995-2-2");
        test_value(h.description, slah.description, "issue-1995-2-3");

        UserApi::postSlaEventSuccess(h.name, 20.4);
        UserApi::postSlaEventSuccess(h.name, 24.8);
        # delete SLA without flushing first to disk
    }

    {
        # negative test creating an SLA with an invalid "units" value
        hash<auto> slah = (
            "name": get_random_string(),
            "units": "invalid",
            "description": "test",
        );
        try {
            UserApi::callRestApi("POST", "/slas", slah);
            assert_eq(False, True);
        } catch (hash<ExceptionInfo> ex) {
            assert_eq("SLA-ARG-ERROR", ex.err);
        }
    }
}

sub bug_1996(QorusSystemRestHelper qrest) {
    string name = sprintf("test_" + get_random_string(30));

    on_exit {
        qrest.del("remote/qorus/" + name);
        qrest.put("remote/qorus/reload");
    }

    # create new qconn file for oload
    hash<TmpFileHash> tmp_file = FsUtil::make_tmp_file("regression-", ".qconn");
    on_exit {
        unlink(tmp_file.path);
    }

    string f_content = sprintf("\n%s = (desc = test, url = qorus://localhost:9598, conn_timeout = 120, timeout = 15)\n",
                                name);
    tmp_file.file.write(f_content);
    tmp_file.file.close();

    int rv = system("oload -lR \"" + tmp_file.path + "\"");
    test_value(rv, 0, "bug-1996-1: Oload of remote connection");

    # get our new connection
    QorusSystemRestHelper nr = UserApi::getRemoteRestConnection(name, False, False);
    test_value(nr.getConnectTimeout(), 120000, "bug-1996-1");
    test_value(nr.getTimeout(), 15000, "bug-1996-2");
}

sub bug_1953(QorusSystemRestHelper qrest) {
    # start SKIP-TEST
    qrest.put("workflows/SKIP-TEST/start");
    on_exit {
        qrest.put("workflows/SKIP-TEST/stop");
        int n = qrest.get("workflows/SKIP-TEST/exec_count");
        test_value(n, 0, "bug-1953-done");
    }

    # make a hash of step info
    hash sh = map {$1.name: $1}, qrest.get("workflows/SKIP-TEST/stepinfo");

    # create a workflow order
    hash oh = (
        "staticdata": ("a" : 1),
    );
    softint wfiid = UserApi::createOrder("SKIP-TEST", NOTHING, oh);
    UserApi::logInfo("created SKIP-TEST wfiid %d", wfiid);

    # save workflow order for future processing
    WorkflowApi::updateInstanceData(("skip-test-wfiid": wfiid));

    # wait for order to get an error status
    wait_for_status("bug-1953-wait-1", wfiid, OMQ::StatError);

    # skip first step
    UserApi::callNetworkApi("omq.system.skip-step", wfiid, sh.skip_step.stepid);

    # wait for order to get an error status
    wait_for_status("bug-1953-wait-2", wfiid, OMQ::StatError);

    # get child wfiid
    softint child_wfiid = (map $1.workflow_instanceid, qrest.get("orders/" + wfiid + "/HierarchyInfo").iterator(), $1.name == "SKIP-TEST" && $1.workflow_instanceid != wfiid)[0];
    # cancel the child workflow
    UserApi::cancelOrder(child_wfiid);

    # skip second step
    try {
        UserApi::callNetworkApi("omq.system.skip-step", wfiid, sh.skip_step_subwf.stepid);
        test_value(True, False, "bug-1953-test");
    } catch (hash<ExceptionInfo> ex) {
        #UserApi::logDebug(get_exception_string(ex));
        test_value(ex.err, "SKIP-STEP-ERROR", "bug-1953-test");
    }
}

# test YAML-based workflow order data APIs
sub issue_2145() {
    softint wfiid = WorkflowApi::getInstanceData("skip-test-wfiid");

    # test static data APIs
    hash dh = (get_random_string(): rand());
    string yaml = make_yaml(dh, YAML::BlockStyle);
    auto rv = UserApi::callRestApi("PUT", "orders/" + wfiid + "/yamlStaticData", ("newdata": yaml));
    assert_eq("OK", rv);
    rv = UserApi::callRestApi("GET", "orders/" + wfiid + "/staticdata");
    assert_eq(dh, rv);
    rv = UserApi::callRestApi("GET", "orders/" + wfiid + "/yamlStaticData");
    assert_eq(yaml, rv);

    # test dynamic data APIs
    rv = UserApi::callRestApi("PUT", "orders/" + wfiid + "/yamlDynamicData", ("newdata": yaml));
    assert_eq("OK", rv);
    rv = UserApi::callRestApi("GET", "orders/" + wfiid + "/dynamicdata");
    assert_eq(dh, rv);
    rv = UserApi::callRestApi("GET", "orders/" + wfiid + "/yamlDynamicData");
    assert_eq(yaml, rv);

    # skip sensitive data tests if there are no encryption keys
    bool has_sd = UserApi::getQorusOptions("sensitive-data-key").toBool();
    if (has_sd) {
        # test sensitive data APIs
        string skey = get_random_string();
        string svalue = get_random_string();
        hash sh = (
            "skey": skey,
            "svalue": svalue,
        );
        rv = UserApi::callRestApi("PUT", "orders/" + wfiid + "/yamlSensitiveData", (sh + ("data": yaml)));
        assert_eq("OK", rv);
        rv = UserApi::callRestApi("GET", "orders/" + wfiid + "/sensitive_data");
        assert_eq((skey: (svalue: ("data": dh))), rv);
        rv = UserApi::callRestApi("GET", "orders/" + wfiid + "/yamlSensitiveData", sh);
        assert_eq(yaml, rv.data);
    }
}

*string sub get_loopback() {
    foreach hash rh in (UserApi::callRestApi("GET", "remote/qorus")) {
        if (rh.loopback) {
            return rh.name;
        }
    }
}

const TestJobPropDomain = "test";
const TestJobPropKey = "test-job-error";

sub bug_1820_1825(QorusSystemRestHelper qrest) {
    # workaround for bug #2499: ensure job is enabled
    UserApi::callRestApi("PUT", "jobs/test/enable");

    # run the test job
    hash h = qrest.put("jobs/test/run");
    test_value(h.job_instanceid.type(), Type::Int, "bug-1820-1825-1");

    # get the last_executed date
    date led = qrest.get("jobs/test/last_executed");

    # make sure the test job goes to error
    UserApi::propUpdate(TestJobPropDomain, TestJobPropKey, True);

    # run the test job again to ensure that the last_executed date is set and ensure that it goes to ERROR
    h = qrest.put("jobs/test/run");
    test_value(h.job_instanceid.type(), Type::Int, "bug-1820-1825-2");
    test_value(h.status, OMQ::StatError, "bug-1820-1825-2-1");

    # get the new last_executed date
    date led2 = qrest.get("jobs/test/last_executed");
    test_value(led2 > led, True, "bug-1820-1825-2-2");

    # disable and reenable the job
    hash jh = qrest.put("jobs/test/disable");
    test_value(jh.name.type(), Type::String, "bug-1820-1825-3");
    test_value(jh.version.type(), Type::String, "bug-1820-1825-4");
    test_value(jh.jobid.type(), Type::Int, "bug-1820-1825-5");
    test_value(jh.info.type(), Type::String, "bug-1820-1825-6");
    jh = qrest.put("jobs/test/enable");
    test_value(jh.name.type(), Type::String, "bug-1820-1825-7");
    test_value(jh.version.type(), Type::String, "bug-1820-1825-8");
    test_value(jh.jobid.type(), Type::Int, "bug-1820-1825-9");
    test_value(jh.info.type(), Type::String, "bug-1820-1825-10");

    # get the last job_instanceid for this job
    hash jrh = qrest.get("jobresults", ("ids": jh.jobid, "limit": 1, "sort": "modified", "desc": True))[0];
    UserApi::logDebug("jrh: %y", jrh);
    test_value(jrh.job_instanceid, h.job_instanceid, "bug-1820-1");
    test_value(jrh.info.last_executed.type(), Type::Date, "bug-1820-2");

    # make sure the last_executed date has been updated in the cache
    date led3 = qrest.get("system/metadata/jmap"){jh.jobid}.last_executed;
    test_value(led3, led2, "bug-1820-3");
}

sub bug_1879(QorusSystemRestHelper qrest) {
    softstring wfiid = WorkflowApi::getInstanceData("err_wfiid");

    hash h = qrest.get("workflows/RUN_LONG");

    softstring wfid = h.workflowid;
    softstring stepid;
    foreach hash sh in (h.stepinfo) {
        if (sh.name == "runlongjob") {
            stepid = sh.stepid;
            break;
        }
    }

    # sanity test search
    hash sh = (
        # comma separated values
        "error": "JOB-ERROR",
        "stepid": stepid,
        "name": "runlongjob",
        "workflow_instanceid": wfiid,
        "workflowid": wfid,
        "workflowstatus": "E",
        );

    list l = qrest.get("orders?action=listErrors", sh);
    #UserApi::logDebug("l: %N", l);
    test_value(l.size(), 1, "1879-1");

    # test comma handling in args
    sh = (
        # comma separated values
        "error": "JOB-ERROR,ERROR1",
        "stepid": "-123," + stepid,
        "name": "runlongjob,other",
        "workflow_instanceid": wfiid + ",-123",
        "workflowid": wfid + ",-123",
        "workflowstatus": "C,E,I",
        );

    l = qrest.get("orders?action=listErrors", sh);
    test_value(l.size(), 1, "1879-2");
}

sub bug_1719(QorusSystemRestHelper qrest) {
    int wfiid = WorkflowApi::getWfiid();
    hash h = qrest.get("orders/" + wfiid + "/HierarchyInfo");
    test_value(h.firstKey().toInt(), wfiid, "bug-1719-1");
}

sub bug_1552(QorusSystemRestHelper qrest) {
    # initialize to have always "equal start"
    hash sh = qrest.put("workflows/INVALID-CONNECTION/setAutostart", ("autostart": 0));
    # try to start the WF, which should fail with alert
    sh = qrest.put("workflows/INVALID-CONNECTION/incAutostart");
    test_value(sh.autostart, 1, "bug-1552-1");

    int ec = qrest.get("workflows/INVALID-CONNECTION/exec_count");
    test_value(ec, 0, "bug-1552-2");

    *list al = qrest.get("system/alerts/ongoing");
    *hash alel;
    foreach hash alm in (al) {
        if (alm.alert == "WORKFLOW-NOT-RUNNING" &&
            alm.name == "INVALID-CONNECTION") {
            test_value(alel, NOTHING, "bug-1552-2");
            alel = alm;
        }
    }
    test_value(exists alel, True, "bug-1552-3");

    # now dec autostart, should remove the alert
    sh = qrest.put("workflows/INVALID-CONNECTION/decAutostart");
    test_value(sh.autostart, 0, "bug-1552-4");
    al = qrest.get("system/alerts/ongoing");
    foreach hash alm in (al) {
        if (alm.alert == "WORKFLOW-NOT-RUNNING" &&
            alm.name == "INVALID-CONNECTION") {
            test_value(True, False, "bug-1552-4");
        }
    }
}

sub feature_1407(QorusSystemRestHelper qrest) {
    test_value(WorkflowApi::getSensitiveData("x", "y"), NOTHING, "feature-1407-1");
    try {
        WorkflowApi::getSensitiveDataFromAlias("0");
        test_value(True, False, "feature-1407-2-x");
    } catch (hash<ExceptionInfo> ex) {
        test_value(ex.err, "INVALID-ALIAS", "feature-1407-2");
    }
    test_value(WorkflowApi::getSensitiveDataAliases(), {}, "feature-1407-3");
    test_value(WorkflowApi::getSensitiveDataKeyValues(), {}, "feature-1407-4");
    test_value(WorkflowApi::getSensitiveMetadata("personid", "123"), {}, "feature-1407-md-0");
    try {
        WorkflowApi::getSensitiveMetadataFromAlias("0");
        test_value(True, False, "feature-1407-md-0-1-x");
    } catch (hash<ExceptionInfo> ex) {
        test_value(ex.err, "INVALID-ALIAS", "feature-1407-md-0-1");
    }

    hash<auto> sdh = {
        "address": "string",
        "taxid": "456",
    };

    hash<auto> md = ("PURPOSE": "x");
    hash<auto> mda = {
        "skey": "personid",
        "svalue": "123",
        "value": md,
    };
    WorkflowApi::updateSensitiveData("personid", "123", sdh, "0", md);

    test_value(WorkflowApi::getSensitiveData("personid", "123"), sdh, "feature-1407-5");
    test_value(WorkflowApi::getSensitiveData("personid", "123", "taxid"), "456", "issue-2527-1");
    test_value(WorkflowApi::getSensitiveData("personid", "123", "taxid", "invalid"), {"taxid": "456"}, "issue-2527-2");
    test_value(WorkflowApi::getSensitiveData("personid", "123", "taxid", "address"), sdh, "issue-2527-3");
    test_value(WorkflowApi::getSensitiveDataFromAlias("0", "taxid").value, "456", "issue-2527-1");
    test_value(WorkflowApi::getSensitiveDataFromAlias("0", "taxid", "invalid").value, {"taxid": "456"}, "issue-2527-2");
    test_value(WorkflowApi::getSensitiveDataFromAlias("0", "taxid", "address").value, sdh, "issue-2527-3");
    test_value(WorkflowApi::getSensitiveDataFromAlias("0"), ("skey": "personid", "svalue": "123", "value": sdh), "feature-1407-5-1");
    test_value(WorkflowApi::getSensitiveDataAliases(), ("0": ("skey": "personid", "svalue": "123")), "feature-1407-6");
    test_value(WorkflowApi::getSensitiveDataKeyValues(), ("personid": ("123",)), "feature-1407-7");
    test_value(WorkflowApi::getSensitiveMetadata("personid", "123"), md, "feature-1407-md-1");
    test_value(WorkflowApi::getSensitiveMetadataFromAlias("0"), mda, "feature-1407-md-2");

    try {
        WorkflowApi::getSensitiveDataFromAlias("1");
        test_value(True, False, "feature-1407-8-x");
    } catch (hash<ExceptionInfo> ex) {
        test_value(ex.err, "INVALID-ALIAS", "feature-1407-8");
    }

    # test deleting non-existent data
    test_value(WorkflowApi::deleteSensitiveDataKey("personid", "789", "taxid"), False, "feature-1407-9");
    test_value(WorkflowApi::deleteSensitiveDataKey("personid", "123", "otherid"), False, "feature-1407-10");

    # delete one key and test
    test_value(WorkflowApi::deleteSensitiveDataKey("personid", "123", "taxid"), True, "feature-1407-11");
    sdh -= "taxid";
    test_value(WorkflowApi::getSensitiveData("personid", "123"), sdh, "feature-1407-12");
    test_value(WorkflowApi::getSensitiveDataFromAlias("0"), ("skey": "personid", "svalue": "123", "value": sdh), "feature-1407-13");
    test_value(WorkflowApi::getSensitiveDataAliases(), ("0": ("skey": "personid", "svalue": "123")), "feature-1407-14");
    test_value(WorkflowApi::getSensitiveDataKeyValues(), ("personid": ("123",)), "feature-1407-15");
    test_value(WorkflowApi::getSensitiveMetadata("personid", "123"), md, "feature-1407-md-3");
    test_value(WorkflowApi::getSensitiveMetadataFromAlias("0"), mda, "feature-1407-md-4");

    # delete all keys and test
    test_value(WorkflowApi::deleteSensitiveData("personid", "123"), True, "feature-1407-16");
    test_value(WorkflowApi::getSensitiveData("personid", "123"), NOTHING, "feature-1407-17");
    test_value(WorkflowApi::getSensitiveMetadata("personid", "123"), {}, "feature-1407-md-5");
    try {
        WorkflowApi::getSensitiveDataFromAlias("0");
        test_value(True, False, "feature-1407-18-x");
    } catch (hash<ExceptionInfo> ex) {
        test_value(ex.err, "INVALID-ALIAS", "feature-1407-18");
    }
    try {
        WorkflowApi::getSensitiveMetadataFromAlias("0");
        test_value(True, False, "feature-1407-md-6-x");
    } catch (hash<ExceptionInfo> ex) {
        test_value(ex.err, "INVALID-ALIAS", "feature-1407-md-6");
    }
    test_value(WorkflowApi::getSensitiveDataAliases(), {}, "feature-1407-19");
    test_value(WorkflowApi::getSensitiveDataKeyValues(), {}, "feature-1407-20");

    # test SensitiveDataHelper
    SensitiveDataHelper sdhr();

    test_value(sdhr.get("x", "y"), NOTHING, "feature-1407-sd-1");
    try {
        sdhr.getFromAlias("0");
        test_value(True, False, "feature-1407-sd-2-x");
    } catch (hash<ExceptionInfo> ex) {
        test_value(ex.err, "INVALID-ALIAS", "feature-1407-sd-2");
    }
    test_value(sdhr.getAliases(), {}, "feature-1407-sd-3");
    test_value(sdhr.getKeyValues(), {}, "feature-1407-sd-4");
    test_value(sdhr.getMetadata("personid", "123"), {}, "feature-1407-sd-md-0");
    try {
        sdhr.getFromAlias("0");
        test_value(True, False, "feature-1407-sd-md-0-1-x");
    } catch (hash<ExceptionInfo> ex) {
        test_value(ex.err, "INVALID-ALIAS", "feature-1407-sd-md-0-1");
    }

    sdh = (
        "address": "string",
        "taxid": "456",
        );

    sdhr.update("personid", "123", sdh, "0", md);

    test_value(sdhr.get("personid", "123"), sdh, "feature-1407-sd-5");
    test_value(sdhr.getFromAlias("0"), ("skey": "personid", "svalue": "123", "value": sdh), "feature-1407-sd-5-1");
    test_value(sdhr.getAliases(), ("0": ("skey": "personid", "svalue": "123")), "feature-1407-sd-6");
    test_value(sdhr.getKeyValues(), ("personid": ("123",)), "feature-1407-sd-7");
    test_value(sdhr.getMetadata("personid", "123"), md, "feature-1407-sd-md-1");
    test_value(sdhr.getMetadataFromAlias("0"), mda, "feature-1407-sd-md-2");

    try {
        sdhr.getFromAlias("1");
        test_value(True, False, "feature-1407-sd-8-x");
    } catch (hash<ExceptionInfo> ex) {
        test_value(ex.err, "INVALID-ALIAS", "feature-1407-sd-8");
    }

    # test deleting non-existent data
    test_value(sdhr.deleteKey("personid", "789", "taxid"), False, "feature-1407-sd-9");
    test_value(sdhr.deleteKey("personid", "123", "otherid"), False, "feature-1407-sd-10");

    # delete one key and test
    test_value(sdhr.deleteKey("personid", "123", "taxid"), True, "feature-1407-sd-11");
    sdh -= "taxid";
    test_value(sdhr.get("personid", "123"), sdh, "feature-1407-sd-12");
    test_value(sdhr.getFromAlias("0"), ("skey": "personid", "svalue": "123", "value": sdh), "feature-1407-sd-13");
    test_value(sdhr.getAliases(), ("0": ("skey": "personid", "svalue": "123")), "feature-1407-sd-14");
    test_value(sdhr.getKeyValues(), ("personid": ("123",)), "feature-1407-sd-15");
    test_value(sdhr.getMetadata("personid", "123"), md, "feature-1407-sd-md-3");
    test_value(sdhr.getMetadataFromAlias("0"), mda, "feature-1407-sd-md-4");

    # delete all keys and test
    test_value(sdhr.del("personid", "123"), True, "feature-1407-sd-16");
    test_value(sdhr.get("personid", "123"), NOTHING, "feature-1407-sd-17");
    test_value(sdhr.getMetadata("personid", "123"), {}, "feature-1407-sd-md-5");
    try {
        sdhr.getFromAlias("0");
        test_value(True, False, "feature-1407-sd-18-x");
    } catch (hash<ExceptionInfo> ex) {
        test_value(ex.err, "INVALID-ALIAS", "feature-1407-sd-18");
    }
    try {
        sdhr.getMetadataFromAlias("0");
        test_value(True, False, "feature-1407-sd-md-6-x");
    } catch (hash<ExceptionInfo> ex) {
        test_value(ex.err, "INVALID-ALIAS", "feature-1407-sd-md-6");
    }
    test_value(sdhr.getAliases(), {}, "feature-1407-sd-19");
    test_value(sdhr.getKeyValues(), {}, "feature-1407-sd-20");

    sdhr.update("personid", "123", sdh, "0", md);

    test_value(sdhr.get("personid", "123"), sdh, "feature-1407-sd-21");
    test_value(sdhr.getFromAlias("0"), ("skey": "personid", "svalue": "123", "value": sdh), "feature-1407-sd-21-1");
    test_value(sdhr.getAliases(), ("0": ("skey": "personid", "svalue": "123")), "feature-1407-sd-22");
    test_value(sdhr.getKeyValues(), ("personid": ("123",)), "feature-1407-sd-23");
    test_value(sdhr.getMetadata("personid", "123"), md, "feature-1407-sd-md-7");
    test_value(sdhr.getMetadataFromAlias("0"), mda, "feature-1407-sd-md-8");

    sdh = (
        "address": "string",
        "taxid": "456",
        );

    md = ("PURPOSE": "y");
    mda = (
        "skey": "personid",
        "svalue": "123",
        "value": md,
        );

    sdhr.replace("personid", "123", sdh, "1", md);
    try {
        sdhr.getFromAlias("0");
        test_value(True, False, "feature-1407-sd-24-x");
    } catch (hash<ExceptionInfo> ex) {
        test_value(ex.err, "INVALID-ALIAS", "feature-1407-sd-24");
    }
    try {
        sdhr.getMetadataFromAlias("0");
        test_value(True, False, "feature-1407-sd-md-9-x");
    } catch (hash<ExceptionInfo> ex) {
        test_value(ex.err, "INVALID-ALIAS", "feature-1407-sd-md-9");
    }
    test_value(sdhr.get("personid", "123"), sdh, "feature-1407-sd-25");
    test_value(sdhr.getFromAlias("1"), ("skey": "personid", "svalue": "123", "value": sdh), "feature-1407-sd-25-1");
    test_value(sdhr.getAliases(), ("1": ("skey": "personid", "svalue": "123")), "feature-1407-sd-26");
    test_value(sdhr.getKeyValues(), ("personid": ("123",)), "feature-1407-sd-27");
    test_value(sdhr.getMetadata("personid", "123"), md, "feature-1407-sd-md-10");
    test_value(sdhr.getMetadataFromAlias("1"), mda, "feature-1407-sd-md-11");

    hash<string, hash<string, hash<SensitiveDataInfo>>> sinfo((
        "personid": (
            "456": new hash<SensitiveDataInfo>((
                "data": sdh,
                "aliases": "4x",
                "meta": md,
            )),
            "789": new hash<SensitiveDataInfo>((
                "data": sdh,
                "aliases": "7x",
                "meta": md,
            )),
        ),
    ));
    sdhr.replaceMulti(sinfo);
    test_value(sdhr.get("personid", "456"), sdh, "multi-1-1");
    test_value(sdhr.get("personid", "789"), sdh, "multi-1-2");
    test_value(sdhr.getFromAlias("4x"), ("skey": "personid", "svalue": "456", "value": sdh), "multi-1-3");
    test_value(sdhr.getFromAlias("7x"), ("skey": "personid", "svalue": "789", "value": sdh), "multi-1-4");
    test_value(keys sdhr.getAliases(), ("1", "4x", "7x"), "multi-1-5");
    test_value(sdhr.getKeyValues(), ("personid": ("123","456","789",)), "multi-1-6");
    test_value(sdhr.getMetadata("personid", "456"), md, "multi-1-7");
    test_value(sdhr.getMetadata("personid", "789"), md, "multi-1-8");
    test_value(sdhr.getMetadataFromAlias("4x"), mda + ("svalue": "456"), "multi-1-9");
    test_value(sdhr.getMetadataFromAlias("7x"), mda + ("svalue": "789"), "multi-1-10");
}

int sub wait_for_2195() {
    int x = 0;
    int tid1;

    # check if the job is running remotely or locally
    if (UserApi::callRestApi("GET", "jobs/test-longrun/remote")) {
        # get the process ID
        string proc_id;
        while (True) {
            try {
                proc_id = UserApi::callRestApi("GET", "jobs/test-longrun/process/id");
                break;
            } catch (hash<ExceptionInfo> ex) {
                #UserApi::logDebug("wait_for_2195() ex: %s", get_exception_string(ex));
                if (ex.err == "REST-ERROR") {
                    if (++x == 80) {
                        throw "ERROR";
                    }
                    # sleep for 1/4 of a second and check again
                    UserApi::usleep(250ms);
                    UserApi::logInfo("checking again %d/40", x);
                    continue;
                }
                rethrow;
            }
        }
        x = 0;
        bool found;
        while (True) {
            string str = backquote("qctl threads " + proc_id);
            DataLineIterator i(str);
            while (i.next()) {
                string line = i.getValue();
                *string tidstr = (line =~ x/TID ([0-9]+)$/)[0];
                if (tidstr) {
                    tid1 = tidstr.toInt();
                    continue;
                }
                if (line =~ /job_sleep/) {
                    if (!tid1) {
                        throw "ERROR", sprintf("cannot find TID for sleep call in %y", str);
                    }
                    found = True;
                    break;
                }
            }
            if (found) {
                break;
            }
            if (++x == 40) {
                throw "ERROR";
            }
            # sleep for 1/4 of a second and check again
            UserApi::usleep(250ms);
            UserApi::logInfo("checking again %d/40", x);
        }
    } else {
        while (True) {
            hash h = UserApi::callRestApi("GET", "/debug/threads");
            foreach hash qth in (h.pairIterator()) {
                if (qth.value[2].function == "job_sleep" && qth.value[2].file =~ /test-longrun/) {
                    tid1 = qth.key.toInt();
                    break;
                }
            }
            if (tid1) {
                break;
            }

            #UserApi::logDebug("tl: %y; sleeping", tl);
            if (++x == 40) {
                throw "ERROR";
            }
            # sleep for 1/4 of a second and check again
            UserApi::usleep(250ms);
            UserApi::logInfo("checking again %d/40", x);
        }
    }
    return tid1;
}

int sub wait_for_2195_2(int tid1) {
    int x = 0;
    int tid2;

    # check if the job is running remotely or locally
    if (UserApi::callRestApi("GET", "jobs/test-longrun/remote")) {
        # get the process ID
        string proc_id;
        while (True) {
            try {
                proc_id = UserApi::callRestApi("GET", "jobs/test-longrun/process/id");
                break;
            } catch (hash<ExceptionInfo> ex) {
                if (ex.err == "REST-ERROR") {
                    if (++x == 40) {
                        throw "ERROR";
                    }
                    # sleep for 1/4 of a second and check again
                    UserApi::usleep(250ms);
                    UserApi::logInfo("checking again %d/40", x);
                    continue;
                }
                rethrow;
            }
        }
        x = 0;
        while (True) {
            string str = backquote("qctl -v threads " + proc_id);
            DataLineIterator i(str);
            bool found;
            while (i.next()) {
                string line = i.getValue();
                *string tidstr = (line =~ x/TID ([0-9]+)$/)[0];
                if (tidstr) {
                    tid2 = tidstr.toInt();
                    continue;
                }
                if (tid2 == tid1) {
                    continue;
                }
                if (line =~ /Condition::wait.*Job.qc/ || line =~ /Job::run.*Job.qc/) {
                    if (!tid2) {
                        throw "ERROR", sprintf("cannot find TID for wait call in %y", str);
                    }
                    found = True;
                    break;
                }
            }
            if (found) {
                break;
            }
            if (++x == 40) {
                throw "ERROR";
            }
            # sleep for 1/4 of a second and check again
            UserApi::usleep(250ms);
            UserApi::logInfo("checking again %d/40", x);
        }
    } else {
        while (True) {
            hash h = UserApi::callRestApi("GET", "/debug/threads");
            foreach hash qth in (h.pairIterator()) {
                if (qth.key != tid1
                    && ((qth.value[0].function == "Condition::wait" && qth.value[0].file =~ /Job.qc/)
                        || (qth.value[1].function == "Job::run" && qth.value[1].file =~ /Job.qc/))) {
                    tid2 = qth.key.toInt();
                    break;
                }
            }
            if (tid2) {
                break;
            }

            #UserApi::logDebug("tl: %y; sleeping", tl);
            if (++x == 40) {
                throw "ERROR";
            }
            # sleep for 1/4 of a second and check again
            UserApi::usleep(250ms);
            UserApi::logInfo("checking again %d/40", x);
        }
    }
    return tid2;
}

sub bug_1561(QorusSystemRestHelper qrest) {
    # let's make sure we cannot run a disabled job
    hash h = qrest.put("jobs/test-longrun/disable");
    {
        on_exit {
            h = qrest.put("jobs/test-longrun/enable");
            test_value(h.info =~ /enabled/, True, "bug-1561-4");
        }

        test_value(h.info =~ /disabled/, True, "bug-1561-1");

        try {
            h = qrest.put("jobs/test-longrun/run");
            test_value(True, False, "bug-1561-2");
        } catch (hash<ExceptionInfo> ex) {
            if (ex.err != "GROUP-DISABLED" && ex.err != "JOB-ERROR") {
                UserApi::logInfo("ex: %s", get_exception_string(ex));
            }
            assert_eq(True, ex.err == "GROUP-DISABLED" || ex.err == "JOB-ERROR", "bug-1561-2");
        }

        # make sure job is inactive
        h = qrest.put("jobs/test-longrun/setActive", ("active": False));
        test_value(h.info =~ /inactive/, True, "bug-1561-3");
    }

    qrest.put("workflows/RUN_LONG/setAutostart", ("autostart" : 2));
    on_exit
        qrest.put("workflows/RUN_LONG/setAutostart", ("autostart" : 0));

    hash<auto> oh = {
        "staticdata": {},
    };

    softint wfiid1 = UserApi::createOrder("RUN_LONG", NOTHING, oh);
    UserApi::logDebug("created wfiid1 %d", wfiid1);
    wait_for_status("bug-1561-5", wfiid1, OMQ::StatInProgress);

    # issue #2195: ensure that the job is in progress before creating the second order
    # otherwise there is a race condition and the wrong order might fail, breaking the regression test workflow
    int tid1 = wait_for_2195();
    UserApi::logInfo("RUN_LONG wfiid %d is blocked in server thread %d", wfiid1, tid1);

    # 2nd order should be blocked by 1st one - job still running
    softint wfiid2 = UserApi::createOrder("RUN_LONG", NOTHING, oh);
    UserApi::logDebug("created wfiid2 %d", wfiid2);

    # wait for orders & steps to be IN-PROGRESS
    wait_for_status("bug-1561-5-1", wfiid1, OMQ::StatInProgress, NOTHING, "runlongjob");
    wait_for_status("bug-1561-5-2", wfiid2, OMQ::StatInProgress, NOTHING, "runlongjob");

    # ensure that the job calls are in progress
    # issue #2195: now that both steps are in progress, we need to make sure that the calls are in progress
    # before disabling the job; this is tricky; we need to look at the thread stacks
    # get TID for the blocked server-side job thread corresponding to the second RUN_LONG wf order
    {
        int tid2 = wait_for_2195_2(tid1);
        UserApi::logInfo("RUN_LONG wfiid %d is blocked in server thread %d", wfiid2, tid2);
    }

    # now let's send a stop request
    h = qrest.put("jobs/test-longrun/disable");
    on_exit qrest.put("jobs/test-longrun/enable");

    UserApi::logDebug("set active %y", h);

    # 2nd order should finish in error since the job is already scheduled to stop
    wait_for_status("bug-1561-6", wfiid2, OMQ::StatError);

    {
        # issue #2208: check info format
        string info = UserApi::callRestApi("GET", "/orders/" + wfiid2 + "/ErrorInstances")[0].info;
        UserApi::logInfo("info: %y", info);
        assert_eq(True, info =~ /jobid.*is stopping/);
    }

    # save wfiid for later use in a test
    WorkflowApi::updateInstanceData(("err_wfiid": wfiid2));
}

sub bug_1760(QorusSystemRestHelper qrest) {
    # let's make sure we cannot run a disabled job
    hash h = qrest.put("jobs/test-longrun/schedule?duration=860000");
    UserApi::logDebug("returned %y", h);
    test_value(h.duration, 860000, "bug-1760");
}

sub bug_1339(QorusSystemRestHelper qrest) {
    # start EVENT-SKIP-TEST
    hash sh = qrest.put("workflows/EVENT-SKIP-TEST/start");
    on_exit {
        qrest.put("workflows/EVENT-SKIP-TEST/stop");
        int n = qrest.get("workflows/EVENT-SKIP-TEST/exec_count");
        test_value(n, 0, "bug-1339-wait-8");
    }

    test_value(sh.exec.lsize() > 0, True, "bug-1339-start-1");

    # test where all steps are skipped
    hash oh = (
        "staticdata": (
            "list": (NOTHING, NOTHING, NOTHING),
        ),
        );

    softint wfiid = UserApi::createOrder("EVENT-SKIP-TEST", NOTHING, oh);
    UserApi::logInfo("created wfiid %d", wfiid);

    wait_for_status("bug-1339-wait-1", wfiid);

    # test where the first step is posted
    string event = UUID::get();
    UserApi::logInfo("using event %y", event);

    oh = (
        "staticdata": (
            "list": (event, NOTHING, NOTHING),
        ),
        );

    wfiid = UserApi::createOrder("EVENT-SKIP-TEST", NOTHING, oh);
    UserApi::logInfo("created wfiid %d", wfiid);

    wait_for_status("bug-1339-wait-2", wfiid, OMQ::StatEventWaiting);

    # post event
    UserApi::postSyncEvent("event-test", event);

    wait_for_status("bug-1339-wait-3", wfiid);

    # test where the second step is posted
    event = UUID::get();
    UserApi::logInfo("using event %y", event);
    oh = (
        "staticdata": (
            "list": (NOTHING, event, NOTHING),
        ),
        );

    wfiid = UserApi::createOrder("EVENT-SKIP-TEST", NOTHING, oh);
    UserApi::logInfo("created wfiid %d", wfiid);

    wait_for_status("bug-1339-wait-4", wfiid, OMQ::StatEventWaiting);

    # post event
    UserApi::postSyncEvent("event-test", event);

    wait_for_status("bug-1339-wait-5", wfiid);

    # test where the third step is posted
    event = UUID::get();
    UserApi::logInfo("using event %y", event);
    oh = (
        "staticdata": (
            "list": (NOTHING, NOTHING, event,),
        ),
        );

    wfiid = UserApi::createOrder("EVENT-SKIP-TEST", NOTHING, oh);
    UserApi::logInfo("created wfiid %d", wfiid);

    wait_for_status("bug-1339-wait-6", wfiid, OMQ::StatEventWaiting);

    # post event
    UserApi::postSyncEvent("event-test", event);

    wait_for_status("bug-1339-wait-7", wfiid);
}

sub feature_1336() {
    # make sure there are no keys set
    test_value(WorkflowApi::getOrderKeys().test, NOTHING, "feature-1336-1");

    # set a key
    hash h = ("test": "test1");
    WorkflowApi::setOrderKeys(h);
    test_value(WorkflowApi::getOrderKeys().test, h.test, "feature-1336-2");

    # append a key
    h = ("test": "test2");
    WorkflowApi::appendOrderKeys(h);
    test_value(WorkflowApi::getOrderKeys("test"), ("test1", "test2"), "feature-1336-3");

    h = ("test": "test3");
    WorkflowApi::appendOrderKeys(h);
    test_value(WorkflowApi::getOrderKeys("test"), ("test1", "test2", "test3"), "feature-1336-4");

    WorkflowApi::appendOrderKeys(h);
    test_value(WorkflowApi::getOrderKeys("test"), ("test1", "test2", "test3"), "feature-1336-5");

    h = ("test": ("test4",));
    WorkflowApi::appendOrderKeys(h);
    test_value(WorkflowApi::getOrderKeys("test"), ("test1", "test2", "test3", "test4"), "feature-1336-6");

    WorkflowApi::appendOrderKeys(h);
    test_value(WorkflowApi::getOrderKeys("test"), ("test1", "test2", "test3", "test4"), "feature-1336-7");
}

sub bug_1326(QorusSystemRestHelper qrest) {
    # start FEEDBACK-DETACH-PARENT
    hash sh = qrest.put("workflows/FEEDBACK-DETACH-PARENT/start");
    test_value(sh.exec.lsize() > 0, True, "bug-1326-start-1");

    on_exit {
        qrest.put("workflows/FEEDBACK-DETACH-PARENT/stop");
        int n = qrest.get("workflows/FEEDBACK-DETACH-PARENT/exec_count");
        test_value(n, 0, "bug-1326-wait-5");
    }

    # start FEEDBACK-DETACH-CHILD
    sh = qrest.put("workflows/FEEDBACK-DETACH-CHILD/start");
    test_value(sh.exec.lsize() > 0, True, "bug-1326-start-2");
    on_exit {
        # stop the workflows when the function exits
        qrest.put("workflows/FEEDBACK-DETACH-CHILD/stop");
        int n = qrest.get("workflows/FEEDBACK-DETACH-CHILD/exec_count");
        test_value(n, 0, "bug-1326-wait-4");
    }

    # create the order scheduled to execute in one minute to ensure that
    # it doesn't get executed yet, but also stays in the workflow order cache
    int wfiid = UserApi::createOrder("FEEDBACK-DETACH-PARENT", NOTHING, ("staticdata": ("test": "test"), "scheduled": now() + 1m));
    UserApi::logInfo("bug_1326: created parent wfiid %d", wfiid);

    # test bug 1772: cancel and uncancel the FEEDBACK-DETACH-PARENT workflow order
    # also tests bug 1775
    hash h = qrest.put("orders/" + wfiid + "/cancel");
    #UserApi::logDebug("cancel h: %y", h);
    test_value(h.workflow_status, OMQ::StatCanceled, "bug-1772-1775-cancel");

    # reschedule order to execute immediately
    string ok = qrest.put("orders/" + wfiid + "/reschedule");
    test_value(ok, "OK", "bug-1772-reschedule");

    # ensure status is still CANCELED
    h = qrest.get("orders/" + wfiid);
    test_value(h.workflowstatus, OMQ::StatCanceled, "bug-1812-1");
    test_value(h.scheduled, NOTHING, "bug-1812-2");

    h = UserApi::uncancelOrder(wfiid, ("test": True));
    #UserApi::logDebug("uncancel h: %y", h);
    test_value(inlist(h.workflow_status, (OMQ::StatReady, OMQ::StatScheduled, OMQ::StatInProgress)), True, "bug-1772-uncancel");

    wait_for_status("bug-1326-wait-1", wfiid, OMQ::StatError);

    # get child workflow instance ID
    h = qrest.get("orders/" + wfiid);
    softint cwfiid;
    foreach hash wh in (h.HierarchyInfo.iterator()) {
        if (wh.name == "FEEDBACK-DETACH-CHILD") {
            cwfiid = wh.workflow_instanceid;
            break;
        }
    }
    UserApi::logInfo("bug_1326: waiting for child %d", cwfiid);
    wait_for_status("bug-1326-wait-2", cwfiid, OMQ::StatEventWaiting);

    # post the workflow event
    UserApi::callNetworkApi("omq.system.post-event", "feedback-detach-child", h.dynamicdata.key);

    # wait for child to complete
    wait_for_status("bug-1326-wait-3", cwfiid);

    # retry can fail in case of a race condition where the parent step has not been updated
    # NOTE: the parent can temporarily go back to InProgress during receiving child's
    # feedback, at which point RETRY will fail. So that you can wait for Error status
    # but it is not final and you must not rely on it. We should find a way how to
    # determine whether a WF is in "final Error", then we can fix it properly.
    # --PQ 06-Sep-2016
    while (True) {
        try {
            # retry parent
            UserApi::logInfo("retrying wfiid %d", wfiid);
            qrest.put("orders/" + wfiid + "/retry");
            break;
        } catch (hash<ExceptionInfo> ex) {
            # poor man's solution, ignore STATUS-ERROR exceptions, sleep 1/2 second and try again
            if (ex.err == "STATUS-ERROR") {
                UserApi::logInfo("retry failed: %s: %s", ex.err, ex.desc);
                UserApi::usleep(500ms);
                continue;
            }
            rethrow;
        }
    }

    wait_for_status("bug-1326-wait-3.1", wfiid);
}

const StateTestHash = (
    "key1": "value",
    "key2": 100,
    );

sub feature_1248() {
    # test dynamic data helper
    string key = UUID::get();
    WorkflowApi::updateDynamicData(("ddf1248": key));
    {
        DynamicDataHelper ddh();
        test_value(ddh.get("ddf1248"), key, "dynamic-data-helper-get 1");
        key = UUID::get();
        ddh.update(("ddf1248": key));
        test_value(ddh.get("ddf1248"), key, "dynamic-data-helper-get 2");
        test_value(ddh.get().ddf1248, key, "dynamic-data-helper-get 3");
        test_value(WorkflowApi::getDynamicData("ddf1248"), key, "dynamic-data-helper-update");
    }
    WorkflowApi::deleteDynamicDataKey("ddf1248");
    test_value(WorkflowApi::getDynamicData("ddf1248"), NOTHING, "post dynamic-data-helper");

    # test temp data helper
    key = UUID::get();
    WorkflowApi::updateTempData(("tdf1248": key));
    {
        TempDataHelper tdh();
        test_value(tdh.get("tdf1248"), key, "temp-data-helper-get 1");
        key = UUID::get();
        tdh.update(("tdf1248": key));
        test_value(tdh.get("tdf1248"), key, "temp-data-helper-get 2");
        test_value(tdh.get().tdf1248, key, "temp-data-helper-get 3");
        test_value(WorkflowApi::getTempData("tdf1248"), key, "temp-data-helper-update");
    }
}

sub feature_1302() {
    omqservice.user."service-state-test".save(StateTestHash);
    on_exit omqservice.user."service-state-test".save();
    test_value(omqservice.user."service-state-test".get(), StateTestHash, "feature 1302");
}

sub bug_1277_1605(QorusSystemRestHelper qrest) {
    # ensure that the interfaces are enabled
    if (!UserApi::callRestApi("GET", "workflows/ASYNC-SEG-TEST/enabled")) {
        UserApi::callRestApi("PUT", "workflows/ASYNC-SEG-TEST/enable");
    }
    if (!UserApi::callRestApi("GET", "workflows/ASYNC-WAITER/enabled")) {
        UserApi::callRestApi("PUT", "workflows/ASYNC-WAITER/enable");
    }

    # also test bug 1605
    hash h = qrest.put("workflows/ASYNC-SEG-TEST/setAutostart", ("autostart": 5));
    test_value(h.autostart, 5, "bug-1605-set-autostart");
    on_exit {
        h = qrest.put("workflows/ASYNC-SEG-TEST/setAutostart", ("autostart": 0));
        test_value(h.autostart, 0, "bug-1605-clear-autostart-1");
        int n = qrest.get("workflows/ASYNC-SEG-TEST/exec_count");
        test_value(n, 0, "bug-1277-2");
    }

    h = qrest.post("workflows/ASYNC-SEG-TEST/execSynchronous", ("staticdata": ("a": 0)));
    UserApi::logInfo("created wfiid %d", h.workflow_instanceid);
    # wait until order has status COMPLETE
    wait_for_status("bug-1277-1", h.workflow_instanceid, OMQ::StatComplete, OMQ::StatError);
}

sub bug_1199(QorusSystemRestHelper qrest) {
    # hide the DUMMY-TEST workflow
    hash h = qrest.put("workflows/setDeprecated?ids=DUMMY-TEST;deprecated=true")[0];
    test_value(h.updated, True, "bug-1199 hide");
    # unhide the DUMMY-TEST workflow
    h = qrest.put("workflows/setDeprecated?ids=DUMMY-TEST;deprecated=false")[0];
    test_value(h.updated, True, "bug-1199 unhide");
    # start the DUMMY-TEST workflow
    h = qrest.put("workflows/DUMMY-TEST/start");
    test_value(h.exec.lsize() > 0, True, "bug-1199 start");
    # stop the DUMMY-TEST workflow
    string ans = qrest.put("workflows/DUMMY-TEST/stop");
    test_value(ans, "OK", "bug-1199 stop");
    int n = qrest.get("workflows/DUMMY-TEST/exec_count");
    test_value(n, 0, "bug-1199 count");
}

sub bug_1152() {
    if (omqservice.user."http-test".bug1152())
        test_value(True, False, "bug-1152");
    else
        test_value(True, True, "bug-1152");
}

sub test_datasource_apis() {
    try {
        UserApi::getDatasourceDedicated("omq");
        test_value(True, False, "datasource-api-1");
    } catch (hash<ExceptionInfo> ex) {
        test_value(ex.err, "DATASOURCE-ERROR", "datasource-api-1");
    }
    try {
        DatasourcePool dsp = UserApi::getDatasourcePool("omq");
        UserApi::logInfo("omq dsp: %y %s", dsp, dsp.toString());
        test_value(True, False, "datasource-api-3");
    } catch (hash<ExceptionInfo> ex) {
        test_value(ex.err, "DATASOURCE-ERROR", "datasource-api-3");
    }
}

sub bug_1119(QorusSystemRestHelper qrest) {
    # this bug only happens if the system schema is oracle
    string drv = qrest.get("system/omq-driver");
    if (drv != "oracle") {
        UserApi::logInfo("skipping test for bug 1119; system schema driver is %y, need \"oracle\" to test", drv);
        return;
    }

    # test other related APIs
    auto rv;

    try {
        rv = qrest.get("orders/-9999/async-queue?stepid=-1,ind=-1");
    } catch (hash<ExceptionInfo> ex) {
        test_value(ex.err, "WORKFLOW-ORDER-ERROR", "bug-1119-1 API v3");
    }

    # we must have a valid queue name to call the API in question
    *list l = qrest.get("async-queues");
    if (!l) {
        UserApi::logInfo("cannot test all of bug 1119 without any configured queues; load the entire regression test suite to have some example queues");
        return;
    }

    string name = l[0].name;

    try {
        rv = qrest.get("async-queues/"+name+"/info?key=someinvalidvalue1119-2");
        test_value(True, False, "rv cannot be returned. Expected is 404");
    } catch (hash<ExceptionInfo> ex) {
        on_error UserApi::logInfo("%s", get_exception_string(ex));
        UserApi::logInfo("ERR: %N\n", ex);
        test_value(ex.err, "DATASTREAM-CLIENT-RECEIVE-ERROR", "bug-1119-2 API v3");
        test_value(ex.arg.status_code, 404, "bug-1119-2 has to return http 404 code");
    }
}

sub test_stream_connection_overlap(QorusSystemRestHelper qrest) {
    try {
        DbRemoteReceive recv1(qrest, "omquser", "select", "regression_example", ("select": ("orderby": "id")));
        on_error
            recv1.disconnect();

        DbRemoteReceive recv2(qrest, "omquser", "select", "regression_example", ("select": ("orderby": "id")));
        test_value(True, False, "stream connection overlap");
    } catch (hash<ExceptionInfo> ex) {
        if (ex.err != "STREAM-ERROR" && ex.err != "PERSISTENCE-ERROR") {
            UserApi::logInfo("%s", get_exception_string(ex));
        }
        test_value({
                "PERSISTENCE-ERROR": True,
                "STREAM-ERROR": True,
            }{ex.err}, True, "stream connection overlap");
    }
}

sub bug_1252(QorusSystemRestHelper qrest) {
    hash h = (
        "staticdata": {},
        "status": OMQ::StatBlocked,
    );
    softint wfiid = qrest.post("workflows/SIMPLETEST/createOrder", h).workflow_instanceid;
    UserApi::logInfo("created SIMPLETEST wfiid: %d", wfiid);
    h = qrest.get("orders/" + wfiid);
    test_value(h.workflowstatus, OMQ::StatBlocked, "bug-1252");
}

class GcTest {
    public {
        static int cnt;
        any a;
        *GcTest b;
        *GcTest c;
    }

    private {
        *GcTest o;
    }

    constructor(*GcTest obj) {
        o = obj;
    }

    destructor() {
        # increment static counter in destructor
        ++cnt;
    }

    set(*GcTest obj) {
        o = obj;
    }
}

sub bug_938(QorusSystemRestHelper qrest) {
    # make sure all instances of DUMMY-TEST are stopped
    stop_workflow("DUMMY-TEST");

    # start the DUMMY-TEST workflow
    int id = UserApi::callNetworkApi("omq.system.start-workflow", ("name": "DUMMY-TEST")).id;
    test_value(id > 0, True, "938-dummy-start-1");

    # verify both options are present
    test_value(qrest.get("workflows/DUMMY-TEST/options").lsize(), 2, "938-check-1");

    # reset omqmap workflow cache
    qrest.put("system/metadata/reload/workflows");

    # verify both options are present
    test_value(qrest.get("workflows/DUMMY-TEST/options").lsize(), 2, "938-check-2");
}

sub test_gc() {
    GcTest::cnt = 0;

    # make circular references
    {
        GcTest obj1();
        obj1.a = obj1;
    }
    test_value(GcTest::cnt, 1, "recursive gc 1");

    {
        GcTest obj2();
        obj2.a = obj2;
    }
    test_value(GcTest::cnt, 2, "recursive gc 2");

    {
        GcTest obj3();
        obj3.a.a = obj3;
    }
    test_value(GcTest::cnt, 3, "recursive gc 3");

    {
        GcTest obj4();
        obj4.a = list(obj4);
    }
    test_value(GcTest::cnt, 4, "recursive gc 4");

    {
        GcTest obj5();
        GcTest obj6();
        obj5.a = obj6;
        obj6.b = obj5;
    }
    test_value(GcTest::cnt, 6, "recursive gc 6");

    {
        GcTest obj7();
        obj7.a = obj7;
        obj7.b = obj7;
    }
    test_value(GcTest::cnt, 7, "recursive gc 7");

    {
        GcTest obj8();
        GcTest obj9();

        obj8.a = ("a": obj9, "b": obj9);
        obj9.b = obj8;
        obj9.c = obj8;
    }
    test_value(GcTest::cnt, 9, "recursive gc 9");

    {
        GcTest obj10();
        GcTest obj11();
        obj10.set(obj11);
        obj11.set(obj10);
    }
    test_value(GcTest::cnt, 11, "recursive gc 11");

    {
        GcTest obj12();
        {
            GcTest obj13();

            obj12.a = obj13;
            obj13.a = obj12;
        }
    }
    test_value(GcTest::cnt, 13, "recursive gc 13-1");

    {
        GcTest t1();
        GcTest t2();
        t1.set(t2);
        t2.set(t1);
        t1.set();

        test_value(GcTest::cnt, 13, "recursive gc 13-2");
    }
    test_value(GcTest::cnt, 15, "recursive gc 15-1");

    {
        GcTest t1();
        t1.set(t1);
        t1.set();

        test_value(GcTest::cnt, 15, "recursive gc 15-2");
    }
    test_value(GcTest::cnt, 16, "recursive gc 16-1");

    {
        GcTest t1();
        {
            GcTest t2();
            t1.set(t2);
            t2.set(t1);
            t2.b = t1;
            {
                GcTest t3();
                t2.set(t3);
                t2.b = t1;
                {
                    GcTest t4();
                    t3.set(t4);
                    t4.set(t1);
                    t3.b = t2;
                    t4.b = t3;
                }
            }
        }
        test_value(GcTest::cnt, 16, "recursive gc 16-2");
    }
    test_value(GcTest::cnt, 20, "recursive gc 20");
}

sub test_rest_errors(QorusSystemRestHelper qrest) {
    # make sure there are no errors for this wf
    list l = qrest.get("errors/workflow/REGRESSION-TEST");
    test_value(l, (), "REST get workflow errors");

    hash h = qrest.get("errors/global/SOCKET-TIMEOUT");
    test_value(h.error, "SOCKET-TIMEOUT", "REST get global error");

    # create a workflow error
    string str = qrest.post("errors/workflow/REGRESSION-TEST?error=SOCKET-TIMEOUT;desc=timeout;status=RETRY");
    test_value("CREATED-WORKFLOW", str, "REST create workflow error");

    {
        on_exit
            qrest.del("errors/workflow/REGRESSION-TEST/SOCKET-TIMEOUT");

        str = qrest.put("errors/workflow/REGRESSION-TEST/SOCKET-TIMEOUT/update?desc=test123");
        test_value("UPDATED-WORKFLOW", str, "REST update workflow error");

        h = qrest.get("errors/workflow/REGRESSION-TEST/SOCKET-TIMEOUT");
        test_value("test123", h.description, "REST update workflow error value");

        test_value(WorkflowApi::getWorkflowMetadata().workflowid, h.workflowid, "REST get workflow-specific error");
    }
}

sub bug_852() {
    date now = now_us();
    hash h = (
        "orderby": ("name","error"),
        "mindate": now,
        "workflowstatus": OMQ::StatError,
        "workflowid": 10,
        "workflow_instanceid": 123,
        "desc": 1,
        "description": "test",
        "info": "test",
        "stepid": 1,
        "severity": "MAJOR",
        "stepname": "test",
        "stepversion": "1.0",
        "retry": 1,
        "business_error": 1,
        "error_instanceid": 123,
        "maxdate": now + 1D,
        "limit": 50,
    );

    string str = "OK";
    try {
        omqservice.system.info.searchWorkflowErrors(h);
    } catch (hash<ExceptionInfo> ex) {
        str = ex.err;
    }
    test_value("OK", str, "info.searchWorkflowErrors");
}

class DataStreamDataCollector inherits DataStreamRecvMessage {
    public {
        data data;
    }

    private nothing recvDataImpl(any d) {
        data += d;
    }

    reset() {
        delete data;
    }
}

class DataStreamDataSender inherits DataStreamSendMessage {
    public {
        data data;
    }

    constructor(data d) {
        data = d;
    }

    set(data d) {
        data = d;
    }

    private any sendDataImpl() {
        if (data.empty())
            return;

        return extract data, 0, 1024;
    }
}

class DataStreamNullSender inherits DataStreamSendMessage {
    private any sendDataImpl() {
        UserApi::sleep(1s);
    }
}

class DataStreamCollector inherits DataStreamRecvMessage {
    public {
        list data = ();
    }

    private nothing recvDataImpl(any d) {
        data += d;
    }

    reset() {
        data = ();
    }
}

const TestXmlData = (
    "Report": (
        "Records": (
            ("name": "Test1", "date": "2014-05-19T05:01:00"),
            ("name": "Test2", "date": "2014-05-29T09:00:00"),
            ("name": "Test3", "date": "2014-05-30T12:00:00"),
        ),
    ),
);

const TestCsvData = (
    'UK,1234567890,"Sony, Xperia S",31052012',
    'UK,1234567891,"Sony, Xperia S",31052012',
    'UK,1234567892,"Sony, Xperia S",31052012',
    'UK,1234567893,"Sony, Xperia S",31052012',
);

const TestCsvParsedData = (
    ("cc": "UK", "serno": 1234567890, "desc": "Sony, Xperia S", "received": 2012-05-31),
    ("cc": "UK", "serno": 1234567891, "desc": "Sony, Xperia S", "received": 2012-05-31),
    ("cc": "UK", "serno": 1234567892, "desc": "Sony, Xperia S", "received": 2012-05-31),
    ("cc": "UK", "serno": 1234567893, "desc": "Sony, Xperia S", "received": 2012-05-31),
);

class BlockDataSender {
    public {}

    private {
        data data;
        int block;
    }

    constructor(data d, int b = 15) {
        set(d);
        block = b;
    }

    set(data d) {
        data = d;
    }

    *data send() {
        *data rv = extract data, 0, block;
        return rv;
    }
}

class BlockDataReceiver {
    public {}

    private {
        data data;
    }

    recv(hash h) {
        if (h.data)
            data += h.data;
    }

    *data getData() {
        return data;
    }
}

sub vsets_tests() {
    test_value(UserApi::getValueMap("regression1", "key1"), "foo", "UserApi::getValueMap value");
    try {
        test_value(UserApi::getValueMap("regression1", "key2"), "bar", "UserApi::getValueMap value - error");
    } catch (hash<ExceptionInfo> ex) {
        test_value(ex.err, "VALUE-MAP-ERROR", "UserApi::getValueMap value - expected error");
    }
    test_value(UserApi::getValueMap("regression2", "key1"), "foo", "UserApi::getValueMap value");
    test_value(UserApi::getValueMap("regression2", "key2"), NOTHING, "UserApi::getValueMap value - no value");
    test_value(UserApi::getValueMap("regression3", "key1"), 1, "UserApi::getValueMap value 3a");
    test_value(UserApi::getValueMap("regression3", "key2"), 2, "UserApi::getValueMap value 3b");
}

sub fs_tests(QorusSystemRestHelper qrest) {
    string xml = makeXMLString(TestXmlData);

    UserApi::logInfo("tmpdir: %y", UserApi::propGet("regression-test", "tmpdir"));
    string tmp = (UserApi::propGet("regression-test", "tmpdir") ?? tmp_location()) + DirSep;

    string fn1 = tmp + "qorus-regression-test-" + UUID::get();
    string fn2 = tmp + "qorus-regression-test-" + UUID::get();

    UserApi::logInfo("hdr: %y", qrest.getDefaultHeaders());
    {
        BlockDataSender bds(xml);
        hash<auto> info;
        on_error UserApi::logError("info: %N", info);
        hash<auto> h = qrest.sendRawStream(\bds.send(), "POST", "/api/services/fs?action=stream;stream=put-file-raw;path="
            + fn1 + ";target_path="+fn2, 20s, \info);
        #UserApi::logInfo("h: %N", h);
        test_value(h.body.size, xml.size(), "put-file-raw raw xml stream");

        on_exit qrest.put("services/fs/del?action=call;args="+fn2);

        BlockDataReceiver bdr();
        h = qrest.getRawStream(\bdr.recv(), "GET", "/api/services/fs?action=stream;stream=get-file-raw;path="+fn2,
            NOTHING, 20s, \info);
        test_value(h.status_code, 200, "get-file-raw header");
        test_value(bdr.getData(), xml, "get-file-raw raw xml stream");
    }

    DataStreamDataSender dss(xml);
    hash h = qrest.sendDataStream(dss, "POST", "services/fs?action=stream;stream=put-file;encoding=utf8;path="+fn1+";target_path="+fn2, 20s);
    test_value(h.body.size, xml.size(), "put-file xml stream");

    on_exit qrest.put("services/fs/del?action=call;args="+fn2);

    DataStreamDataCollector dsdc();
    qrest.recvDataStream(dsdc, "GET", "services/fs?action=stream;stream=get-file;path="+fn2, NOTHING, 20s);
    test_value(binary_to_string(dsdc.data), xml, "get-file xml stream");
    dsdc.reset();

    DataStreamCollector dsc();
    qrest.recvDataStream(dsc, "GET", "services/fs?action=stream;stream=get-xml-data;element=Records;path="+fn2, NOTHING, 20s);
    test_value(dsc.data, TestXmlData.Report.Records, "get-xml-data stream");
    dsc.reset();

    string fn3 = tmp + "qorus-regression-test-" + UUID::get();

    string csv = TestCsvData.join("\n");
    dss.set(csv);
    h = qrest.sendDataStream(dss, "POST", "services/fs?action=stream;stream=put-file;encoding=utf8;path="+fn3, 20s);
    test_value(h.body.size, csv.size(), "put-file csv stream");

    on_exit qrest.put("services/fs/del?action=call;args="+fn3);

    qrest.recvDataStream(dsdc, "GET", "services/fs?action=stream;stream=get-file;path="+fn3, NOTHING, 20s);
    test_value(binary_to_string(dsdc.data), csv, "get-file csv stream");
    dsdc.reset();

    hash ch = (
        "action": "stream",
        "stream": "get-csv-data",
        "path": fn3,
        "csvutil": (
            "headers": ("cc", "serno", "desc", "received"),
            "fields": (
                "serno": "int",
                "received": ("type": "date", "format": "DDMMYYYY"),
            ),
        ),
    );

    qrest.recvDataStream(dsc, "GET", "services/fs", ch, 20s);
    test_value(dsc.data, TestCsvParsedData, "get-csv-data stream");
    dsc.reset();

    # high level streaming api - for filesystem
    # FsRemoteSend
    {
        UserApi::logDebug("FsRemoteSend test start");
        string content = "lorem ipsum\n";
        # issue #2867: use a unique filename for FS tests
        string fn = sprintf(tmp + get_random_string() + "-qorus-client-stream.txt");
        FsRemoteSend fs(qrest, fn);
        fs.append(content);
        fs.commit();

        ReadOnlyFile f(fn);
        string refdata = f.read(-1);
        test_value(content, refdata, "FsRemoteSend");
        f.close();

        UserApi::logDebug("FsRemoteSend::rename test start");
        fn += "-1";
        fs.rename(fn);
        ReadOnlyFile fr(fn);
        refdata = fr.read(-1);
        test_value(content, refdata, "FsRemoteSend::rename");
        fr.close();

        # delete the test file
        fs.del();
    }

    # high level streaming api - for filesystem
    # FsRemoteSend with user connections
    {
        UserApi::logDebug("FsRemoteSend conn test start");
        string content = "lorem ipsum\n";
        # issue #2867: use a unique filename for FS tests
        string fn = get_random_string() + "-qorus-client-stream.txt";
        string userConn = "fs-regression";
        if (PlatformOS == "Windows")
            userConn = "fs-regression-win";
        FsRemoteSend fs(qrest, userConn, fn);
        fs.append(content);
        fs.commit();

        # get actual target location
        string ftmp = qrest.get("remote/user/" + userConn + "/url");
        if (PlatformOS == "Windows")
            ftmp =~ s/^file:\/\/\/?//;
        else
            ftmp =~ s/^file:\/\///;
        ftmp += DirSep;

        ReadOnlyFile f(ftmp + fn);
        string refdata = f.read(-1);
        test_value(content, refdata, "FsRemoteSend conn");
        f.close();

        UserApi::logDebug("FsRemoteSend::rename conn test start");
        fn += "-2";
        fs.rename(fn);
        ReadOnlyFile fr(ftmp + fn);
        refdata = fr.read(-1);
        test_value(content, refdata, "FsRemoteSend::rename conn");
        fr.close();

        # delete the test file
        fs.del();
    }

    # high level streaming api - negative - with not existing user connection
    # FsRemoteSend with user connections
    {
        UserApi::logDebug("FsRemoteSend negative conn test start");
        *hash<ExceptionInfo> ex;
        try {
            string content = "lorem ipsum\n";
            # issue #2867: use a unique filename for FS tests
            FsRemoteSend fs(qrest, "fs-not-existing", get_random_string() + "-qorus-client-stream.txt");
            on_success fs.commit();
            on_error fs.cancel();

            fs.append(content);
        } catch (hash<ExceptionInfo> ex1) {
            ex = ex1;
            #UserApi::logDebug("%s: %s: %s", get_ex_pos(ex), ex.err, ex.desc);
        }
        test_value(exists ex, True, "FsRemoteSend negative conn test");
    }

    # high level streaming api - for filesystem
    # FsRemote tests
    {
        UserApi::logDebug("FsRemote conn test start");
        string content = "lorem ipsum\n";
        # issue #2867: use a unique filename for FS tests
        string fn = get_random_string() + "-qorus-client-stream.txt";
        string userConn = "fs-regression";
        if (PlatformOS == "Windows")
            userConn = "fs-regression-win";

        FsRemote fs(qrest);
        fs.write_file_conn(userConn, fn, content);

        # get actual target location
        string ftmp = qrest.get("remote/user/" + userConn + "/url");
        if (PlatformOS == "Windows")
            ftmp =~ s/^file:\/\/\/?//;
        else
            ftmp =~ s/^file:\/\///;
        ftmp += DirSep;

        ReadOnlyFile f(ftmp + fn);
        string refdata = f.read(-1);
        test_value(content, refdata, "FsRemote conn");
        f.close();

        fs.del_conn(userConn, fn);
    }
}

const SchemaOptions = (
    "replace": True,
    "driver": (
        "oracle": (
            "compute_statistics": True,
            "character_semantics": True,
        ),
    ),
);

const T_RegressionExample = (
    "columns": (
        "id": c_int(True, "PK ID field"),
        "filename": c_varchar(200, True, "input filename"),
        "uuid": c_varchar(40, True, "system-supplied UUID for the file"),
        "store_code": c_varchar(200, True, "input store code"),
        "product_code": c_varchar(50, True, "input product code / EAN"),
        "product_desc": c_varchar(200, True, "input product description"),
        "cost": c_number(22, 2, True),
        "ordered": c_int(True),
        "available": c_int(True),
        "in_transit": c_int(True),
        "total": c_int(True),
        "qorus_wfiid": c_int(True),
    ),
    "primary_key": ("name": "pk_regression_example", "columns": ("id")),
    "indexes": (
        "sk_regression_example_filename": ("columns": ("filename")),
        "sk_regression_example_uuid": ("columns": ("uuid")),
        "sk_regression_example_q_wfiid": ("columns": ("qorus_wfiid")),
    ),
);

const T_DsTest1 = (
    "columns": (
        "id": c_int(True, "ID field"),
        "status": c_varchar(1, True),
        "updated_id": c_int(False),
    ),
);

const T_RegressionStreamsTarget = (
    "columns": (
        "id": c_int(True, "PK ID field"),
        "filename": c_varchar(200, True, "input filename"),
        "uuid": c_varchar(40, True, "system-supplied UUID for the file"),
        "store_code": c_varchar(200, True, "input store code"),
        "product_code": c_varchar(50, True, "input product code / EAN"),
        "product_desc": c_varchar(200, True, "input product description"),
        "cost": c_number(22, 2, True),
        "ordered": c_int(True),
        "available": c_int(True),
        "in_transit": c_int(True),
        "total": c_int(True),
        "qorus_wfiid": c_int(True),
    ),
    "primary_key": ("name": "pk_regression_streams_target", "columns": ("id")),
);

const RegressionSchema = (
    "tables": (
        "regression_example": T_RegressionExample,
        "regression_streams_target": T_RegressionStreamsTarget,
        "ds_test1": T_DsTest1,
    ),
    "sequences": (
        "seq_regression_example": hash(),
    ),
);

const TestData = (
    ("id": iop_seq("seq_regression_example"), "filename": "StockReport-20131217174630.xml", "uuid": "f0350061-001a-4477-9e02-abd7c740ce35", "store_code": "Vclavsk nmst", "product_code": "SV300S37A/120G", "product_desc": "Kingston SSDNow V300 120GB 7mm", "cost": 249.50n, "ordered": 4, "available": 3, "in_transit": 5, "total": 12, "qorus_wfiid": 137083),
    ("id": iop_seq("seq_regression_example"), "filename": "StockReport-20131217174631.xml", "uuid": "f0350062-001a-4477-9e02-abd7c740ce35", "store_code": "Vclavsk nmst", "product_code": "SV300S37B/240G", "product_desc": "Kingston SSDNow V300 240GB 7mm", "cost": 499.95n, "ordered": 2, "available": 2, "in_transit": 0, "total": 4, "qorus_wfiid": 137083),
);

class DataStreamSender inherits DataStreamSendMessage {
    public {
        list data;
    }

    constructor(softlist d) {
        data = d;
    }

    set(softlist d) {
        data = d;
    }

    private any sendDataImpl() {
        list l = extract data, 0, 500;
        return l ? l : NOTHING;
    }
}

sub sqlutil_tests_bug1559(QorusSystemRestHelper qrest) {
    hash bug1559_tests = (
            "simple select" : ( "sql" : "select qorus_wfiid from regression_example where qorus_wfiid = %v",
                                "argv" : 137083,
                                "result" : ("qorus_wfiid" : (137083, 137083,)),
                              ),
            "simple update" : ( "sql" : "update regression_example set qorus_wfiid = qorus_wfiid where qorus_wfiid = %v",
                                "argv" : 137083,
                                "result" : 2,
                              ),
            "oracle pl/sql" : ( "sql" : "declare tmp number; begin select 1 into tmp from dual; :ret := tmp; end;",
                                "argv" : Type::Int,
                                "result" : ("ret" : 1),
                                "driver" : "oracle",
                              ),
        );

    *string drv = qrest.get("system/omquser-driver");

    HashIterator bug1559_it(bug1559_tests);
    while (bug1559_it.next()) {
        string desc = bug1559_it.getKey();
        hash test = bug1559_it.getValue();
        UserApi::logInfo("bug1559: Start of %s", desc);

        if (!exists test.driver || test.driver == drv) {
            list a = ("omquser", test.sql, );
            if (exists test.argv) {
                a += test.argv;
            }

            any ret = qrest.put("services/sqlutil/exec_sql?action=call", ("args" : a));
            if (ret != test.result) {
                throw "BUG1559-ERROR", sprintf("%s: returned: %n; expected: %n", desc, ret, test.result);
            }
        }
        else {
            UserApi::logInfo("bug1559: test skipped because driver is not '%s' (it's '%s')", test.driver, drv);
        }

        UserApi::logInfo("bug1559: end of %s", desc);
    }
}

sub test_pseudocolumns() {
    AbstractTable re = UserApi::getSqlTable("omquser", "regression_example", False);
    AbstractTable rst = UserApi::getSqlTable("omquser", "regression_streams_target", False);

    hash h = (
        "columns": ("rowid", "id"),
    );
    string sql;
    *list q = re.selectRows(h, \sql);
    UserApi::logDebug("sql: %s", sql);
    test_value(q, (), "simple-pseudocolumn");

    h = (
        "columns": ("rowid", "id"),
        "where": ("rowid": "rst.rowid"),
        "join": join_inner(rst, "rst", ("id": "id")),
    );
    UserApi::logDebug("sql: %s", re.getSelectSql(h));
    q = re.selectRows(h, \sql);
    UserApi::logDebug("sql: %s", sql);
    test_value(q, (), "join-pseudocolumn");
}

sub sqlutil_tests(QorusSystemRestHelper qrest) {
    UserApi::logDebug("sqlutil_tests start");
    # ensure start with always the same schema status
    qrest.put("services/sqlutil/drop_schema?action=call", ("args": ("omquser", RegressionSchema)));
    # create test schema from scratch
    hash h = omqservice.system.sqlutil.align_schema("omquser", RegressionSchema, SchemaOptions);
    UserApi::logInfo("created regression schema");

    {
        # issue #3433 tests
        assert_throws("DATA-TYPE-ERROR", \UserApi::getTypeFromPath(), "datasource/omquser/xxxx_invalid");
        assert_throws("DATA-TYPE-ERROR", \UserApi::getTypeFromPath(), "datasource/omquser/regression_example");
        AbstractDataProviderType type = UserApi::getTypeFromPath("datasource/omquser/regression_example/record");
        assert_eq("hash<auto>", type.getBaseTypeName());

        # FIXME: setup user and remote connections for automatic tests
        #type = UserApi::getTypeFromPath("connection/rest-billing-demo/accounts/GET/request");
        #assert_eq(NT_HASH, type.getBaseTypeCode());
        #type = UserApi::getTypeFromPath("remote/isepl/datasources/omquser/regression_example/record");
        #assert_eq(NT_HASH, type.getBaseTypeCode());
    }

    # test Oracle pseudocolumns if possible
    *string drv = qrest.get("system/omquser-driver");
    if (drv == "oracle")
        test_pseudocolumns();
    else
        UserApi::logInfo("skipping Oracle pseudocolumn tests; omquser driver is: %y", drv);

    table_cache_tests();

    on_exit {
        qrest.put("services/sqlutil/drop_schema?action=call", ("args": ("omquser", RegressionSchema)));
        UserApi::logInfo("dropped regression schema");
    }

    DataStreamSender dss(TestData);
    h = qrest.sendDataStream(dss, "POST", "services/sqlutil?action=stream;stream=insert;datasource=omquser;table=regression_example", 20s);
    UserApi::logInfo("body: %N", h.body);
    test_value(h.body.rows, 2, "insert stream");

    DataStreamCollector dsc();
    {
        list data = TestData;
        data[0].id = 1;
        data[1].id = 2;
        qrest.recvDataStream(dsc, "GET", "services/sqlutil?action=stream;stream=select;datasource=omquser;table=regression_example", NOTHING, 20s);
        test_value(dsc.data, data, "select stream");
        dsc.reset();

        dss.set(data);
        h = qrest.sendDataStream(dss, "POST", "services/sqlutil?action=stream;stream=upsert;datasource=omquser;table=regression_example", 20s);
        UserApi::logInfo("upsert result: %y", h.body);
        test_value(h.body.rows, 2, "upsert stream");

        qrest.recvDataStream(dsc, "GET", "services/sqlutil?action=stream;stream=select;datasource=omquser;table=regression_example", NOTHING, 20s);
        test_value(dsc.data, data, "select stream after upsert");
        dsc.reset();
    }

    JavaRegression::testSchema();

    # negative stream test
    try {
        qrest.recvDataStream(dsc, "GET", "services/sqlutil?action=stream;stream=select;datasource=xxxinvalidxxx;table=regression_example", NOTHING, 20s);
        test_value(True, False, "negative select stream");
    } catch (hash<ExceptionInfo> ex) {
        test_value(ex.err, "DATASOURCE-ERROR", "negative select stream");
    }
    dsc.reset();

    # transaction test
    {
        list data = TestData;
        data[0].id = 998;
        data[1].id = 999;
        dss.set(data);
        # start a persistent connection
        h = qrest.sendDataStream(dss, "POST", "services/sqlutil?action=stream;stream=upsert;datasource=omquser;table=regression_example", 20s, NOTHING, ("Qorus-Connection": "Persistent"));
        test_value(h.body.rows, 2, "upsert stream");
        test_value(h."qorus-connection", "Persistent", "persistent DataStream connection acknowledgement");
        # throw an exception if the connection is lost instead of automatically reconnecting
        qrest.setPersistent();
        # make sure and disconnect if there are any errors in order to rollback the transaction
        on_error qrest.disconnect();

        data[2] = data[0];
        data[3] = data[1];
        data[0].id = 1;
        data[1].id = 2;
        qrest.recvDataStream(dsc, "GET", "services/sqlutil?action=stream;stream=select;datasource=omquser;table=regression_example;orderby=id", NOTHING, 20s);
        test_value(dsc.data, data, "select stream after upsert");
        dsc.reset();

        # rollback the transaction
        qrest.recvDataStream(dsc, "POST", "services/sqlutil?action=stream;stream=rollback", NOTHING, 20s);
        dsc.reset();

        pop data;
        pop data;

        qrest.recvDataStream(dsc, "GET", "services/sqlutil?action=stream;stream=select;datasource=omquser;table=regression_example", NOTHING, 20s);
        test_value(dsc.data, data, "select stream after rollback");
        dsc.reset();
    }

    test_value(qrest.get("remote/datasources/omquser/up"), True, "REST after stream error");

    # #1559 system.sqlutil: exec_sql and exec_raw_sql does return NOTHING in case simple DML statements
    sqlutil_tests_bug1559(qrest);

    {
        DataStreamNullSender dss();
        # start a persistent connection, but force a remote timeout after 1ms
        string err;
        try {
            qrest.sendDataStream(dss, "POST", "services/sqlutil?action=stream;stream=upsert;datasource=omquser;table=regression_example;timeout=1", 20s, NOTHING, ("Qorus-Connection": "Persistent"));
        } catch (hash<ExceptionInfo> ex) {
            err = ex.err;
        }
        qrest.disconnect();
        test_value(err, "SOCKET-TIMEOUT", "REST stream remote timeout");
    }

    DatasourcePool dsomquser = UserApi::getDatasourcePool("omquser");

    # high level streaming api - for databases
    # DbRemoteReceive
    {
        UserApi::logDebug("DbRemoteReceive::select test start");
        DbRemoteReceive recv(qrest, "omquser", "select", "regression_example", ("select": ("orderby": "id")));
        list data = recv.getAllDataRows();
        # do not compare sequence-generated-IDs here
        list refdata = dsomquser.selectRows("select * from regression_example order by id");
        test_value((map $1-"id", data), (map $1-"id", refdata), "DbRemoteReceive::select");
        # check counters
        test_value(recv.getInfo().total_count, data.size(), "DbRemoteReceive::select - total_count");
    }

    # DbRemoteReceive select bulk
    {
        UserApi::logDebug("DbRemoteReceive::select bulk with getData() test start");
        DbRemoteReceive recv(qrest, "omquser", "select", "regression_example", ("select": ("orderby": "id"), "block": 2));
        list data;
        while (*list l = recv.getDataRows())
            data += l;

        # do not compare sequence-generated-IDs here
        list refdata = dsomquser.selectRows("select * from regression_example order by id");
        test_value((map $1-"id", data), (map $1-"id", refdata), "DbRemoteReceive::select bulk");
    }

    # DbRemoteReceive select bulk columns with getData
    {
        UserApi::logDebug("DbRemoteReceive::select bulk columns with getData() test start");
        DbRemoteReceive recv(qrest, "omquser", "select", "regression_example", ("select": ("orderby": "id"), "block": 2));
        *hash data;
        while (*hash h = recv.getData()) {
            if (!data)
                map data.$1 = (), h.keyIterator();
            map data.$1 += h.$1, h.keyIterator();
        }

        list ldata = map $1 - "id", data.contextIterator();

        # do not compare sequence-generated-IDs here
        list refdata = dsomquser.selectRows("select * from regression_example order by id");
        test_value(ldata, (map $1-"id", refdata), "DbRemoteReceive::select bulk columns with getData()");
    }

    # DbRemoteReceive bulk DML select test 1 (block=1)
    {
        UserApi::logDebug("DbRemoteReceive::bulk DML select test 1 start");
        DbRemoteReceive recv(qrest, "omquser", "select", "regression_example", ("block": 1, "select": ("orderby": "id")));
        hash data = recv.getAllData() - "id";
        # do not compare sequence-generated-IDs here
        hash refdata = dsomquser.select("select * from regression_example order by id") - "id";
        test_value(data, refdata, "DbRemoteReceive::select bulk DML 1");
    }

    # DbRemoteReceive bulk DML select test 2 (block=2)
    {
        UserApi::logDebug("DbRemoteReceive::bulk DML select test 2 start");
        DbRemoteReceive recv(qrest, "omquser", "select", "regression_example", ("block": 2, "select": ("orderby": "id")));
        hash data = recv.getAllData() - "id";
        # do not compare sequence-generated-IDs here
        hash refdata = dsomquser.select("select * from regression_example order by id") - "id";
        test_value(data, refdata, "DbRemoteReceive::select bulk DML 2");
    }

    # DbRemoteReceive bulk DML select test 3 (block=default)
    {
        UserApi::logDebug("DbRemoteReceive::bulk DML select test 3 start");
        DbRemoteReceive recv(qrest, "omquser", "select", "regression_example", ("select": ("orderby": "id")));
        hash data = recv.getAllData() - "id";
        # do not compare sequence-generated-IDs here
        hash refdata = dsomquser.select("select * from regression_example order by id") - "id";
        test_value(data, refdata, "DbRemoteReceive::select bulk DML 3");
    }

    # DbRemoteReceive
    {
        UserApi::logDebug("DbRemoteReceive::select test 2 start");
        DbRemoteReceive recv(qrest, "omquser", "select", "regression_example", ("select": ("where": ("product_code": "SV300S37B/240G"), "orderby": "id")));
        list data = ();
        while (*softlist d = recv.getDataRows()) data += d;
        # do not compare sequence-generated-IDs here
        list refdata = dsomquser.selectRows("select * from regression_example where product_code = 'SV300S37B/240G' order by id");
        test_value((map $1-"id", data), (map $1-"id", refdata), "DbRemoteReceive::select 2");
    }

    # DbRemoteSend
    {
        UserApi::logDebug("DbRemoteSend::insert test start");
        DbRemoteSend out(qrest, "omquser", "insert", "regression_streams_target");
        on_error out.rollback();
        list refdata = dsomquser.selectRows("select * from regression_streams_target order by id");
        out.append(TestData);
        # explicit commit here for tests
        out.commit();
        list data = dsomquser.selectRows("select * from regression_streams_target order by id");
        test_value((map $1-"id", data), (map $1-"id", refdata+TestData), "DbRemoteSend::insert");
        # check counters
        test_value(out.getInfo().count, NOTHING, "DbRemoteSend::insert - count");
        test_value(out.getInfo().total_count, TestData.size(), "DbRemoteSend::insert - total_count");
    }

    # bulk upsert test
    {
        UserApi::logDebug("DbRemoteSend::bulk upsert test start");
        hash d1 = dsomquser.select("select * from regression_streams_target order by id");
        hash dnew = d1;
        dnew.store_code = map "XXX", xrange(d1.firstValue().size());

        {
            hash uopt = ("omit_update": "store_code", "upsert_strategy": AbstractTable::UpsertUpdateFirst);
            DbRemoteSend out(qrest, "omquser", "upsert", "regression_streams_target", uopt);
            on_error out.rollback();
            on_success out.commit();

            out.append(dnew);
        }

        hash d2 = dsomquser.select("select * from regression_streams_target order by id");
        test_value(d2, d2, "DbRemoteSend::bulk upsert");
    }

    # DbRemoteSend iterator stream test
    {
        UserApi::logDebug("DbRemoteSend::insert iterator test start");

        dsomquser.exec("delete from regression_streams_target");
        dsomquser.exec("delete from regression_example");
        dsomquser.commit();

        {
            DbRemoteSend out(qrest, "omquser", "insert", "regression_streams_target", ("block": 1));
            on_error out.rollback();
            on_success out.commit();

            out.append(TestData.iterator());
            out.openStream("insert", "regression_example");
            out.append(TestData.iterator());
        }

        list<auto> data = dsomquser.selectRows("select * from regression_streams_target order by id");
        test_value((map $1-"id", data), (map $1-"id", TestData), "DbRemoteSend::insert iterator 1");
        data = dsomquser.selectRows("select * from regression_example order by id");
        test_value((map $1-"id", data), (map $1-"id", TestData), "DbRemoteSend::insert iterator 2");
    }

    # DbRemoteSend negative stream test - unique constraint violated
    {
        UserApi::logDebug("DbRemoteSend::insert unique-constraint-violated test start");

        DbRemoteSend out(qrest, "omquser", "insert", "regression_streams_target");
        on_error out.rollback();
        list<auto> refdata = dsomquser.selectRows("select * from regression_streams_target order by id");

        try {
            out.append(refdata);
            out.commit();
            assert_eq(True, False);
        } catch (hash<ExceptionInfo> ex) {
            on_error UserApi::logInfo("%s", get_exception_string(ex));
            test_value(ex.desc =~ /ORA-00001/ || ex.desc =~ /duplicate key value/ || ex.desc =~ /^Duplicate entry /,
                True, "DbRemoteSend::insert unique-constraint-violated");
        }
    }

    AbstractTable rtt = UserApi::getSqlTable("omquser", "regression_streams_target", False);

    # DbRemoteReceive and InboundIdentityTableMapper test
    {
        UserApi::logDebug("InboundIdentityTableMapper test start");

        dsomquser.exec("delete from regression_streams_target");
        dsomquser.commit();

        DbRemoteReceive recv(qrest, "omquser", "select", "regression_example", ("select": ("orderby": "id")));

        {
            code info_log = sub (string msg) { UserApi::logInfo(vsprintf(msg, argv)); };
            code input_log = sub (hash h) { UserApi::logDebug("input: %y", h); };
            code output_log = sub (hash h) { UserApi::logDebug("output: %y", h); };
            # will perform bulk DML inserts where possible
            InboundIdentityTableMapper mmap(rtt, ("id": ("sequence": "seq_regression_example")), ("info_log": info_log, "output_log": output_log, "input_log": input_log));
            on_success mmap.commit();
            on_error mmap.rollback();

            while (*hash data = recv.getData())
                mmap.queueData(data);
        }

        list data = dsomquser.selectRows("select * from regression_streams_target order by id");
        test_value((map $1-"id", data), (map $1-"id", TestData), "InboundIdentityTableMapper 1");
        data = dsomquser.selectRows("select * from regression_example order by id");
        test_value((map $1-"id", data), (map $1-"id", TestData), "InboundIdentityTableMapper 2 (sanity)");
    }

    # DbRemoteReceive and BulkInsertOperation test
    if (!rtt.hasArrayBind()) {
        UserApi::logDebug("skipping BulkInsertOperation tests; bulk API not supported in driver");
    } else {
        UserApi::logDebug("BulkInsertOperation test start");

        dsomquser.exec("delete from regression_streams_target");
        dsomquser.commit();

        DbRemoteReceive recv(qrest, "omquser", "select", "regression_example", ("select": ("orderby": "id")));

        {
            code info_log = sub (string msg) { UserApi::logInfo(vsprintf(msg, argv)); };
            BulkInsertOperation insert(rtt, ("info_log": info_log));
            on_success insert.commit();
            on_error insert.rollback();

            while (*hash data = recv.getData())
                insert.queueData(data);
        }

        list data = dsomquser.selectRows("select * from regression_streams_target order by id");
        test_value((map $1-"id", data), (map $1-"id", TestData), "BulkInsertOperation");

        UserApi::logDebug("BulkUpsertOperation test start");

        data = map $1 + ("uuid": "deleted"), data;
        {
            code info_log = sub (string msg) { UserApi::logInfo(vsprintf(msg, argv)); };
            BulkUpsertOperation upsert(rtt, ("info_log": info_log));
            on_success upsert.commit();
            on_error upsert.rollback();

            upsert.queueData(data);
        }

        list new_data = dsomquser.selectRows("select * from regression_streams_target order by id");
        test_value(new_data, data, "BulkUpsertOperation");
    }

    {
        list refList = (
            ( "uuid_mapped" : "f0350061-001a-4477-9e02-abd7c740ce35", "some_const" : "foobar", "rtt": "file" ),
            # filtered out by a select hash ( "uuid_mapped" : "f0350062-001a-4477-9e02-abd7c740ce35", "some_const" : "foobar" ),
        );

        hash bind = ( "bind" : ("in_transit" : 5, "qorus_wfiid": 137083, ) );
        QorusSqlStatementOutboundMapper m = UserApi::getMapper("regression-out-sql-statement", bind);
        on_success m.commit();
        on_error m.rollback();

        list res = list();
        while (*list l = m.getDataRows()) {
            res += l;
        }
        test_value(refList, res, "QorusSqlStatementOutboundMapper::getDataRows");
    }

    {
        list refList = (
            ( "uuid_mapped" : "f0350061-001a-4477-9e02-abd7c740ce35", "some_const" : "foobar", "rtt": "UserApi::getMapper" ),
            # filtered out by a select hash ( "uuid_mapped" : "f0350062-001a-4477-9e02-abd7c740ce35", "some_const" : "foobar" ),
        );

        hash bind = ("bind" : ("in_transit" : 5, "qorus_wfiid": 137083, ), "runtime": ("runtime-test": "UserApi::getMapper"));
        QorusSqlStatementOutboundMapper m = UserApi::getMapper("regression-out-sql-statement", bind);
        on_success m.commit();
        on_error m.rollback();

        list res = list();
        while (*list l = m.getDataRows()) {
            res += l;
        }
        test_value(refList, res, "QorusSqlStatementOutboundMapper::getDataRows");
    }

    {
        # test for issue #2157
        # issue #2229: as a workaround for the fact that the mapper is normally invalid in qorus-core and only
        # valid when the schema is created, and the fact that mappers are created in each interface object,
        # we need to reset the mapper in qorus-core before reading the description
        UserApi::callRestApi("PUT", "mappers/regression-out-sql-statement/reload");
        string desc = UserApi::callRestApi("GET", "mappers/regression-out-sql-statement/options/input/uuid/desc");
        if (desc !~ /; test$/)
            UserApi::logInfo("desc: %y", desc);
        # ensure our description gets added to the end of the output description
        assert_eq(True, desc =~ /; test$/);
    }

    {
        list refList = (
            ( "uuid_mapped" : "f0350061-001a-4477-9e02-abd7c740ce35", "some_const" : "foobar" ),
            # filtered out by a select hash ( "uuid_mapped" : "f0350062-001a-4477-9e02-abd7c740ce35", "some_const" : "foobar" ),
        );

        hash bind = ( "bind" : (5, 137083,));
        QorusRawSqlStatementOutboundMapper m = UserApi::getMapper("regression-out-rawsql-statement", bind);
        on_success m.commit();
        on_error m.rollback();

        list res = list();
        while (*list l = m.getDataRows()) {
            res += l;
        }
        test_value(refList, res, "QorusRawSqlStatementOutboundMapper::getDataRows");
    }

    # DbRemoteSend negative tests - incorrect API usage
    {
        UserApi::logDebug("DbRemoteSend::insert incorrect API usage");
        DbRemoteSend out(qrest, "omquser", "insert", "regression_streams_target");
        on_error out.disconnect();
        *hash h = dsomquser.select("select * from regression_streams_target where id != id");
        #UserApi::logDebug("h: %N", h);
        out.append(h);
        map h.$1 = NOTHING, h.keyIterator();
        #UserApi::logDebug("h: %N", h);
        out.append(h);
        out.commit();
    }

    hash th = dsomquser.select("select * from regression_streams_target order by id");
    # DbRemoteSend negative stream test - invalid column on insert
    {
        UserApi::logDebug("DbRemoteSend::insert invalid column");
        DbRemoteSend out(qrest, "omquser", "insert", "regression_streams_target");
        on_exit out.disconnect();
        hash h = th;
        #UserApi::logInfo("h: %N", h);
        # create invalid column
        h.fname = remove h.filename;

        *string err;
        try {
            out.append(h);
            out.commit();
        } catch (hash<ExceptionInfo> ex) {
            #UserApi::logDebug(get_exception_string(ex));
            err = ex.err;
        }
        test_value(err, "COLUMN-ERROR", "DbRemoteSend::insert invalid column");
    }

    # DbRemoteSend negative stream test - invalid column on upsert
    {
        UserApi::logDebug("DbRemoteSend::upsert invalid column");
        DbRemoteSend out(qrest, "omquser", "upsert", "regression_streams_target", ("block": 1));
        # we need to disconnect if there's an error here to ensure that the thread resource is cleared
        # in this thread before continuing
        on_exit out.disconnect();
        hash h = th;
        #UserApi::logDebug("config: %N", out.config());
        # create invalid column
        h.fname = remove h.filename;

        *string err;
        hash<ExceptionInfo> ex;
        try {
            # keep sending the invalid row until we get an error
            while (True)
                out.append(h);
            out.commit();
        } catch (hash<ExceptionInfo> ex) {
            err = ex.err;
            if (!inlist(err, ("COLUMN-ERROR", "STREAM-TERMINATED", "IO-ERROR"))) {
                UserApi::logInfo("INVALID EXCEPTION: %s", get_exception_string(ex));
            }
        }
        test_value(inlist(err, ("COLUMN-ERROR", "STREAM-TERMINATED", "IO-ERROR")), True, "DbRemoteSend::upsert invalid column");
    }

    # DbRemoteSend negative stream test 2 - invalid column on mass upsert
    {
        UserApi::logDebug("DbRemoteSend::upsert invalid column 2");
        DbRemoteSend out(qrest, "omquser", "upsert", "regression_streams_target", ("block": 500));
        on_exit out.disconnect();
        hash h = th;
        #UserApi::logDebug("config: %N", out.config());
        # create invalid column
        h.fname = remove h.filename;

        *string err;
        try {
            # keep sending the invalid row until we get an error
            while (True)
                out.append(h);
            out.commit();
        } catch (hash<ExceptionInfo> ex) {
            #UserApi::logDebug("%s", get_exception_string(ex));
            err = ex.err;
        }
        test_value(inlist(err, ("COLUMN-ERROR", "STREAM-TERMINATED", "IO-ERROR", "SOCKET-SSL-ERROR")), True, "DbRemoteSend::upsert invalid column");
    }

    # DbRemoteSend update
    {
        UserApi::logDebug("DbRemoteSend::update");
        DbRemoteSend out(qrest, "omquser", "update", "regression_streams_target");
        on_error out.disconnect();

        hash h = ("set": (map ("filename": $1 + "X", "uuid": th.uuid[$#] + "Y"), th.filename), "cond": (map ("id": $1), th.id));
        #UserApi::logDebug("l: %N", h);
        out.append(h);
        out.commit();

        hash nth = dsomquser.select("select * from regression_streams_target order by id");

        map test_value($1.filename, h.set[$#].filename, "DbRemoteSend::update " + $#), nth.contextIterator();
        th = nth;
    }

    {
        *string err;
        try {
            DbRemoteReceive recv(qrest, "omquser", "select", "regression_example", ("where": ("id": -1)));
            on_error recv.disconnect();
            recv.getAllData();
            recv.commit();
        } catch (hash<ExceptionInfo> ex) {
            #UserApi::logDebug(get_exception_string(ex));
            err = ex.err;
        }
        test_value(err, "SQLUTIL-ERROR", "DbRemoteSend::invalid commit");
    }

    # stream API error test - invalid socket operation while stream is in progress
    {
        UserApi::logDebug("DbRemoteSend::select socket error");
        DbRemoteReceive recv(qrest, "omquser", "select", "regression_example", ("where": ("id": -1)));
        on_error recv.disconnect();
        on_success recv.getAllData();

        *string err;
        try {
            DbRemote db(qrest, "omquser");
            db.select("regression_streams_target");
        } catch (hash<ExceptionInfo> ex) {
            #UserApi::logDebug(get_exception_string(ex));
            err = ex.err;
        }
        test_value(err, "STREAM-ERROR", "stream API error");
    }

    # test for bug 1579: the DbRemote class throws an extraneous exception in the destructor when DbRemote::rollback() is called with no argument or with DO_DISCONNECT
    {
        UserApi::logDebug("bug-1579");
        try {
            DbRemote db(qrest, "omquser");
            db.beginTransaction();
            db.rollback();
            test_value(True, True, "bug-1579");
        } catch (hash<ExceptionInfo> ex) {
            #UserApi::logDebug(get_exception_string(ex));
            test_value(ex.err, NOTHING, "bug-1579");
        }
    }

    bug_1388(qrest);

    UserApi::logDebug("sqlutil_tests end");
}

sub bug_1388(QorusSystemRestHelper qrest) {
    # stream API error test - reset the sqlutil service during a persistent connection
    UserApi::logDebug("bug_1388 service reset during transaction");
    # this receive is probably too fast
    DbRemote db(qrest, "omquser");
    on_exit UserApi::callRestApi("PUT", "workflows/SQLUTIL-RESET/stop");
    on_error {
        UserApi::logDebug("bug_1388 transaction rollback started");
        db.rollback();
        UserApi::logDebug("bug_1388 transaction rolled back");
    }
    on_success {
        UserApi::logDebug("bug_1388 transaction commit started");
        db.commit();
        UserApi::logDebug("bug_1388 transaction commited");
    }

    db.select("regression_streams_target");

    stop_workflow("SQLUTIL-RESET");

    # start the SQLUTIL-RESET workflow
    int id = UserApi::callNetworkApi("omq.system.start-workflow", ("name": "SQLUTIL-RESET")).id;
    test_value(id > 0, True, "bug-1388-1");

    date start = now_us();
    hash<auto> h = {
        "staticdata": {"test": True},
    };
    int wfiid = UserApi::createOrder("SQLUTIL-RESET", NOTHING, h);
    UserApi::logInfo("created SQLUTIL-RESET wfiid: %d", wfiid);

    # wait for workflow to block
    while (True) {
        *string stepstatus = UserApi::callRestApi("GET", "orders/" + wfiid + "/StepInstances")[0].stepstatus;
        if (stepstatus == OMQ::StatInProgress) {
            break;
        }
        date delta = now_us() - start;
        if (delta > 20s) {
            throw "TIMEOUT-ERROR", sprintf("waited %y for step to start for issue 1388 test", delta);
        }
        UserApi::usleep(50ms);
    }
}

sub table_cache_tests() {
    AbstractTable t1 = UserApi::getSqlTable("omquser", "regression_example", False);
    DatasourcePool dsp = UserApi::getDatasourcePool("omquser", False);
    AbstractTable t2 = UserApi::getSqlTable(dsp, "regression_example", False);
    if (t1 != t2) {
        printf("t1: %y: %y t2: %y %y", t1.getName(), t1.uniqueHash(), t2.getName(), t2.uniqueHash());
    }
    test_value(t1.uniqueHash(), t2.uniqueHash(), "sql-table-cache-1");

    *hash<auto> h = UserApi::getSqlCacheInfo();
    #UserApi::logDebug("sql cache: %N", h);
    # the SQL cache is now distributed; we can't expect the qorus-core server count value to be > 1
    test_value(h.omquser.tables.regression_example.count > 0, True, "sql-table-cache-2");

    try {
        t1 = UserApi::getSqlTable("omq", "workflows");
    } catch (hash<ExceptionInfo> ex) {
        test_value(ex.err, "DATASOURCE-ERROR", "neg-sql-table-cache-1");
    }
}

sub bug_815() {
    # make sure all instances of DUMMY-TEST are stopped
    stop_workflow("DUMMY-TEST");

    # start the DUMMY-TEST workflow
    int id = UserApi::callNetworkApi("omq.system.start-workflow", ("name": "DUMMY-TEST")).id;
    test_value(id > 0, True, "815-dummy-start-1");

    # make sure all instances of DUMMY-TEST are stopped
    stop_workflow("DUMMY-TEST");

    id = UserApi::callNetworkApi("omq.system.start-workflow", ("name": "DUMMY-TEST")).id;
    test_value(id > 0, True, "815-dummy-start-2");
}

sub bug_1545(QorusSystemRestHelper qrest) {
    # make sure all instances of DS-TEST are stopped
    stop_workflow("DS-TEST");

    # start the DS-TEST workflow
    int id = UserApi::callNetworkApi("omq.system.start-workflow", ("name": "DS-TEST")).id;
    test_value(id > 0, True, "1545-ds-test-1");

    hash h = ("staticdata": ("test": True),);
    int wfiid = UserApi::createOrder("DS-TEST", NOTHING, h);
    UserApi::logInfo("created DS-TEST wfiid: %d", wfiid);

    # should wait for ds_test_lock_table to sleep
    UserApi::logInfo("sleeping ...");
    UserApi::sleep(2s);
    UserApi::logInfo("... woken up, sending cache reset");

    #any ret = qrest.put("system/sqlcache/clear", ("datasource" : "omquser", "name" : "ds_test1"));
    any ret = qrest.put("remote/datasources/omquser/reset");

    UserApi::logInfo("cache reset request sent: %y", ret);

    int wfiid2 = UserApi::createOrder("DS-TEST", NOTHING, h);
    UserApi::logInfo("new order created DS-TEST wfiid: %d", wfiid);

    # make sure all instances of DS-TEST are stopped
    wait_for_status("1545-ds-test-2", wfiid);
    wait_for_status("1545-ds-test-3", wfiid2);
    stop_workflow("DS-TEST");
    UserApi::logInfo("bug_1545 finished");
}

sub bug_342() {
    try {
        # only log on Solaris 8 because the bug should only affect that arch
        if (get_qore_library_info().BuildHost =~ /SunOS .* 5.8/)
            UserApi::logInfo("about to test libxml2 crashing bug with error handling...");

        # if this test fails, Qorus will crash...
        auto ignored = parseXML("<AAA>aaa&aaa</AAA>");
        remove ignored;
    } catch (hash<ExceptionInfo> ex) {
        test_value(True, True, "bug-342");
    }
}

sub schedule2_test() {
    # start the DUMMY-TEST workflow
    int id = UserApi::callNetworkApi("omq.system.start-workflow", ("name": "DUMMY-TEST")).id;
    test_value(id > 0, True, "start-workflow-5");

    # create 2 DUMMY-TEST orders with different (low) priorities; scheduled 1 hour in the future
    hash h = ("staticdata": ("test": True), "scheduled": now() + 1h, "priority": 900);
    int wfiid = UserApi::createOrder("DUMMY-TEST", NOTHING, h);
    UserApi::logInfo("created DUMMY-TEST wfiid: %d (prio 900)", wfiid);

    h.priority = 905;
    int wfiid2 = UserApi::createOrder("DUMMY-TEST", NOTHING, h);
    UserApi::logInfo("created DUMMY-TEST wfiid: %d (prio 905)", wfiid2);

    h = omqservice.system.info.getWorkflowStatus2(wfiid);
    test_value(h.workflowstatus, OMQ::StatScheduled, "getWorkflowStatus2-7");
    test_value(h.priority, 900, "getWorkflowStatus2-8");

    h = omqservice.system.info.getWFIAllInfo(wfiid2);
    test_value(h.InstanceInfo.workflowstatus, OMQ::StatScheduled, "getWFIAllInfo-7");
    test_value(h.InstanceInfo.priority, 905, "getWFIAllInfo-8");

    # change priority and retest
    string ok = UserApi::callNetworkApi("omq.system.reprioritize-order", wfiid, 10);
    test_value(ok, "OK", "reprioritize-order-1");

    ok = UserApi::callNetworkApi("omq.system.reprioritize-order", wfiid2, 5);
    test_value(ok, "OK", "reprioritize-order-2");

    h = omqservice.system.info.getWorkflowStatus2(wfiid);
    test_value(h.workflowstatus, OMQ::StatScheduled, "getWorkflowStatus2-9");
    test_value(h.priority, 10, "getWorkflowStatus2-10");

    h = omqservice.system.info.getWFIAllInfo(wfiid);
    test_value(h.InstanceInfo.workflowstatus, OMQ::StatScheduled, "getWFIAllInfo-9");
    test_value(h.InstanceInfo.priority, 10, "getWFIAllInfo-10");

    h = omqservice.system.info.getWorkflowStatus2(wfiid2);
    test_value(h.workflowstatus, OMQ::StatScheduled, "getWorkflowStatus2-11");
    test_value(h.priority, 5, "getWorkflowStatus2-12");

    h = omqservice.system.info.getWFIAllInfo(wfiid2);
    test_value(h.InstanceInfo.workflowstatus, OMQ::StatScheduled, "getWFIAllInfo-11");
    test_value(h.InstanceInfo.priority, 5, "getWFIAllInfo-12");

    # set scheduled date to now + 2s
    date sched = now_us() + 2s;

    ok = UserApi::callNetworkApi("omq.system.reschedule-order", wfiid2, sched);
    test_value(ok, "OK", "reschedule-order-4");
    ok = UserApi::callNetworkApi("omq.system.reschedule-order", wfiid, sched);
    test_value(ok, "OK", "reschedule-order-5");

    # wait until the first order has status COMPLETE
    wait_for_status("reschedule-1", wfiid);

    # get "test1" date from dynamic data from the first order
    date s1 = omqservice.system.info.getWFIAllInfo(wfiid).OrderInfo.dynamicdata.test1;

    # wait until the second order has status COMPLETE
    wait_for_status("reschedule-2", wfiid2);

    # get "test1" date from dynamic data from the second order
    date s2 = omqservice.system.info.getWFIAllInfo(wfiid2).OrderInfo.dynamicdata.test1;

    # make sure the second order was processed first due to the higher priority
    UserApi::logInfo("%s: %y, %s: %y", wfiid, s1, wfiid2, s2);
    test_value(s1 >= s2, True, "reprioritize-order-3");

    # stop all instances of DUMMY-TEST
    stop_workflow("DUMMY-TEST");
}

int sub priority_test() {
    # create a non-cached DUMMY-TEST order with a low priority
    hash h = ("staticdata": ("test": True), "priority": 990);
    int wfiid = UserApi::createOrder("DUMMY-TEST", NOTHING, h);
    UserApi::logInfo("created DUMMY-TEST wfiid: %d", wfiid);

    h = omqservice.system.info.getWorkflowStatus2(wfiid);
    test_value(h.workflowstatus, OMQ::StatReady, "getWorkflowStatus2-11");
    test_value(h.priority, 990, "getWorkflowStatus2-12");

    h = omqservice.system.info.getWFIAllInfo(wfiid);
    test_value(h.InstanceInfo.workflowstatus, OMQ::StatReady, "getWFIAllInfo-13");
    test_value(h.InstanceInfo.priority, 990, "getWFIAllInfo-14");

    # change priority and retest
    string ok = UserApi::callNetworkApi("omq.system.reprioritize-order", wfiid, 15);
    test_value(ok, "OK", "reprioritize-order-4");

    h = omqservice.system.info.getWorkflowStatus2(wfiid);
    test_value(h.workflowstatus, OMQ::StatReady, "getWorkflowStatus2-13");
    test_value(h.priority, 15, "getWorkflowStatus2-14");

    h = omqservice.system.info.getWFIAllInfo(wfiid);
    test_value(h.InstanceInfo.workflowstatus, OMQ::StatReady, "getWFIAllInfo-15");
    test_value(h.InstanceInfo.priority, 15, "getWFIAllInfo-16");

    # start the DUMMY-TEST workflow
    int id = UserApi::callNetworkApi("omq.system.start-workflow", ("name": "DUMMY-TEST")).id;
    test_value(id > 0, True, "start-workflow-6");

    # wait until order has status COMPLETE
    wait_for_status("reprioritize-1", wfiid);

    return id;
}

sub bug_278(int id, QorusSystemRestHelper qrest) {
    # BUG 278: create a DUMMY-TEST order with status BLOCKED
    hash h = ("staticdata": ("test": True, "temptest": True), "priority": 1);
    int wfiid = UserApi::createOrder("DUMMY-TEST", NOTHING, h, OMQ::StatBlocked);
    UserApi::logInfo("created DUMMY-TEST (BLOCKED) wfiid: %d", wfiid);

    h = omqservice.system.info.getWorkflowStatus2(wfiid);
    test_value(h.workflowstatus, OMQ::StatBlocked, "getWorkflowStatus2-15");
    test_value(h.priority, 1, "getWorkflowStatus2-16");

    h = omqservice.system.info.getWFIAllInfo(wfiid);
    test_value(h.InstanceInfo.workflowstatus, OMQ::StatBlocked, "getWFIAllInfo-17");
    test_value(h.InstanceInfo.priority, 1, "getWFIAllInfo-18");

    # ensure DUMMY-TEST workflow is still running
    h = UserApi::getRunningWorkflowInfo(id);
    #UserApi::logInfo("id=%y info=%y", id, h);
    test_value(elements h > 0, True, "getRunningWorkflowInfo-1");

    # BUG 279, 280: unblock workflow order
    # bug 877: unblock with API call and provide tempdata
    # feature 1303: and new order keys
    h = UserApi::unblockOrder(wfiid, ("test": True), ("test1": wfiid));
    #h = UserApi::callNetworkApi("omq.system.block-workflow-instance", wfiid, False);
    test_value(h.workflow_status, OMQ::StatReady, "unblock-1");

    # wait until order has status COMPLETE
    wait_for_status("unblock-status-1", wfiid, OMQ::StatComplete, OMQ::StatError);

    # check order keys
    h = qrest.get("orders/" + wfiid + "/keys");
    test_value(h, ("test1": wfiid.toString()), "unblock with order key update");

    # stop all instances of DUMMY-TEST
    stop_workflow("DUMMY-TEST");
}

sub bug_287_290_351() {
    # BUG 287: detach function test
    hash si = WorkflowApi::getStepInfo();
    test_value(si.eventtype, "regression-test", "getStepInfo-1");

    # get new event key
    string key = UUID::get();
    UserApi::logInfo("using event key %y", key);

    hash h = (
        "name": "DETACH-TEST",
        "orderdata": ("status": OMQ::StatError, "event": ("type": si.eventtype, "key": key)),
        "orderkeys": ("key3": "test"),
        );

    h = UserApi::callNetworkApi("omq.system.exec-synchronous-workflow", h);
    UserApi::logInfo("created DETACH-TEST (ERROR) wfiid: %d", h.workflow_instanceid);
    test_value(h.status, OMQ::StatError, "detach-1");
    softstring wfiid = h.workflow_instanceid;

    # BUG 290: start DETACH-TEST, block order, and then unblock order
    int id = UserApi::callNetworkApi("omq.system.start-workflow", ("name": "DETACH-TEST")).id;
    test_value(id > 0, True, "start-workflow-7");

    h = UserApi::callNetworkApi("omq.system.block-workflow-instance", wfiid);
    test_value(h.workflow_status, OMQ::StatBlocked, "block-1");

    # issue #2948: BLOCKED orders can be canceled
    assert_eq(("unBlock", "cancel"), UserApi::callRestApi("GET", "orders/" + wfiid + "/actions"));

    h = UserApi::callNetworkApi("omq.system.block-workflow-instance", wfiid, False);
    test_value(h.workflow_status, OMQ::StatError, "unblock-2");

    # make sure all instances of DETACH-TEST are stopped
    stop_workflow("DETACH-TEST");

    # BUG 287: bind event and then cancel DETACH-TEST workflow
    UserApi::bindEvent(key);

    # issue #3209: wait for qwf process to stop running before calling cancel
    # we want to test running the detach function in qorus-core
    {
        hash<auto> wfh = UserApi::callRestApi("GET", "workflows/DETACH-TEST");
        if (wfh.process.pid) {
            string proc_id = sprintf("qwf-DETACH-TEST-v%s-%d", wfh.version, wfh.workflowid);
            wait_for_process_not_pid(proc_id, wfh.process.pid);
        }
    }

    # BUG 287: now cancel DETACH-TEST order to allow this workflow to go to COMPLETE (our workflow event is posted in DETACH-TEST's detach function)
    h = UserApi::callNetworkApi("omq.system.cancel-workflow-instance", wfiid);
    test_value(h.workflow_status, OMQ::StatCanceled, "cancel-1");

    # BUG 351: not possible to set order keys with network API exec-synchronous-workflow
    # test if key3 set in initial call to exec-synchronous-workflow
    h = omqservice.system.info.getOrderInfo(wfiid);
    test_value(h.keys.key3, "test", "bug-351");
}

const hello_str = "hello";

sub http_tests(string url) {
    # http service binding test
    omqservice.user."http-test".init();
    string url = omqservice.user."http-test".url();
    UserApi::logInfo("got url %y", url);
    HTTPClient hc({
        "url": url,
    });
    hash h = hc.send(NOTHING, "GET", "/");
    test_value(h.body, "OK", "http-test-1");

    # bug 385: service binding to the global HTTP listeners is not working
    if (url =~ /:.*@/)
        UserApi::logInfo("using local system url: %y", url);
    HTTPClient hc2({
        "url": url,
    });
    h = hc2.send(NOTHING, "GET", "http-test");
    test_value(h.body, "OK", "http-test-2");

    h = hc2.send(NOTHING, "GET", "/", ("QORUS-TEST": "yes"));
    test_value(h.body, "OK", "http-test-3");

    h = hc2.send(NOTHING, "GET", "/", ("Content-Type": "x-qorus-misc"));
    test_value(h.body, "OK", "http-test-4");

    string ok = UserApi::callNetworkApi("omq.user.delete-service", "http-test");
    test_value(ok, "OK", "stop-service-1");

    try {
        hc.disconnect();
        h = hc.send(NOTHING, "GET", "/");
        test_value(False, True, "negative http-test-1");
    } catch (hash<ExceptionInfo> ex) {
        test_value(True, True, "negative http-test-1");
    }

    try {
        h = hc2.send(NOTHING, "GET", "http-test", ("Content-Type": "x-qorus-misc"));
        test_value(h.body != "OK", True, "negative http-test-2");
    } catch (hash<ExceptionInfo> ex) {
        test_value(True, True, "negative http-test-2");
    }

    try {
        h = hc2.send(NOTHING, "GET", "http-test");
        test_value(h.body != "OK", True, "negative http-test-3");
    } catch (hash<ExceptionInfo> ex) {
        test_value(True, True, "negative http-test-3");
    }
}

sub ftp_tests() {
    # ftp service binding test
    *string dir = UserApi::propGet("ftp-test", "dir");
    on_exit UserApi::propUpdate("ftp-test", "dir", dir);

    string key = UUID::get();

    string tmp = (UserApi::propGet("regression-test", "tmpdir") ?? tmp_location()) + DirSep;

    string tmp_dir = tmp + key;
    int rc = mkdir(tmp_dir, 0755);
    test_value(rc, 0, "mkdir-1");
    UserApi::logInfo("created temporary directory %y", tmp_dir);

    on_exit {
        rc = rmdir(tmp_dir);
        test_value(rc, 0, "rmdir-1");
        UserApi::logInfo("removed temporary directory %y", tmp_dir);
    }

    #UserApi::logDebug("tmp_dir=%y", tmp_dir);
    UserApi::propUpdate("ftp-test", "dir", tmp_dir);
    string tdir = UserApi::propGet("ftp-test", "dir");
    test_value(tdir, tmp_dir, "prop-get-1");
    tdir = UserApi::propGet("ftp-test", "dir");
    test_value(tdir, tmp_dir, "prop-get-2");
    test_value(UserApi::propGet("ftp-test").dir, tmp_dir, "prop-get-3");
    test_value(UserApi::propGet().omq.type(), Type::Hash, "prop-get-4");

    # make sure service is stopped
    try { UserApi::callNetworkApi("omq.user.delete-service", "ftp-test"); } catch () {}

    omqservice.user."ftp-test".init();
    # test #2288
    {
        string type = UserApi::callRestApi("GET", "services/ftp-test/remote") ? Type::Hash : Type::NothingType;
        assert_eq(type, UserApi::callRestApi("GET", "services/ftp-test/processes")[0].type());
    }

    # get hostname
    string url = UserApi::qorusGetLocalUrl();
    hash<auto> url_info = parse_url(url);

    # get port
    int port = omqservice.user."ftp-test".port();

    url = sprintf("ftp://user:password@%s:%d", url_info.host, port);
    FtpClient fc(url);
    fc.setNetworkFamily(AF_INET);
    UserApi::logInfo("cwd: %s", fc.pwd());
    fc.mkdir("tmp");
    {
        on_exit fc.rmdir("tmp");

        fc.cwd("tmp");
        {
            on_exit fc.cwd("/");

            fc.putData(hello_str, "hello.txt");
            on_exit fc.del("hello.txt.tmp");
            string hello = fc.getAsString("hello.txt.tmp");
            test_value(hello, hello_str, "ftp-put-get-1");
        }
    }

    string ok = UserApi::callNetworkApi("omq.user.delete-service", "ftp-test");
    test_value(ok, "OK", "stop-service-2");
}

sub bug_302() {
    # save current "cache-max" option
    int cache_max = UserApi::getOption("cache-max");

    # set cache-max to 0 and reset on exit
    UserApi::callNetworkApi("omq.system.set-option", ("cache-max": 0));
    on_exit UserApi::callNetworkApi("omq.system.set-option", ("cache-max": cache_max));

    hash h = ("name": "DETACH-TEST",
              "orderdata": ("status": OMQ::StatError,
                            "skip-logic": True));

    h = UserApi::callNetworkApi("omq.system.exec-synchronous-workflow", h);
    UserApi::logInfo("created DETACH-TEST (ERROR) wfiid: %d", h.workflow_instanceid);

    softstring wfiid = h.workflow_instanceid;

    test_value(h.status, OMQ::StatError, "detach-2");

    # get workflow version for next call
    h = omqservice.system.info.getWorkflowStatus2(wfiid);

    # get stepid of first DETACH-TEST step
    h = omqservice.system.info.getWorkflowMetadataFromName2("DETACH-TEST", h.version)."DETACH-TEST"{h.version};
    softstring stepid = h.steps[0].stepid;

    # raise priority to make sure order is processed first
    UserApi::callNetworkApi("omq.system.reprioritize-order", wfiid, 1);

    # lower priority on error
    on_error UserApi::callNetworkApi("omq.system.reprioritize-order", wfiid, OMQ::DefaultOrderPriority);

    # make sure all instances of DETACH-TEST are stopped
    stop_workflow("DETACH-TEST");

    # start one instance of DETACH-TEST with special options
    int id = UserApi::callNetworkApi("omq.system.start-workflow", ("name": "DETACH-TEST")).id;
    test_value(id > 0, True, "start-workflow-8");

    # make sure all instances of DETACH-TEST are stopped
    on_exit stop_workflow("DETACH-TEST");

    # call skip-step on the step
    UserApi::callNetworkApi("omq.system.skip-step", wfiid, stepid);

    # wait until order has status COMPLETE
    wait_for_status("bug-302-1", wfiid, OMQ::StatComplete, OMQ::StatError);

    # now test with skip-step-without-retry
    h = ("name": "DETACH-TEST",
         "orderdata": ("status": OMQ::StatError,
                       "skip-logic": True));

    h = UserApi::callNetworkApi("omq.system.exec-synchronous-workflow", h);
    UserApi::logInfo("created DETACH-TEST (ERROR) wfiid: %d", h.workflow_instanceid);

    wfiid = h.workflow_instanceid;

    test_value(h.status, OMQ::StatError, "detach-3");

    # get workflow version for next call
    h = omqservice.system.info.getWorkflowStatus2(wfiid);

    # raise priority to make sure order is processed first
    UserApi::callNetworkApi("omq.system.reprioritize-order", wfiid, 1);

    # call skip-step-without-retry on the step
    UserApi::callNetworkApi("omq.system.skip-step-without-retry", wfiid, stepid);

    # make sure workflow order is not cached
    while (True) {
        string str = UserApi::callNetworkApi("omq.system.debug.get-workflow-entry", wfiid);
        if (strlen(str) < 20)
            break;
    }

    # call retry-workflow-instance on the order
    h = UserApi::callNetworkApi("omq.system.retry-workflow-instance", wfiid);
    test_value(h.workflow_status, OMQ::StatRetry, "retry-1");

    # wait until order has status COMPLETE
    wait_for_status("bug-302-2", wfiid, OMQ::StatComplete, OMQ::StatError);
}

const MultiReq = (
    "OrderNumber": "TEST-123",
    "DealerCode": "DEALER-1",
    "IsUpdate": False,
    "IsCancelled": False,
    "IsGiftWrapped": False,
    "ShipToStore": True,
    "GiftWrapped": False,
    "DeliveryType": "TEST",
    "EmailAddress": "test@test.com",
    "ContactNumber": "+420 777 279 144",
    "Name": (
        "FirstName": "Testie",
        "LastName": "O'Test",
    ),
    "DeliveryAddress": (
        "AddressLine1": "Kladska 5/1489",
        "AddressLine2": "120 00",
        "AddressLine3": "Prague",
        "AddressLine4": "",
        "County": "Prague",
        "Country": "Czech Republic",
    ),
    "InvoiceAddress": (
        "AddressLine1": "Kladska 5/1489",
        "AddressLine2": "120 00",
        "AddressLine3": "Prague",
        "AddressLine4": "",
        "County": "Prague",
        "Country": "Czech Republic",
    ),
    "OrderGrossPrice": 149.99n,
    "OrderDiscount": 0.00n,
    "OrderNetPrice": 130.00n,
    "OrderItem": (
        "Price": 130.00n,
        "FTC": True,
    ),
);

const MultiResp = (
    "OrderNumber": "16685422",
    "ReceiptAck": (
        "RequestStatus": "Success",
        "ErrorInfo": NOTHING,
    ),
);

sub soap_tests(string url) {
    # start simple SOAP service
    omqservice.user.simple.init();
    UserApi::logInfo("started simple service");
    on_exit {
        string ok = UserApi::callNetworkApi("omq.user.delete-service", "simple");
        test_value(ok, "OK", "stop-soap-service");
    }

    #if (url =~ /:.*@/)
    UserApi::logInfo("system URL: %y", url);
    string wsdl = url + "/SOAP/simple_test?wsdl";

    # create the SoapClient object
    SoapClient sc({
        "wsdl": wsdl,
        "url": url + "/SOAP/simple_test",
    });

    # setup SOAP call with multipart response
    hash h.body.tickerSymbol = "QORE";
    # make SOAP call with multipart response
    hash response = sc.call("getCompanyInfo", h);

    test_value(response.body.result, 99.9, "soap-multipart-response-1", is_alpine_and_oracle());
    test_value(type(response.docs), Type::String, "soap-multipart-response-2");
    test_value(type(response.logo), Type::Binary, "soap-multipart-response-3");

    # setup SOAP call with multipart request
    h = {
        "body": {"name": "QORE", "id": 500},
        "logo": response.logo,
    };
    # make SOAP call with multipart request
    string rv = sc.call("setCompanyLogo", h);
    test_value(rv, "OK", "soap-multipart-request-1");

    # start multi-soap SOAP service
    omqservice.user."multi-soap".init();

    on_exit {
        string ok = UserApi::callNetworkApi("omq.user.delete-service", "multi-soap");
        test_value(ok, "OK", "stop-multi-soap-service");
    }

    # substitute target port
    {
        *hash<auto> sp = UserApi::propGet("multi-soap");
        softint bind = sp.bind ? sp.bind : 9999;
        # do not substitute if the URL is based on a UNIX domain socket
        if (url =~ /socket=/) {
            url = sprintf("http://" + parse_url(url).host + ":%d", bind);
            wsdl = url + "/SOAP/ExampleSendOrder?wsdl";
        } else {
            # use HTTP URL in all cases
            url =~ s/^https/http/;
            wsdl = url + "/SOAP/ExampleSendOrder?wsdl";
            url = regex_subst(url, ":[0-9]+", ":" + bind.toString());
            wsdl = regex_subst(wsdl, ":[0-9]+", ":" + bind.toString());
        }
        if (url =~ /:.*@/) {
            UserApi::logInfo("using url %y for multi-soap; wsdl: %y", url, wsdl);
        }
    }

    # create the SoapClient object
    UserApi::logInfo("wsdl: %y url: %y", wsdl, url);
    sc = new SoapClient(("wsdl": wsdl, "url": url));

    hash<auto> answer = sc.Send(("OrderRequests": ("OrderRequest": MultiReq), "swaBinary": NOTHING));
    test_value((remove answer.ReceiptAck.OriginalTXID).typeCode(), NT_STRING, "multi-soap-1");
    test_value((remove answer.Timestamp).typeCode(), NT_STRING, "multi-soap-2");
    test_value(answer, MultiResp, "multi-soap-3");
}

sub bug_324() {
    omqservice.user."http-test".startSingleSleeper();
    string ok = UserApi::callNetworkApi("omq.user.delete-service", "http-test");
    test_value(ok, "OK", "stop-sleeping-service-1");

    omqservice.user."http-test".startErrorSleeper();
    ok = UserApi::callNetworkApi("omq.user.delete-service", "http-test");
    test_value(ok, "OK", "stop-sleeping-service-2");
}

sub bug_356() {
    hash h."" = "a";
    test_value(type(makeXMLRPCValueString(h)), Type::String, "bug-356");
}

sub bug_368() {
    hash h = UserApi::callNetworkApi("omq.system.job.run", "test");
    test_value(exists h, True, "bug-368");
}

sub bug_511() {
    # save some dynamic data to then delete it
    WorkflowApi::updateDynamicData(("k1": 1, "k2": 2, "k3": 3, "k4": 4));
    WorkflowApi::deleteDynamicDataKey("k1");
    test_value(WorkflowApi::getDynamicData("k1"), NOTHING, "bug-511-1");
    WorkflowApi::deleteDynamicDataKey(("k2", "k3"));
    test_value(WorkflowApi::getDynamicData(("k2", "k3")), hash(), "bug-511-2");
    test_value(WorkflowApi::getDynamicData("k4"), 4, "bug-511-3");
}

sub bug_544() {
    try {
        omqservice.user."http-test".reset();
        test_value(True, False, "bug-544");
    } catch (hash<ExceptionInfo> ex) {
        test_value(ex.err, "SERVICE-DEADLOCK-ERROR", "bug-544");
    }
}

sub bug_548_549() {
    test_value(string(10.2n), "10.2", "bug-548");

    AbstractDatasource ds = UserApi::getDatasourcePool("omquser");
    switch (ds.getDriverName()) {
        case "oracle": {
            test_value(ds.selectRow("select 10.2 as val from dual").val, 10.2n, "bug-549");
            break;
        }
        case "mysql":
        case "pgsql": {
            test_value(ds.selectRow("select 10.2 as val").val, 10.2n, "bug-549");
            break;
        }
    }

    # also make sure YAML, XML-RPC, and JSON-RPC can serialize "number" values
    test_value(parseYAML(makeYAML(10.2n)), 10.2n, "yaml-number");
    # only yaml also returns a "number" type
    test_value(parseJSON(makeJSONString(10.2n)), 10.2, "json-number", is_alpine_and_oracle());
    test_value(parseXMLRPCValue(makeXMLRPCValueString(10.2n)), 10.2, "xmlrpc-number", is_alpine_and_oracle());
}

sub bug_785() {
    # start one instance of ATTACH-ERROR
    int id = UserApi::callNetworkApi("omq.system.start-workflow", ("name": "ATTACH-ERROR")).id;
    test_value(id > 0, True, "start-attach-error");

    # make sure all instances of ATTACH-ERROR are stopped on exit
    on_exit
        stop_workflow("ATTACH-ERROR");

    # create an ATTACH-ERROR order
    hash h = ("staticdata": ("test": True));
    # check backwards-compatible call for UserApi::createOrder()
    softint wfiid = UserApi::createOrder("ATTACH-ERROR", NOTHING, h);
    UserApi::logInfo("created ATTACH-ERROR wfiid: %d", wfiid);

    # cancel the wf on exit
    on_exit
        UserApi::callNetworkApi("omq.system.cancel-workflow-instance", wfiid);

    # wait until order has status ERROR
    wait_for_status("bug-785-1", wfiid, OMQ::StatError, OMQ::StatComplete);

    # call retry-workflow-instance on the order
    h = UserApi::callNetworkApi("omq.system.retry-workflow-instance", wfiid);
    test_value(h.workflow_status, OMQ::StatRetry, "bug-785-retry");

    # wait until order has status ERROR
    wait_for_status("bug-785-2", wfiid, OMQ::StatError, OMQ::StatComplete);
}
# END

# type: GENERIC
# version: 1.0
# desc: regression test workflow library functions
# name: regression-lib
# author: Qore Technologies, s.r.o.
%new-style
%require-types
sub test_value(auto v1, auto v2, string msg, bool use_number_eq = False) {
    if ((use_number_eq && abs(v1 - v2) <  0.0000000001) || (!use_number_eq && v1 == v2)) {
        UserApi::logInfo("OK: %s", msg);
        return;
    }

    string err = sprintf("ERROR: %s test failed! (%N != %N)", msg, v1, v2);
    UserApi::logInfo(err);
    throw "ERROR", err;
}

string sub get_location() {
    hash<CallStackInfo> h = UserApi::get_thread_call_stack()[3];
    return sprintf("%s:%d", h.file, h.line + h.offset);
}

sub assert_throws(string err, *string errDesc, code theCode, *softlist args, *string label) {
    string desc = "assert_throws()";
    if (label)
        desc += ": " + label;
    desc += ": " + get_location();
    try {
        call_function_args(theCode, args);
        test_value(NOTHING, sprintf("expected exception: %y", err), desc);
    } catch (hash<auto> ex) {
        if (ex.err !== err) {
            throw "ERROR", sprintf("ERROR: assert_throws() failed %y != %y: %s", err, ex.err, ex.desc);
        }
        if (errDesc != NOTHING && !ex.desc.regex(errDesc)) {
            throw "ERROR", sprintf("ERROR: assert_throws() failed %y !~ %y (%s)", errDesc, ex.desc, ex.err);
        }
        test_value(ex.err, err, desc);
    }
}

sub assert_throws(string err, code theCode, *softlist args, *string label) {
    assert_throws(err, NOTHING, theCode, args, label);
}

sub assert_ge(auto v1, auto v2, *string label) {
    string desc = "assert_ge()";
    if (label) {
        desc += ": " + label;
    }
    desc += ": " + get_location();
    if (v2 >= v1) {
        UserApi::logInfo("OK: %s", desc);
        return;
    }
    string err = sprintf("ERROR: %s test failed! (%N != %N)", desc, v1, v2);
    UserApi::logInfo(err);
    throw "ERROR", err;
}

sub assert_eq(auto v1, auto v2, *string label) {
    string desc = "assert_eq()";
    if (label) {
        desc += ": " + label;
    }
    desc += ": " + get_location();
    test_value(v2, v1, desc);
}

sub assert_neq(auto v1, auto v2, *string label) {
    string desc = "assert_neq()";
    if (label) {
        desc += ": " + label;
    }
    desc += ": " + get_location();
    if (v1 !== v2) {
        UserApi::logInfo("OK: %s", desc);
        return;
    }

    string err = sprintf("ERROR: %s inequality test failed! (%N == %N)", desc, v1, v2);
    UserApi::logInfo(err);
    throw "ERROR", err;
}
# END

# type: GENERIC
# version: 1.0
# desc: regression test workflow untyped code
# name: regression-untyped-lib
# author: Qore Technologies, s.r.o.
# make sure untyped code is supported properly
class X {
    private $.a;

    private {
        $.b;
        static x1;
    }

    public {
        $.c;
        static x2;
    }

    meth($a, $b, $c) {
    }

    static meth($a) {
        my $b = True;
        delete $b;
    }
}

sub test_x1($a, $b, $c) {
}

sub test_x2($a) {
}
# END

# type: ARRAY
# version: 1.0
# desc: regression test feedback array function
%new-style
%require-types

# bug 1238: leave multiple keys
list sub feedback_array() {
    return ("one", "two");
}
# END

# type: STEP
# version: 1.1
# desc: creates a FEEDBACK_TEST order
# name: feedback_parent
# author: Qore Technologies, s.r.o.
%new-style
%require-types

sub feedback_parent(string key) {
    # make sure all instances of FEEDBACK-TEST are stopped
    stop_workflow("FEEDBACK-TEST");

    int id = UserApi::callNetworkApi("omq.system.start-workflow", ("name": "FEEDBACK-TEST")).id;
    test_value(id > 0, True, "start-workflow-1");

    string uuid = UUID::get();

    # save uuid in dynamic data for checking in next step
    WorkflowApi::updateDynamicData((key: uuid));

    softint wfiid = WorkflowApi::bindSubworkflow(("name": "FEEDBACK-TEST"), ("staticdata": ("uuid": uuid, "key": key))).workflow_instanceid;

    # ossue #2434 test step description
    assert_eq("feedback parent description", WorkflowApi::getStepInfo().desc);

    UserApi::logInfo("created FEEDBACK-TEST wfiid %d uuid: %s", wfiid, uuid);
}
# END

# type: STEP
# version: 1.0
# desc: dummy subworkflow step to act as a segment boundary
# author: Qore Technologies, s.r.o.
%new-style
%require-types

sub feedback_subworkflow() {
    WorkflowApi::skipSubworkflow();
}
# END

# type: STEP
# version: 1.0
# desc: updates feedback in the parent workflow
# name: feedback_child
# author: Qore Technologies, s.r.o.
%new-style
%require-types

sub feedback_child() {
    hash sd = WorkflowApi::getStaticData();
    UserApi::logInfo("sd: %y", sd);

    UserApi::logInfo("updating parent feedback with %y = %y", sd.key, sd.uuid);
    WorkflowApi::leaveParentFeedback(sd.key, sd.uuid);
}
# END

# type: GENERIC
# version: 1.0
# desc: regression test error function
# author: Qore Technologies, s.r.o.
%new-style
%require-types

*hash sub regression_errors() {
%ifdef Disabled
    return (
        "REGRESSION-ERROR" : (
            "desc": "regression test error",
            "status": OMQ::StatRetry,
            "retry-delay": 1s,
            ),
        );
%endif
}
# END

# type: STEP
# version: 1.0
# desc: does a one-time retry
# name: regression_retry
# author: Qore Technologies, s.r.o.
%new-style
%require-types

sub regression_retry() {
%ifdef Disabled
    if (!WorkflowApi::getDynamicData("retry")) {
        WorkflowApi::updateDynamicData(("retry": True));
        throw "REGRESSION-ERROR", "test retry error";
    }
%endif
}
# END

# type: STEP
# version: 1.0
# desc: dummy test function
# name: dummy_1
# author: Qore Technologies, s.r.o.
sub dummy_1() {
    WorkflowApi::updateDynamicData(("test1": now_us()));

    if (WorkflowApi::getStaticData().temptest) {
        if (!WorkflowApi::getTempData().test)
            throw "TEMPDATA-ERROR", "test for bug 877 failed";
        else
            UserApi::logInfo("temp data test passed");
    }
}
# END
