#!/usr/bin/env qore
# -*- mode: qore; indent-tabs-mode: nil -*-

/*
    Qorus Integration Engine(R) Community Edition

    Copyright (C) 2013 - 2023 Qore Technologies, s.r.o., all rights reserved

    LICENSE: GNU GPLv3

    https://www.gnu.org/licenses/gpl-3.0.en.html
*/

# @file generate a Qorus service from a Swagger 2.0 schema

%new-style
%enable-all-warnings
%require-types
%strict-args

%requires RestSchemaValidator
%requires Swagger
%requires Util
%requires Mime
%requires yaml
%requires SqlUtil
%requires QorusClientBase
%requires FileLocationHandler

%exec-class Swagger2Service

class Swagger2Service {
    public {
        #! program options
        const Opts = {
            "output":  "f,file=s",
            "name":    "n,name=s",
            "list":    "L,list",
            "version": "v,version=s",
            "bb":      "b,building-block",
            "help":    "h,help",
        };

        #! parsed options
        hash<auto> opt;
    }

    constructor() {
        GetOpt g(Opts);
        opt = g.parse3(\ARGV);
        if (opt.help)
            usage();
        if (!ARGV[0].val()) {
            errorln("missing Swagger 2.0 schema file name");
            usage();
        }

        # initialize Qorus client library
        QorusClient::initFast();

        string schema = shift ARGV;
        string content = FileLocationHandler::getTextFileFromLocation(schema);
        SwaggerSchema swagger = SwaggerLoader::fromString(content);

        if (opt."list") {
            printf("URL: %s\n", swagger.getTargetUrl());
            foreach hash<auto> h in (swagger.getPathOperationHash().pairIterator()) {
                map printf("%s /%s\n", $1.upr(), h.key), h.value;
            }
            thread_exit;
        }

        string path = basename(schema);

        # generate service name
        string name = opt.name ?? getSymbol(swagger.info.title ?? basename(path));
        string version;
        if (opt.version.val()) {
            version = opt.version;
        } else {
            if (swagger.info.version && swagger.info.version !~ /^unknown$/i) {
                version = swagger.info.version;
            } else {
                version = "1.0";
            }
        }

        string fn = opt.output ?? sprintf("%s-v%s.qsd", name, version);
        string yaml_fn = fn + ".yaml";

        generateService(swagger, path, name, version, fn, yaml_fn);
        print("created the following files:\n");
        # save schema as resource file in the target dir
        string dir = dirname(fn);
        if (dir != ".") {
            path = dir + DirSep + path;
        }
        hash<UrlInfo> url_info = parse_url(schema);
        if ((url_info.protocol && url_info.protocol != "file") || !is_readable(path)) {
            File f();
            f.open2(path, O_CREAT | O_WRONLY | O_TRUNC);
            f.write(content);
            printf("+ %s\n", path);
        }
        printf("+ %s\n", fn);
        printf("+ %s\n", yaml_fn);
        printf("oload with: \"oload %s -lvR\"\n", yaml_fn);
    }

    generateService(SwaggerSchema swagger, string path, string name, string version, string fn, string yaml_fn) {
        string svc_pfx = name;
        # capitolize the first letter of svc_pfx
        if (svc_pfx[0] =~ /[[:lower:]]/u) {
            svc_pfx = svc_pfx[0].upr() + svc_pfx[1..];
        }

        File yaml_file();
        yaml_file.open2(yaml_fn, O_CREAT|O_WRONLY|O_TRUNC);

        string svc_classname = svc_pfx + "QorusService";

        code get_yaml = string sub (auto v) {
            return trim(make_yaml(v, None));
        };

        string svc_desc = swagger.info.desc
            ? getDesc(swagger.info.desc)
            : sprintf("REST server service generated from %s", basename(path));

        string base_class = opt.bb ? "BBM_RestServiceBase" : "QorusService";
        string extra_yaml;
        if (opt.bb) {
            extra_yaml = getBbYaml();
        }

        # output YAML metadata
        yaml_file.printf("# This is a generated file, don't edit!
type: service
name: %s
version: %s
desc: %s
author:
  - %s
base-class-name: %s%s
class-name: %s
lang: qore
servicetype: USER
resource:
  - %s
code: %s
methods:
  - name: init
    desc: init method\n", name, get_yaml(version), get_yaml(svc_desc), get_yaml(getAuthor()), base_class,
        extra_yaml, svc_classname, path, fn);

        File f();
        f.open2(fn, O_CREAT|O_WRONLY|O_TRUNC);
        # output emacs header for old-school coders
        f.printf("# -*- mode: qore; indent-tabs-mode: nil -*-\n");
        f.printf("# generated by %s on %s from Swagger schema %s\n\n", get_script_name(), now().format("YYYY-MM-DD"), path);
        f.print("%new-style\n%require-types\n%strict-args\n%enable-all-warnings\n\n%requires Swagger\n\n");

        # list of REST classes
        list<string> classes();

        # first generate all source code to get hashdecls and hierarchy
        # path -> method -> code
        hash<string, hash<string, string>> codemap;
        # path dependency: parent path -> child (terminal leaf node only) -> True
        hash<string, hash<string, bool>> pdep;
        # child depth hash: depth -> path -> methods
        hash<string, hash<string, list<string>>> cdh();
        # hashdecls already output
        hash<string, bool> hdo;
        # wilcard class hash
        hash<string, bool> wch;
        # orphan class hash
        hash<auto> och;
        # path to class name map
        hash<string, string> pathmap;

        # recursive closures to deal with ophan classes
        code do_orphan = sub (reference<auto> h, list<auto> l, int offset = 0) {
            if (offset >= l.size() - 1)
                h{l[offset]} = True;
            else
                do_orphan(\h{l[offset]}, l, ++offset);
        };

        code remove_orphan = sub (reference<auto> h, list<auto> l, int offset = 0) {
            if (!h || !h{l[offset]})
                return;

            if (offset == l.size() - 1) {
                if (offset)
                    h = True;
                else
                    remove h{l[0]};
            } else
                remove_orphan(\h{l[offset]}, l, ++offset);
        };

        code emit_orphans = sub (hash<auto> och, *string pfx) {
            foreach hash<auto> h in (och.pairIterator()) {
                string orphan_name = pfx ? pfx + "/" + h.key : h.key;
                if (h.value === True) {
                    string classname = outputRestClass(f, {"key": orphan_name}, codemap, pdep{orphan_name}, wch);
                    pathmap{orphan_name} = classname;
                    if (!pfx)
                        classes += classname;
                } else
                    emit_orphans(h.value, orphan_name);
            }
        };

        foreach hash<auto> h in (swagger.getPathOperationHash().pairIterator()) {
            # process hierarchy
            {
                list<string> l = h.key.split("/");
                # first insert all URI paths into the orphan class hash
                # entries are removed when then are generated
                do_orphan(\och, l);

                cdh{l.size()}{h.key} = h.value;

                foreach string elem in (l) {
                    # check for wildcards in all elements
                    if (elem =~ /^{.*}$/ || elem == "*") {
                        wch{elem} = True;
                    }
                    if ($# > 0) {
                        string parent = foldl $1 + "/" + $2, l[0..($# - 1)];
                        pdep{parent}{l[$#]} = True;
                    }
                }
                cdh{l.size()}{h.key} = h.value;
            }
            foreach string meth in (h.value) {
                hash<RestQoreExampleCodeInfo> qex = swagger.getQoreExampleResponse(meth, "/" + h.key, 200);
                # output hashdecls immediately
                foreach hash<auto> hdh in (qex.hashdecls.pairIterator()) {
                    if (hdo{hdh.key})
                        continue;
                    hdo{hdh.key} = True;
                    f.printf("# REST API hash %y\n", hdh.key);
                    f.printf("%s\n", hdh.value);
                }
                # save code for REST class output
                codemap{h.key}{meth} = qex.example;
            }
        }

        *list<auto> root_methods;

        # emit REST class in reverse hierarchy order; children first
        foreach hash<auto> dh in (new HashReverseIterator(cdh)) {
            foreach hash<auto> h in (dh.pairIterator()) {
                # do not output root class yet
                if (h.key.val()) {
                    #stderr.printf("%y: dep: %y\n", h.key, pdep{h.key});
                    string classname = outputRestClass(f, h, codemap, pdep{h.key}, wch);
                    pathmap{h.key} = classname;
                    if (h.key !~ /\//)
                        classes += classname;
                    # remove emitted classes from orphan hash
                    remove_orphan(\och, h.key.split("/"));
                } else {
                    root_methods = h.value;
                    remove och."";
                }
            }
        }

        # get RestHandler class name
        string rh_cls_name = svc_pfx + "RestHandler";
        pathmap{"/"} = rh_cls_name;

        # emit orphan classes
        if (och) {
            emit_orphans(och);
        }

        # emit intermediate classes with no methods
        map outputRestClass(f, {"key": $1, "value": ()}, codemap, pdep{$1}, wch), keys pdep, !pathmap{$1};

        # get HTTP URI base path for service
        string url = swagger.getTargetUrl();
        hash<UrlInfo> urlh;
        try {
            urlh = parse_url(url);
        } catch (hash<ExceptionInfo> ex) {
            if (ex.err != "PARSE-URL-ERROR") {
                rethrow;
            }
        }

        # is it a YAML schema?
        bool yaml = (path =~ /yaml/i);

        # output RestHandler class
        f.printf("class %s inherits AbstractServiceRestHandler {
    constructor() : AbstractServiceRestHandler(%y, False, NOTHING,
            SwaggerLoader::fromString(ServiceApi::getResourceData(%y).toString(), %s)) {\n", rh_cls_name,
            urlh.path ?? "/", path, yaml ? "False": "True");
        map f.printf("        addClass(new %s());\n", $1), classes;
        f.printf("    }\n");
        if (urlh.path) {
            string prefix = urlh.path;
            prefix =~ s/^\/+//g;
            prefix = replace(prefix, "/", "\\/");
            f.printf("\n    # remove the path prefix from requests before matching\n    removeRootPath(reference<string> path) {\n        path =~ s/^\\/*%s//;\n    }\n", prefix);
        }

        # add any top-level methods
        if (root_methods) {
            Swagger2Service::outputRestClassIntern(f, "", root_methods, codemap, pdep."", wch);
        }

        f.printf("}\n\n");

        if (opt.bb) {
            f.printf("class %s inherits BBM_RestServiceBase {
    private AbstractServiceHttpHandler getHandlerImpl() {
        return new %s();
    }
}", svc_classname, rh_cls_name);

        } else {
            # output service class
            f.printf("class %s inherits QorusService {
    init() {
        %s rh();
        bindHttp(rh);
    }
}", svc_classname, rh_cls_name);
        }
    }

    static string getBbYaml() {
        string yaml = "\nclasses:\n  - BBM_RestServiceBase";
        # get config item yaml
        omqclient.initOmq();
        Table classes(omq, "classes");
        string sql;
        on_error printf("SQL: %y\n", sql);
        *hash<auto> row = classes.selectRow({
            "columns": ("classid", "version", "yaml_config_items", cop_max("created")),
            "where": {"name": "BBM_RestServiceBase"},
            "groupby": ("classid", "version", "yaml_config_items"),
            "having": {"created": (COP_MAX, op_ceq("created"))},
            "limit": 1,
        }, \sql);
        if (!row) {
            return "";
        }
        *list<auto> l = parse_yaml(row.yaml_config_items);
        if (!l) {
            return "";
        }
        yaml += "\nconfig-items:";
        foreach hash<auto> conf in (l) {
            yaml += sprintf("\n  - name: %s", conf.name);
            yaml += sprintf("\n    parent:\n        interface-type: class\n        "
                "interface-name: BBM_RestServiceBase\n        interface-version: %y", row.version);
        }
        return yaml;
    }

    static string outputRestClass(File f, hash<auto> h, hash<string, hash<string, string>> codemap, *hash<string, bool> dep, *hash<string, bool> wch) {
        string classname = Swagger2Service::getSymbol(h.key, True) + "RestClass";
        f.printf("# REST class for URI path /%s: methods: %s\n", h.key, (foldl $1 + ", " + $2, map $1.upr(), h.value) ?? "n/a");
        f.printf("class %s inherits AbstractRestClass {\n", classname);

        *list<string> const_classes = map Swagger2Service::getSymbol(h.key + "/" + $1, True), keys dep, !wch{$1};

        # output any properties and a constructor (if necessary) and the name() method
        {
            list<string> l = h.key.split("/");
            string name = l.last();
            if (wch{name}) {
                f.print("    private {\n        string arg;\n    }\n\n");
                f.print("    constructor(string arg) {\n        self.arg = arg;\n");
                map f.printf("        addClass(new %sRestClass());\n", $1), const_classes;
                f.print("    }\n\n");
            } else if (const_classes) {
                f.print("    constructor(string arg) {\n        self.arg = arg;\n");
                map f.printf("        addClass(new %sRestClass());\n", $1), const_classes;
                f.print("    }\n\n");
            }
            f.printf("    string name() {\n");
            if (wch{name})
                f.printf("        return arg;\n");
            else
                f.printf("        return %y;\n", name);
            f.printf("    }\n");
        }

        Swagger2Service::outputRestClassIntern(f, h.key, h.value, codemap, dep, wch);
        f.printf("}\n\n");
        return classname;
    }

    static outputRestClassIntern(File f, string uri_path, *list<auto> methods,
            hash<string, hash<string, string>> codemap, *hash<string, bool> dep, *hash<string, bool> wch) {

        *hash<string, string> wc_classes = map {$1: Swagger2Service::getSymbol(uri_path + "/" + $1, True)}, keys dep,
            wch{$1};
        # output subclass code if appropriate
        if (wc_classes) {
            f.printf("\n    *AbstractRestClass subClass(string arg, hash<auto> cx, *hash<auto> ah) {\n");
            foreach hash<auto> i in (wc_classes.pairIterator()) {
                f.printf("        # FIXME: implement appropriate wildcard matching logic here for arg =~ /%s/\n", i.key);
                f.printf("        return new %sRestClass(arg);\n", i.value);
            }
            f.printf("    }\n");
        }
        # generate methods
        foreach string meth in (methods) {
            f.print("\n");
            f.printf("    # %s /%s\n", meth.upr(), uri_path);
            f.printf("    hash<HttpHandlerResponseInfo> %s(hash<auto> cx, *hash<auto> ah) {\n", meth);
            f.printf("        # NOTE: insert custom method code here\n");
            f.printf(Swagger2Service::getCode(codemap{uri_path}{meth}, 8));
            f.printf("    }\n");
        }
        #map printf("%s /%s\n", $1.upr(), h.key), h.value;
    }

    static string getCode(string srccode, int spaces) {
        trim srccode;
        string str = strmul(" ", spaces);
        return str + srccode.split("\n").join("\n" + str) + "\n";
    }

    static string getDesc(string desc) {
        desc =~ s/\s+/ /g;
        return desc;
    }

    static string getAuthor() {
%ifdef HAVE_UNIX_USERMGT
        return getpwuid(getuid()).pw_gecos;
%else
        return getusername();
%endif
    }

    static string getSymbol(string str, *bool cap_first) {
        # ensure capitalization in the string
        *list l = (str =~ x/([ _\/{}])([a-z])/g);
        if (l)
            map str = replace(str, l[$1] + l[$1 + 1], l[$1 + 1].upr()), xrange(0, l.size() - 1, 2);

        str =~ s/ +//g;
        str =~ s/[^a-z0-9_]+//ig;

        if (str !~ /^[a-z_]/i)
            str = "rest" + str;
        if (cap_first && str !~ /^[A-Z]/)
            str = str[0].upr() + str.substr(1);
        return str;
    }

    static usage() {
        printf("usage: %s [options] <URL_to_swagger_2.0_schema>
 -b,--building-block  use the BBM_RestServiceBase class as a base class
 -f,--file=ARG        specify output file name (otherwise files are generated based on the Swagger schema)
 -L,--list            list URI paths and methods supported by the schema
 -n,--name=ARG        specify the service name (otherwise generated automatically)
 -v,--version=ARG     specify the service version (otherwise generated automatically)
 -h,--help            this help text
", get_script_name());
        exit(1);
    }

    static errorln(string fmt) {
        stderr.printf("%s: ERROR: %s\n", get_script_name(), vsprintf(fmt, argv));
    }

    static error(string fmt) {
        Swagger2Service::errorln(vsprintf(fmt, argv));
        exit(1);
    }
}
