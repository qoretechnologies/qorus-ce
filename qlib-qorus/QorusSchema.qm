# -*- mode: qore; indent-tabs-mode: nil -*-
# @file QorusSchema.qm Qorus Integration System schema description module

/*
    Qorus Integration Engine(R) Community Edition

    Copyright (C) 2003 - 2023 Qore Technologies, s.r.o., all rights reserved

    LICENSE: GNU GPLv3

    https://www.gnu.org/licenses/gpl-3.0.en.html
*/

%requires qore >= 1.0

module QorusSchema {
    version = "1.0";
    desc = "Qorus Integration Engine(R) Community Edition schema module";
    author = "Qore Technologies <info@qoretechnologies.com>";
    url = "http://www.qoretechnologies.com";
}

%requires QorusVersion
%requires Util
%requires SqlUtil
%requires Schema
# for remoteconnections migration
%requires yaml

# here we add fallback paths to the QORE_MODULE_DIR search path,
# in case QORE_MODULE_DIR is not set properly for Qorus
%append-module-path /var/opt/qorus/qlib:$OMQ_DIR/qlib:/opt/qorus/qlib

%new-style
%require-types
%enable-all-warnings

const GenericOptions = {
    "replace": True,
};

const IndexOptions = {
    "driver": {
        "oracle": {
            "compute_statistics": True,
        },
    },
};

const ColumnOptions = {};
/* (
    "driver": (
        "oracle": ("character_semantics": True,),
    ),
    );
*/

const SequenceHash = {
    "seq_workflows": {},
    "seq_steps": {},
    "seq_workflow_instance": {},
    "seq_function_instance": {},
    "seq_error_instance": {},
    "seq_services": {},
    "seq_service_methods": {},
    "seq_sessions": {},
    "seq_queues": {},
    "seq_classes": {},
    "seq_constants": {},
    "seq_workflow_event_types": {},
    "seq_groups": {},
    "seq_jobs": {},
    "seq_job_instance": {},
    "seq_job_errorid": {},
    "seq_audit_eventid": {},
    "seq_release_file_contents": {},
    "seq_mappers": {},
    "seq_order_instance_notes" : {},
    "seq_value_maps": {},
    "seq_sla": {},
    "seq_sla_events": {},
    "seq_loggers": {},
    "seq_types": {},
    "seq_connections": {},
};

const PGSQL_SEQUENCES = {
    "seq_workflow_instance_stats_stage": {},
    "seq_job_instance_stats_stage": {},
};

const Sequences = {
    "driver": {
        "oracle": SequenceHash,
        "pgsql": SequenceHash + PGSQL_SEQUENCES,
    },
};

const NN_False = 0;
const NN_True = 1;
const NN_TrueExceptMysql = 2;

public namespace Arch {
    public const TYPE_EXCLUDED = "excluded";
    public const TYPE_META = "meta";
    public const TYPE_LIVE = "live";
    public const TYPES = ( TYPE_EXCLUDED, TYPE_META, TYPE_LIVE, );

    public const DATA_UPSERT = "upsert";
    public const DATA_FULL = "full";
    public const DATA_DATE_UPSERT = "date_upsert";
    public const DATA_DATE = "date";
    public const DATA_JOBID = "jobid";
    public const DATA_WFIID = "wfiid";
    public const DATA_CUSTOM = "custom";
    public const DATAS = (DATA_UPSERT, DATA_FULL, DATA_DATE_UPSERT, DATA_DATE,
                          DATA_JOBID, DATA_WFIID, DATA_CUSTOM, );

    public const TEMPLATE_META_UPSERT = ( "type" : TYPE_META, "data" : DATA_UPSERT );
    public const TEMPLATE_META_FULL = ( "type" : TYPE_META, "data" : DATA_FULL );
    public const TEMPLATE_WFIID = ( "type" : TYPE_LIVE, "data" : DATA_WFIID );
    public const TEMPLATE_JOBID = ( "type" : TYPE_LIVE, "data" : DATA_JOBID );
}

hash sub c_date(int notnull, string comment) {
    return c_date(notnull, True, comment);
}

hash sub c_date(int notnull, bool ora_date = True, *string comment) {
    return {
        "qore_type": Type::Date,
        "comment": comment,
    }
    + (notnull ? {"notnull": True} : NOTHING)
    + {
        "driver": {
            "oracle": ora_date ? {"native_type": "date"} : NOTHING,
            "mysql": notnull == NN_TrueExceptMysql ? {"notnull": False} : NOTHING,
        },
    };
}
hash sub c_date(bool notnull = False, bool ora_date = True, *string comment) {
    return {
        "qore_type": Type::Date,
        "comment": comment,
    }
    + (notnull ? {"notnull": True} : NOTHING)
    + {
        "driver": {
            "oracle": ora_date ? {"native_type": "date"} : NOTHING,
        },
    };
}

hash sub c_date(bool notnull, string comment) {
    return {
        "qore_type": Type::Date,
        "driver": {"oracle": {"native_type": "date"}},
        "comment": comment,
    }
    + (notnull ? {"notnull": True} : NOTHING)
    ;
}

hash sub c_date(string comment) {
    return {
        "qore_type": Type::Date,
        "driver": {"oracle": {"native_type": "date"}},
        "comment": comment,
    };
}

hash sub c_timestamp(int notnull, *string comment) {
    return {
        "qore_type": Type::Date,
        "comment": comment,
    }
    + (notnull ? {"notnull": True} : NOTHING)
    + {
        "driver": {
            "mysql": notnull == NN_TrueExceptMysql ? {"notnull": False} : NOTHING,
        },
    };
}

hash sub c_timestamp(bool notnull = False, *string comment) {
    return {
        "qore_type": Type::Date,
        "comment": comment,
    }
    + (notnull ? {"notnull": True} : NOTHING)
    ;
}

hash sub c_timestamp(string comment) {
    return {
        "qore_type": Type::Date,
        "comment": comment,
    };
}

hash sub c_raw(int size, bool notnull, *string comment) {
    return {
        "qore_type": Type::Binary,
        "comment": comment,
    }
    + (notnull ? {"notnull": True} : NOTHING)
    + {
        "driver": {
            "oracle": {"native_type": "raw", "size": size,},
            "mysql": {"native_type": "varbinary", "size": size,},
        },
    };
}

const C_Modified = c_date();
const C_Created = C_Modified + {"notnull": True,};

hash sub get_pgsql_trigger_func(string name, bool insert_only = False, *string col, *string seq,
        bool has_modified = True) {
    string sql = "returns trigger language plpgsql as $function$\n"
"begin\n"
"  if (tg_op = 'INSERT') then\n";

    if (col && seq) {
        sql += sprintf("    if new.%s is null then
       select nextval('%s') into new.%s;
    end if;\n", col, seq, col);
    }

    sql += "    if new.created is null then\n"
"      select current_timestamp into new.created;\n"
"    end if;\n";

    if (has_modified) {
        sql += "    if new.modified is null then\n"
"      select current_timestamp into new.modified;\n"
"    end if;\n";
    }

  if (insert_only) {
      sql += "  end if;\n";
  }
  else {
      sql += "  else\n"
"    if (tg_op = 'UPDATE') then\n";

      if (has_modified) {
        sql +=
"      if new.modified is null or new.modified = old.modified then\n"
"        select current_timestamp into new.modified;\n"
"      end if;\n";
      } # modified

      sql +=
"    end if;\n"
"  end if;\n";
  }

  sql += "  return new;\n"
"end;\n"
"$function$";

    return (
        "functions": (
            "trig_" + name + "()": sql,
        ),
   );
}
hash sub get_pgsql_trigger(string name, bool insert_only = False) {
    return ("trig_" + name: sprintf("before insert %son %s for each row execute procedure trig_%s()",
        insert_only ? "" : "or update ", name, name));
}

hash sub get_mysql_triggers(string name, bool insert_only = False, *string col, *string seq) {
    string sql = "before insert on " + name + " for each row\nbegin\n";

    if (col && seq)
        sql += sprintf("  if new.%s is null or new.%s = 0 then
     set new.%s = my_nextval('%s');
  end if;\n", col, col, col, seq);

    sql += "  if new.created is null then
    set new.created = now();
  end if;\n";
    if (!insert_only)
        sql += "  if new.modified is null then
    set new.modified = now();
  end if;\n";
  sql += "end";

    return ("trig_" + name + "_insert": sql) +
        (insert_only ? NOTHING : (
             "trig_" + name + "_update": "before update on " + name + " for each row
begin
  if new.modified is null or new.modified = old.modified then
    set new.modified = now();
  end if;
end"));
}

hash sub get_oracle_trigger(string name, bool insert_only = False, *string col, *string seq, *string trig_pfx) {
    string sql = sprintf("BEFORE INSERT%s ON %s
REFERENCING NEW AS NEW OLD AS OLD
FOR EACH ROW
begin
  if inserting then\n", insert_only ? "" : " OR UPDATE", name.upr());
    if (col && seq)
        sql += sprintf("    if :new.%s is null then
      select %s.nextval into :new.%s from dual;
    end if;\n", col, seq, col);
    sql += "    if :new.created is null then
      :new.created := localtimestamp;
    end if;
  end if;\n";
  if (!insert_only)
    sql += "  --
  if :new.modified is null or :new.modified = :old.modified then
    :new.modified := localtimestamp;
  end if;\n";
  sql += "end;";
    return ("trig_" + (trig_pfx ?? name): sql);
}

const T_ClusterProcesses = {
    "arch": {"type": Arch::TYPE_EXCLUDED},
    "columns": {
        "process_network_id": c_varchar(240, True, "the ZeroMQ network ID of the process (PK)"),
        "host": c_varchar(240, True, "the host where the process is running"),
        "node": c_varchar(250, True, "the node where the process is running"),
        "pid": c_int("the PID of the process on the given host"),
        "process_type": c_varchar(240, True, "the type of process"),
        "client_id": c_varchar(240, True, "the client_id of the process"),
        "interfaces": c_varchar(4000, True, "the interfaces used for the process on the node"),
        "queue_urls": c_varchar(4000, False, "the ZeroMQ URLs for the process; NULL for non-ZeroMQ processes"),
        "info": c_varchar(4000, "YAML-serialized process info"),
        "dependent": c_number(1, True, "1 = dependent on qorus-core, 0 = running independently") +
            {"default_value": 0},
        "heartbeat": c_timestamp("process heartbeat column"),
        "active_master": c_number(1, "1 = active master processes"),
        "created": c_timestamp(NN_TrueExceptMysql, "created timestamp"),
        "modified": c_timestamp("modified timestamp"),
    },
    "indexes": {
        "driver": {
            "oracle": {
                "pk_cluster_processes": {"columns": ("process_network_id"), "unique": True},
            },
        },
        "pk_cluster_processes_am": {"columns": ("active_master"), "unique": True},
    },
    "primary_key": {"name": "pk_cluster_processes", "columns": ("process_network_id")},
    "driver": {
        "pgsql": get_pgsql_trigger_func("cluster_processes"),
    },
    "triggers": {
        "driver": {
            "oracle": get_oracle_trigger("cluster_processes"),
            "pgsql": get_pgsql_trigger("cluster_processes"),
            "mysql": get_mysql_triggers("cluster_processes"),
        },
    },
};

const T_SystemProperties = (
    "arch" : {"type" : Arch::TYPE_EXCLUDED},
    "rename": (
        "column_map": (
            "key": "keyname",
        ),
    ),
    "columns": (
        "domain": c_varchar(240, True),
        "keyname": c_varchar(240, True),
        "value": c_varchar(4000),
        "created": c_date(NN_TrueExceptMysql),
        "modified": c_date(),
    ),
    "indexes": (
        "sk_system_properties_domain": ("columns": "domain"),
        "driver": (
            "oracle": (
                "pk_system_properties": ("columns": ("domain", "keyname"), "unique": True),
            ),
        ),
    ),
    "primary_key": ("name": "pk_system_properties", "columns": ("domain", "keyname")),
    "driver": (
        "pgsql": get_pgsql_trigger_func("system_properties"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("system_properties"),
            "pgsql": get_pgsql_trigger("system_properties"),
            "mysql": get_mysql_triggers("system_properties"),
        ),
    ),
);

const T_SessionStatus = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "sessionstatus": c_varchar(40, True),
        "description": c_varchar(240),
        "created": c_date(NN_TrueExceptMysql),
        "modified": c_date(),
    ),
    "indexes": (
        "driver": ("oracle": ("pk_session_status": ("columns": "sessionstatus", "unique": True))),
    ),
    "primary_key": ("name": "pk_session_status", "columns": "sessionstatus"),
    "driver": (
        "pgsql": get_pgsql_trigger_func("session_status"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("session_status"),
            "pgsql": get_pgsql_trigger("session_status"),
            "mysql": get_mysql_triggers("session_status"),
        ),
    ),
);

const T_Sessions = (
    "arch" : {"type" : Arch::TYPE_EXCLUDED},
    "columns": (
        "sessionid": c_number(14, True),
        "instancekey": c_varchar(80, True),
        "sessionstatus": c_varchar(40, True),
        "hostname": c_varchar(80, True),
        "xmlrpc_server": c_varchar(250, True),
        "version": c_varchar(20),
        "started": c_date(NN_TrueExceptMysql),
        "ended": c_date(),
    ),
    "indexes": (
        "sk_sessionkey": ("columns": "instancekey"),
        "sk_sessionstatus": ("columns": "sessionstatus"),
        "driver": ("oracle": ("pk_sessions": ("columns": "sessionid", "unique": True))),
    ),
    "primary_key": ("name": "pk_sessions", "columns": "sessionid"),
    "foreign_constraints": (
        "fk_sessions_session_status": ("columns": "sessionstatus", "table": "session_status"),
    ),
    "driver": (
        "pgsql": (
            "functions": (
                "trig_sessions()": "returns trigger language plpgsql as $function$
begin
  if (tg_op = 'INSERT') then
    if new.started is null then
      select current_timestamp into new.started;
    end if;
    if new.sessionid is null then
      select nextval('seq_sessions') into new.sessionid;
    end if;
    if new.sessionstatus is null then
      select 'ACTIVE' into new.sessionstatus;
    end if;
  else
    if (tg_op = 'UPDATE') then
      if new.sessionstatus = 'COMPLETE' then
        select current_timestamp into new.ended;
      end if;
    end if;
  end if;
  return new;
end;
$function$", #",
            ),
        ),
    ),
    "triggers": (
        "driver": (
            "oracle": (
                "trig_sessions": "BEFORE INSERT OR UPDATE ON SESSIONS
REFERENCING NEW AS NEW OLD AS OLD
FOR EACH ROW
begin
  if inserting then
    if :new.started is null then
      :new.started := sysdate;
    end if;
    if :new.sessionid is null then
      select seq_sessions.nextval into :new.sessionid from dual;
    end if;
    if :new.sessionstatus is null then
      :new.sessionid := 'ACTIVE';
    end if;
  else
    if updating then
      if :new.sessionstatus = 'COMPLETE' then
        :new.ended := sysdate;
      end if;
    end if;
  end if;
end;",
            ),
            "pgsql": get_pgsql_trigger("sessions"),
            "mysql": (
                "trig_sessions_insert": "before insert on sessions for each row
begin
  set new.started = now();
end",
                "trig_sessions_update": "before update on sessions for each row
begin
  if new.sessionstatus = 'COMPLETE' then
    set new.ended = now();
  end if;
end",
            ),
        ),
    ),
);

const T_FunctionType = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "name": c_varchar(20, True),
        "description": c_varchar(240),
        "created": c_date(NN_TrueExceptMysql),
        "modified": c_date(),
    ),
    "indexes": (
        "driver": ("oracle": ("pk_function_type": ("columns": "name", "unique": True))),
    ),
    "primary_key": ("name": "pk_function_type", "columns": "name"),
    "driver": (
        "pgsql": get_pgsql_trigger_func("function_type"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("function_type"),
            "pgsql": get_pgsql_trigger("function_type"),
            "mysql": get_mysql_triggers("function_type"),
        ),
    ),
);

const T_FunctionInstance = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "function_instanceid": c_number(14, True),
        "function_type": c_varchar(20, True),
        "name": c_varchar(160, True),
        "version": c_varchar(80, True),
        "patch": c_varchar(80),
        "description": c_varchar(4000),
        "author": c_varchar(240),
        "body": c_clob(True),
        "created": c_date(NN_TrueExceptMysql),
        "modified": c_date(),
    ),
    "indexes": (
        "driver": (
            "oracle": (
                "pk_function_instance": ("columns": "function_instanceid", "unique": True),
            ),
        ),
        "sk_fi_function_type": ("columns": "function_type"),
        "sk_fi_name_version": ("columns": ("name", "version"), "unique": True),
    ),
    "primary_key": ("name": "pk_function_instance", "columns": "function_instanceid"),
    "unique_constraints": (
        "sk_fi_name_version": ("columns": ("name", "version")),
    ),
    "foreign_constraints": (
        "fk_func_inst_function_type": ("columns": "function_type", "table": "function_type", "target_columns": "name"),
    ),
    "driver": (
        "pgsql": get_pgsql_trigger_func("function_instance", False, "function_instanceid", "seq_function_instance"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("function_instance", False, "function_instanceid", "seq_function_instance"),
            "pgsql": get_pgsql_trigger("function_instance"),
            "mysql": get_mysql_triggers("function_instance", False, "function_instanceid", "seq_function_instance"),
        ),
    ),
);

const T_FunctionInstanceTags = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "function_instanceid": c_number(14, True),
        "tag": c_varchar(255, True),
        "value": c_varchar(4000, True),
        "created": c_timestamp(NN_TrueExceptMysql),
        "modified": c_timestamp(False),
    ),
    "indexes": (
        "driver": ("oracle": ("pk_function_instance_tags": ("columns": ("function_instanceid", "tag"), "unique": True))),
        "sk_fit_function_instance": ("columns": ("function_instanceid")),
        "sk_fit_tags": ("columns": "tag"),
    ),
    "primary_key": ("name": "pk_function_instance_tags", "columns": ("function_instanceid", "tag")),
    "foreign_constraints": (
        "fk_fit_function_instance": ("columns": "function_instanceid", "table": "function_instance"),
    ),
    "driver": (
        "pgsql": get_pgsql_trigger_func("function_instance_tags"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("function_instance_tags"),
            "pgsql": get_pgsql_trigger("function_instance_tags"),
            "mysql": get_mysql_triggers("function_instance_tags"),
        ),
    ),
);

const T_Classes = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "classid": c_number(14, True),
        "name": c_varchar(160, True),
        "version": c_varchar(80, True),
        "patch": c_varchar(80),
        "description": c_varchar(4000),
        "author": c_varchar(240),
        "body": c_clob(True),
        "language": c_varchar(80, True, "programming language") + {"default_value": "qore"},
        "language_info": c_clob(False, "supplemental information for the programming language"),
        "yaml_config_items": c_clob(False, "config items defined in YAML"),
        "connectors": c_clob(False, "class connectors defined in YAML"),
        "processor": c_clob(False, "processor definition in YAML"),
        "created": c_date(NN_TrueExceptMysql),
        "modified": c_date(),
    ),
    "indexes": {
        "driver": {
            "oracle": {
                "pk_classes": {"columns": ("classid"), "unique": True},
            },
        },
        "sk_classes_name_version": {"columns": ("name", "version"), "unique": True},
    },
    "primary_key": ("name": "pk_classes", "columns": ("classid")),
    "unique_constraints": (
        "sk_classes_name_version": ("columns": ("name", "version")),
    ),
    "driver": (
        "pgsql": get_pgsql_trigger_func("classes", False, "classid", "seq_classes"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("classes", False, "classid", "seq_classes"),
            "pgsql": get_pgsql_trigger("classes"),
            "mysql": get_mysql_triggers("classes", False, "classid", "seq_classes"),
        ),
    ),
);

const T_ClassDependencies = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "classid": c_number(14, True),
        "dependson_class": c_varchar(160, True),
        "created": c_timestamp(NN_TrueExceptMysql),
        "modified": c_timestamp(False),
    ),
    "indexes": (
        "driver": ("oracle": ("pk_class_deps": ("columns": ("classid", "dependson_class"), "unique": True))),
        "sk_class_deps_class": ("columns": ("classid")),
        "sk_class_deps_dependson_class": ("columns": "dependson_class"),
    ),
    "primary_key": ("name": "pk_class_deps", "columns": ("classid", "dependson_class")),
    "foreign_constraints": (
        "fk_class_deps_class": ("columns": "classid", "table": "classes"),
    ),
    "driver": (
        "pgsql": get_pgsql_trigger_func("class_dependencies"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("class_dependencies"),
            "pgsql": get_pgsql_trigger("class_dependencies"),
            "mysql": get_mysql_triggers("class_dependencies"),
        ),
    ),
);

const T_ClassTags = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "classid": c_number(14, True),
        "tag": c_varchar(255, True),
        "value": c_varchar(4000, True),
        "created": c_timestamp(NN_TrueExceptMysql),
        "modified": c_timestamp(False),
    ),
    "indexes": {
        "driver": {"oracle": {"pk_class_tags": {"columns": ("classid", "tag"), "unique": True}}},
        "sk_class_tags_class": {"columns": ("classid")},
        "sk_class_tags_tags": {"columns": "tag"},
    },
    "primary_key": {"name": "pk_class_tags", "columns": ("classid", "tag")},
    "foreign_constraints": {
        "fk_class_tags_class": {"columns": "classid", "table": "classes"},
    },
    "driver": {
        "pgsql": get_pgsql_trigger_func("class_tags"),
    },
    "triggers": {
        "driver": {
            "oracle": get_oracle_trigger("class_tags"),
            "pgsql": get_pgsql_trigger("class_tags"),
            "mysql": get_mysql_triggers("class_tags"),
        },
    },
);

const T_Constants = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "constantid": c_number(14, True),
        "name": c_varchar(160, True),
        "version": c_varchar(80, True),
        "patch": c_varchar(80),
        "description": c_varchar(4000),
        "author": c_varchar(240),
        "body": c_clob(True),
        "created": c_date(NN_TrueExceptMysql),
        "modified": c_date(),
    ),
    "indexes": (
        "driver": (
            "oracle": (
                "pk_constants": ("columns": ("constantid"), "unique": True),
            )),
        "sk_constants_name_version": ("columns": ("name", "version"), "unique": True),
    ),
    "primary_key": ("name": "pk_constants", "columns": ("constantid")),
    "unique_constraints": (
        "sk_constants_name_version": ("columns": ("name", "version")),
    ),
    "driver": (
        "pgsql": get_pgsql_trigger_func("constants", False, "constantid", "seq_constants"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("constants", False, "constantid", "seq_constants"),
            "pgsql": get_pgsql_trigger("constants"),
            "mysql": get_mysql_triggers("constants", False, "constantid", "seq_constants"),
        ),
    ),
);

const T_ConstantTags = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "constantid": c_number(14, True),
        "tag": c_varchar(255, True),
        "value": c_varchar(4000, True),
        "created": c_date(NN_TrueExceptMysql, False),
        "modified": c_date(False, False),
    ),
    "indexes": (
        "driver": ("oracle": ("pk_constant_tags": ("columns": ("constantid", "tag"), "unique": True))),
        "sk_constant_tags_constant": ("columns": ("constantid")),
        "sk_constant_tags_tags": ("columns": "tag"),
    ),
    "primary_key": ("name": "pk_constant_tags", "columns": ("constantid", "tag")),
    "foreign_constraints": (
        "fk_constant_tags_constant": ("columns": "constantid", "table": "constants"),
    ),
    "driver": (
        "pgsql": get_pgsql_trigger_func("constant_tags"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("constant_tags"),
            "pgsql": get_pgsql_trigger("constant_tags"),
            "mysql": get_mysql_triggers("constant_tags"),
        ),
    ),
);

const T_Mappers = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "mapperid": c_number(14, True, "the primary key for the Mapper"),
        "name": c_varchar(160, True, "the name of the Mapper object"),
        "version": c_varchar(80, True, "the version of the Mapper object"),
        "patch": c_varchar(80, "the patch level of the Mapper object"),
        "description": c_varchar(4000, "the description of the Mapper object"),
        "author": c_varchar(240, "the author of the Mapper object"),
        "type": c_varchar(160, True, "the type (class) of Mapper object"),
        "parse_options": c_varchar(500, "comma-separated parse options for the mapper source code"),
        "fields": c_clob(True, "Mapper fields as Qore source for the mapper field hash"),
        "options": c_clob("Mapper options in YAML hash format"),
        "is_yaml": c_number(1, True) + {"default_value": 0},
        "context": c_varchar(1000, "the mapper interface context"),
        "created": c_timestamp(NN_TrueExceptMysql, "the created date for the Mapper object"),
        "modified": c_timestamp(False, "the last modified date for the Mapper object"),
    ),
    "indexes": (
        "driver": ("oracle": ("pk_mappers": ("columns": ("mapperid"), "unique": True))),
    ),
    "primary_key": ("name": "pk_mappers", "columns": ("mapperid")),
    "driver": (
        "pgsql": get_pgsql_trigger_func("mappers", False, "mapperid", "seq_mappers"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("mappers", False, "mapperid", "seq_mappers"),
            "pgsql": get_pgsql_trigger("mappers"),
            "mysql": get_mysql_triggers("mappers", False, "mapperid", "seq_mappers"),
        ),
    ),
);

const T_MapperTags = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "mapperid": c_number(14, True),
        "tag": c_varchar(255, True),
        "value": c_varchar(4000, True),
        "created": c_timestamp(NN_TrueExceptMysql, "created date"),
        "modified": c_timestamp(False, "modified date"),
    ),
    "indexes": (
        "driver": ("oracle": ("pk_mapper_tags": ("columns": ("mapperid", "tag"), "unique": True))),
        "sk_mapper_tags_mapper": ("columns": ("mapperid")),
        "sk_mapper_tags_tags": ("columns": "tag"),
    ),
    "primary_key": ("name": "pk_mapper_tags", "columns": ("mapperid", "tag")),
    "foreign_constraints": (
        "fk_mapper_tags_mapper": ("columns": "mapperid", "table": "mappers"),
    ),
    "driver": (
        "pgsql": get_pgsql_trigger_func("mapper_tags"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("mapper_tags"),
            "pgsql": get_pgsql_trigger("mapper_tags"),
            "mysql": get_mysql_triggers("mapper_tags"),
        ),
    ),
);

const T_MapperLib = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "mapperid": c_number(14, True),
        "type": c_varchar(20, True),
        "name": c_varchar(160, True),
        "load_order": c_number(4, True) + {"default_value": 1},
    ),
    "indexes": (
        "driver": (
            "oracle": ("pk_mapper_lib": ("columns": ("mapperid", "type", "name"), "unique": True)),
            "fk_mapper_lib_type": ("columns": "type"),
            "fk_mapper_lib_mapperid": ("columns": "mapperid"),
        ),
    ),
    "primary_key": ("name": "pk_mapper_lib", "columns": ("mapperid", "type", "name")),
    "foreign_constraints": (
        "fk_mapper_lib_type": ("columns": "type", "table": "library_type", "target_columns": ("name")),
        "fk_mapper_lib_wfid": ("columns": "mapperid", "table": "mappers"),
    ),
);

const T_Sla = (
    "arch": Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "slaid": c_number(14, True, "the primary key for this table"),
        "name": c_varchar(200, True, "the unique SLA name"),
        "units": c_varchar(200, True, "the units for the sla_events.value column") + {"default_value": "seconds"},
        "description": c_varchar(4000, "the SLA description"),
        "created": c_timestamp(NN_TrueExceptMysql, "the SLA creation time"),
        "modified": c_timestamp("the SLA last modified time"),
    ),
    "indexes": (
        "driver": (
            "oracle": (
                "pk_sla": ("columns": ("slaid"), "unique": True),
                "sk_sla": ("columns": ("name"), "unique": True),
            ),
        ),
    ),
    "primary_key": ("name": "pk_sla", "columns": ("slaid")),
    "driver": (
        "pgsql": get_pgsql_trigger_func("sla", False, "slaid", "seq_sla"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("sla", False, "slaid", "seq_sla"),
            "pgsql": get_pgsql_trigger("sla"),
            "mysql": get_mysql_triggers("sla", False, "slaid", "seq_sla"),
        ),
    ),
);

const T_SlaEvents = (
    "arch" : (
        "type" : Arch::TYPE_LIVE,
        "data" : Arch::DATA_DATE,
    ),
    "columns": (
        "sla_eventid": c_number(14, True, "the primary key to this table"),
        "slaid": c_number(14, True, "a foreign key to the SLA table"),
        "value": c_number(True, "the SLA event value"),
        "producer": c_varchar(200, "the optional SLA event producer"),
        "success": c_number(1, True, "1 if the SLA event was successful, 0 if not"),
        "err": c_varchar(200, "an error code in case of SLA event errors"),
        "errdesc": c_varchar(4000, "an error description string in case of SLA event errors"),
        "created": c_timestamp(NN_TrueExceptMysql, "the SLA event creation time"),
    ),
    "primary_key": ("name": "pk_sla_events", "columns": ("sla_eventid")),
    "indexes": (
        "driver": (
            "oracle": (
                "pk_sla_events": ("columns": ("sla_eventid")),
                "sk_sla_events_sla": ("columns": ("slaid")),
            ),
            "sk_sla_events_created": ("columns": "created"),
        ),
    ),
    "foreign_constraints": (
        "sk_sla_events_sla": ("columns": ("slaid"), "table": "sla"),
    ),
    "driver": (
        "pgsql": get_pgsql_trigger_func("sla_events", True, "sla_eventid", "seq_sla_events", False),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("sla_events", True, "sla_eventid", "seq_sla_events"),
            "pgsql": get_pgsql_trigger("sla_events", True),
            "mysql": get_mysql_triggers("sla_events", True, "sla_eventid", "seq_sla_events")
        ),
    ),
);

const T_CustomStatuses = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "workflowid": c_number(14, True),
        "statusid": c_varchar(1, True),
        "description": c_varchar(4000),
        "created": c_date(NN_TrueExceptMysql),
        "modified": c_date(),
    ),
    "indexes": (
        "driver": ("oracle": ("pk_custom_statuses": ("columns": ("workflowid", "statusid"), "unique": True))),
    ),
    "primary_key": ("name": "pk_custom_statuses", "columns": ("workflowid", "statusid")),
    "driver": (
        "pgsql": get_pgsql_trigger_func("custom_statuses"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("custom_statuses"),
            "pgsql": get_pgsql_trigger("custom_statuses"),
            "mysql": get_mysql_triggers("custom_statuses"),
        ),
    ),
);

const T_LibraryType = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "name": c_varchar(20, True),
        "description": c_varchar(240, True),
    ),
    "indexes": (
        "driver": ("oracle": ("pk_library_type": ("columns": ("name"), "unique": True))),
    ),
    "primary_key": ("name": "pk_library_type", "columns": ("name")),
);

const T_ConfigItemValues = {
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": {
        "name": c_varchar(240, True, "the configuration item name with prefix"),
        "level": c_varchar(240, True, "the configuration item level"),
        "value": c_varchar(4000, False, "the current configuration item value as a serialized string"),
        "manually_updated": c_number(1, True, "1 = config item updated with the API, 0 = config item has its default "
            "value from the initial configuration") + {"default_value": 0},
        "created": c_timestamp(NN_TrueExceptMysql),
        "modified": c_timestamp(),
    },
    "indexes": {
        "driver": {
            "oracle": {
                "pk_config_item_values": {
                    "columns": ("name", "level"),
                    "unique": True,
                },
            },
        },
    },
    "primary_key": {
        "name": "pk_config_item_values",
        "columns": ("name", "level"),
    },
    "driver": {
        "pgsql": get_pgsql_trigger_func("config_item_values"),
    },
    "triggers": {
        "driver": {
            "oracle": get_oracle_trigger("config_item_values"),
            "pgsql": get_pgsql_trigger("config_item_values"),
            "mysql": get_mysql_triggers("config_item_values"),
        },
    },
};

const T_ServiceType = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "service_type": c_varchar(20, True),
        "description": c_varchar(240),
        "created": c_date(NN_TrueExceptMysql),
        "modified": c_date(),
    ),
    "indexes": (
        "driver": ("oracle": ("pk_service_type": ("columns": ("service_type"), "unique": True))),
    ),
    "primary_key": ("name": "pk_service_type", "columns": ("service_type")),
    "driver": (
        "pgsql": get_pgsql_trigger_func("service_type"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("service_type"),
            "pgsql": get_pgsql_trigger("service_type"),
            "mysql": get_mysql_triggers("service_type"),
        ),
    ),
);

const T_Loggers = {
    "arch" : {"type": Arch::TYPE_EXCLUDED},
    "columns": {
        "loggerid": c_number(14, True, "logger metadata ID number"),
        "interface_table_name": c_varchar(160, "name of interface table, if set then uses as a default logger for that type of interface"),
        "params": c_varchar(4000, "logger parameters (e.g. level(required), name, additivity"),
        "created": c_date(NN_TrueExceptMysql),
        "modified": c_date(),
    },
    "indexes": {
        "driver": {
            "oracle": {
                "pk_loggers": {"columns": ("loggerid"), "unique": True},
            }
        },
        "sk_loggers_interface_name": {"columns": "interface_table_name", "unique": True},
    },
    "primary_key": ("name": "pk_loggers", "columns": ("loggerid")),
    "driver": {
        "pgsql": get_pgsql_trigger_func("loggers", False, "loggerid", "seq_loggers"),
    },
    "triggers": {
        "driver": {
            "oracle": get_oracle_trigger("loggers", False, "loggerid", "seq_loggers"),
            "pgsql": get_pgsql_trigger("loggers"),
            "mysql": get_mysql_triggers("loggers", False, "loggerid", "seq_loggers"),
        },
    },
};

const T_Services = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "serviceid": c_number(14, True),
        "service_type": c_varchar(20, True),
        "name": c_varchar(160, True),
        "version": c_varchar(80, True),
        "patch": c_varchar(80),
        "description": c_varchar(4000),
        "author": c_varchar(240),
        "service_modules": c_varchar(4000, "a comma-separated list of service modules to use with this service"),
        "parse_options": c_varchar(500, "comma-separated parse options for the mapper source code"),
        "remote": c_number(1, True, "1 = the interface can run in a separate process, 0 = not") +
            {"default_value": 1},
        "manual_remote": c_number(1, True, "0 = remote has not been updated with the API, 1 = it has") +
            {"default_value": 0},
        "autostart": c_number(1, True) + {"default_value": 0},
        "manual_autostart": c_number(1, True) + {"default_value": 0},
        "class_source": c_clob(False, "service source for class-based services"),
        "class_name": c_varchar(160, False, "the name of the class for class-based services; if NULL then the "
            "service name is the class name; can only be set if class_source is not NULL"),
        "language": c_varchar(80, True, "programming language") + {"default_value": "qore"},
        "language_info": c_clob(False, "supplemental information for the programming language"),
        "yaml_config_items": c_clob(False, "config items defined in YAML"),
        "yaml_fsm_triggers": c_clob(False, "FSM triggers serialized in YAML (method -> FSM name)"),
        "api_manager": c_clob(False, "API manager information serialized in YAML"),
        "events": c_clob(False, "Event sources and handlers serialized in YAML"),
        "enabled": c_number(1, True) + {"default_value": 1},
        "loggerid": c_number(14, "each service can have its own logger, not set = use default logger"),
        "created": c_date(NN_TrueExceptMysql),
        "modified": c_date(),
    ),
    "indexes": (
        "driver": ("oracle": (
                       "pk_services": ("columns": ("serviceid"), "unique": True),
                   )),
        "sk_svc_st_name_version": ("columns": ("service_type", "name", "version"), "unique": True),
    ),
    "rename": (
        "constraint_map": ("pk_service": "pk_services"),
    ),
    "primary_key": ("name": "pk_services", "columns": ("serviceid")),
    "unique_constraints": (
        "sk_svc_st_name_version": ("columns": ("service_type", "name", "version")),
    ),
    "foreign_constraints": (
        "fk_svc_svc_type": ("columns": "service_type", "table": "service_type"),
        "fk_svc_loggerid": ("columns": "loggerid", "table": "loggers"),
    ),
    "driver": (
        "pgsql": get_pgsql_trigger_func("services", False, "serviceid", "seq_services"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("services", False, "serviceid", "seq_services"),
            "pgsql": get_pgsql_trigger("services"),
            "mysql": get_mysql_triggers("services", False, "serviceid", "seq_services"),
        ),
    ),
);

const T_ServiceTags = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "serviceid": c_number(14, True),
        "tag": c_varchar(255, True),
        "value": c_varchar(4000, True),
        "created": c_date(NN_TrueExceptMysql, False),
        "modified": c_date(False, False),
    ),
    "indexes": (
        "driver": ("oracle": ("pk_service_tags": ("columns": ("serviceid", "tag"), "unique": True))),
        "sk_service_tags_service": ("columns": ("serviceid")),
        "sk_service_tags_tags": ("columns": "tag"),
    ),
    "primary_key": ("name": "pk_service_tags", "columns": ("serviceid", "tag")),
    "foreign_constraints": (
        "fk_service_tags_service": ("columns": "serviceid", "table": "services"),
    ),
    "driver": (
        "pgsql": get_pgsql_trigger_func("service_tags"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("service_tags"),
            "pgsql": get_pgsql_trigger("service_tags"),
            "mysql": get_mysql_triggers("service_tags"),
        ),
    ),
);

const T_ServiceMethods = (
    "arch" : Arch::TEMPLATE_META_FULL,
    "columns": (
        "service_methodid": c_number(14, True),
        "serviceid": c_number(14, True),
        "name": c_varchar(160, True),
        "description": c_varchar(4000),
        "author": c_varchar(240),
        "locktype": c_varchar(40, True),
        "internal": c_number(1, True),
        "writeflag": c_number(1, True),
        "body": c_clob(False, "the service method body for function-based services, NULL for class-based services"),
        "slaid": c_number(14, "SLA associated to this method call"),
        "created": c_date(NN_TrueExceptMysql),
        "modified": c_date(),
    ),
    "indexes": (
        "driver": (
            "oracle": (
                "pk_service_methods": ("columns": ("service_methodid"), "unique": True),
            ),
        ),
        "sk_servmeth_serviceid": ("columns": ("serviceid")),
        "sk_servmeth_name_si": ("columns": ("name", "serviceid"), "unique": True),
        "sk_servmeth_sla": ("columns": ("slaid")),
    ),
    "primary_key": ("name": "pk_service_methods", "columns": ("service_methodid")),
    "unique_constraints": (
        "sk_servmeth_name_si": ("columns": ("name", "serviceid")),
    ),
    "foreign_constraints": (
        "fk_servmeth_serviceid": ("columns": "serviceid", "table": "services"),
        "fk_servmeth_sla": ("columns": "slaid", "table": "sla"),
    ),
    "driver": (
        "pgsql": get_pgsql_trigger_func("service_methods", False, "service_methodid", "seq_service_methods"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("service_methods", False, "service_methodid", "seq_service_methods"),
            "pgsql": get_pgsql_trigger("service_methods"),
            "mysql": get_mysql_triggers("service_methods", False, "service_methodid", "seq_service_methods"),
        ),
    ),
);

const T_ServiceMethodTags = (
    "arch" : Arch::TEMPLATE_META_FULL,
    "columns": (
        "service_methodid": c_number(14, True),
        "tag": c_varchar(255, True),
        "value": c_varchar(4000, True),
        "created": c_date(NN_TrueExceptMysql, False),
        "modified": c_date(False, False),
    ),
    "rename": (
        "index_map": (
            "sk_service_method_tags_service_method": "sk_set_service_method",
            "sk_service_method_tags_tags": "sk_set_tags",
        ),
        "constraint_map": (
            "fk_service_method_tags_service_method": "fk_set_service_method",
        ),
    ),
    "indexes": (
        "driver": ("oracle": ("pk_service_method_tags": ("columns": ("service_methodid", "tag"), "unique": True))),
        "sk_set_service_method": ("columns": ("service_methodid")),
        "sk_set_tags": ("columns": "tag"),
    ),
    "primary_key": ("name": "pk_service_method_tags", "columns": ("service_methodid", "tag")),
    "foreign_constraints": (
        "fk_set_service_method": ("columns": "service_methodid", "table": "service_methods"),
    ),
    "driver": (
        "pgsql": get_pgsql_trigger_func("service_method_tags"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("service_method_tags"),
            "pgsql": get_pgsql_trigger("service_method_tags"),
            "mysql": get_mysql_triggers("service_method_tags"),
        ),
    ),
);

const T_ServiceFileResourceTypes = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "resource_type": c_char(1, True),
        "description": c_varchar(240),
    ),
    "indexes": (
        "driver": ("oracle": ("pk_service_file_resource_types": ("columns": ("resource_type"), "unique": True))),
    ),
    "primary_key": ("name": "pk_service_file_resource_types", "columns": ("resource_type")),
);

const T_ServiceFileResources = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "serviceid": c_number(14, True),
        "name": c_varchar(255, True),
        #"content_type": c_varchar(255, True),
        "resource_type": c_char(1, True),
        "body": c_blob("the file resource body"),
        "created": c_date(NN_TrueExceptMysql, False),
        "modified": c_date(False, False),
    ),
    "indexes": (
        "driver": ("oracle": ("pk_service_file_resources": ("columns": ("serviceid", "name"), "unique": True))),
        "sk_service_fr_service": ("columns": ("serviceid")),
        "sk_service_fr_type": ("columns": ("resource_type")),
    ),
    "primary_key": ("name": "pk_service_file_resources", "columns": ("serviceid", "name")),
    "foreign_constraints": (
        "fk_service_fr_service": ("columns": "serviceid", "table": "services"),
        "fk_service_fr_type": ("columns": "resource_type", "table": "service_file_resource_types"),
    ),
    "driver": (
        "pgsql": get_pgsql_trigger_func("service_file_resources"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("service_file_resources"),
            "pgsql": get_pgsql_trigger("service_file_resources"),
            "mysql": get_mysql_triggers("service_file_resources"),
        ),
    ),
);

const T_ServiceStateData = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "serviceid": c_number(14, True, "service metadata ID number"),
        "data": c_clob("service state recovery data"),

        "created": c_timestamp(NN_TrueExceptMysql),
        "modified": c_timestamp(),
    ),
    "indexes": (
        "driver": (
            "oracle": (
                "pk_service_state_data": ("columns": ("serviceid"), "unique": True),
            ),
        ),
    ),
    "foreign_constraints": (
        "fk_service_sd_services": ("columns": ("serviceid"), "table": "services"),
    ),
    "primary_key": ("name": "pk_service_state_data", "columns": ("serviceid")),
    "driver": (
        "pgsql": get_pgsql_trigger_func("service_state_data"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("service_state_data"),
            "pgsql": get_pgsql_trigger("service_state_data"),
            "mysql": get_mysql_triggers("service_state_data"),
        ),
    ),
);

const T_ServiceConfigItems = {
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": {
        "serviceid": c_number(14, True, "service metadata ID number"),
        "name": c_varchar(240, True, "the configuration item name with prefix"),
        "prefix": c_varchar(240, False, "the configuration item prefix"),
        "type": c_varchar(240, True, "the configuration item type"),
        "default_value": c_varchar(4000, False, "the configuration item default value as a serialized string"),
        "strictly_local": c_number(1, True, "allow this config item to be overridden at the next level") +
            {"default_value": 1},
        "description": c_varchar(4000, "the description of the configuration item"),
        "config_group": c_varchar(240, True, "the group of the configuration item") + {"default_value": "Default"},
        "allowed_values": c_varchar(4000, False, "the list of allowed values of the configuration item"),
        "sensitive": c_number(1, True, "sensitive field flag") + {"default_value": 0},

        "created": c_timestamp(NN_TrueExceptMysql),
        "modified": c_timestamp(),
    },
    "indexes": {
        "driver": {
            "oracle": {
                "pk_service_config_items": {
                    "columns": ("serviceid", "name"),
                    "unique": True,
                },
            },
        },
    },
    "foreign_constraints": {
        "fk_service_ci_services": {
            "columns": ("serviceid"),
            "table": "services",
        },
    },
    "primary_key": {
        "name": "pk_service_config_items",
        "columns": ("serviceid", "name"),
    },
    "driver": {
        "pgsql": get_pgsql_trigger_func("service_config_items"),
    },
    "triggers": {
        "driver": {
            "oracle": get_oracle_trigger("service_config_items"),
            "pgsql": get_pgsql_trigger("service_config_items"),
            "mysql": get_mysql_triggers("service_config_items"),
        },
    },
};

const T_ServiceOptions = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "serviceid": c_number(14, True),
        "config": c_number(1),
        "name": c_varchar(80, True),
        "description": c_varchar(4000, True),
        "value": c_varchar(4000),
        "created": c_date(NN_TrueExceptMysql),
        "modified": c_date(),
    ),
    "indexes": (
        "driver": ("oracle": ("pk_service_options": ("columns": ("serviceid", "name"), "unique": True))),
    ),
    "foreign_constraints": (
        "fk_svco_services": ("columns": ("serviceid"), "table": "services"),
    ),
    "primary_key": ("name": "pk_service_options", "columns": ("serviceid", "name")),
    "driver": (
        "pgsql": get_pgsql_trigger_func("service_options"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("service_options"),
            "pgsql": get_pgsql_trigger("service_options"),
            "mysql": get_mysql_triggers("service_options"),
        ),
    ),
);

const T_Queues = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "queueid": c_number(14, True),
        "name": c_varchar(160, True),
        "description": c_varchar(4000),
        "serviceid": c_number(14),
        "created": c_date(NN_TrueExceptMysql),
        "modified": c_date(),
    ),
    "indexes": (
        "driver": ("oracle": (
                       "pk_queues": ("columns": ("queueid"), "unique": True),
                   )),
        "sk_queues_serviceid": ("columns": ("serviceid")),
        "sk_queues_name": ("columns": ("name"), "unique": True),
    ),
    "primary_key": ("name": "pk_queues", "columns": ("queueid")),
    "unique_constraints": (
        "sk_queues_name": ("columns": ("name")),
    ),
    "foreign_constraints": (
        "fk_queues_services": ("columns": "serviceid", "table": "services"),
    ),
    "driver": (
        "pgsql": get_pgsql_trigger_func("queues", False, "queueid", "seq_queues"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("queues", False, "queueid", "seq_queues"),
            "pgsql": get_pgsql_trigger("queues"),
            "mysql": get_mysql_triggers("queues", False, "queueid", "seq_queues"),
        ),
    ),
);

const T_QueueTags = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "queueid": c_number(14, True),
        "tag": c_varchar(255, True),
        "value": c_varchar(4000, True),
        "created": c_date(NN_TrueExceptMysql, False),
        "modified": c_date(False, False),
    ),
    "indexes": (
        "driver": ("oracle": ("pk_queue_tags": ("columns": ("queueid", "tag"), "unique": True))),
        "sk_queue_tags_queue": ("columns": ("queueid")),
        "sk_queue_tags_tags": ("columns": "tag"),
    ),
    "primary_key": ("name": "pk_queue_tags", "columns": ("queueid", "tag")),
    "foreign_constraints": (
        "fk_queue_tags_queue": ("columns": "queueid", "table": "queues"),
    ),
    "driver": (
        "pgsql": get_pgsql_trigger_func("queue_tags"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("queue_tags"),
            "pgsql": get_pgsql_trigger("queue_tags"),
            "mysql": get_mysql_triggers("queue_tags"),
        ),
    ),
);

const T_WorkflowEventTypes = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "workflow_event_typeid": c_number(14, True),
        "name": c_varchar(160, True),
        "description": c_varchar(4000),
        "created": c_date(NN_TrueExceptMysql),
        "modified": c_date(),
    ),
    "indexes": (
        "driver": ("oracle": (
                       "pk_workflow_event_types": ("columns": ("workflow_event_typeid"), "unique": True),
                   )),
        "sk_workflow_event_types_name": ("columns": ("name"), "unique": True),
    ),
    "primary_key": ("name": "pk_workflow_event_types", "columns": ("workflow_event_typeid")),
    "unique_constraints": (
        "sk_workflow_event_types_name": ("columns": ("name")),
    ),
    "driver": (
        "pgsql": get_pgsql_trigger_func("workflow_event_types", False, "workflow_event_typeid", "seq_workflow_event_types"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("workflow_event_types", False, "workflow_event_typeid", "seq_workflow_event_types"),
            "pgsql": get_pgsql_trigger("workflow_event_types"),
            "mysql": get_mysql_triggers("workflow_event_types", False, "workflow_event_typeid", "seq_workflow_event_types"),
        ),
    ),
);

const T_WorkflowEventTypesTags = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "workflow_event_typeid": c_number(14, True),
        "tag": c_varchar(255, True),
        "value": c_varchar(4000, True),
        "created": c_date(NN_TrueExceptMysql, False),
        "modified": c_date(False, False),
    ),
    "rename": (
        "index_map": (
            "sk_workflow_event_type_tags_workflow_event_type": "sk_wet_tags_wet",
            "sk_workflow_event_type_tags_tags": "sk_wet_tags_tags",
        ),
        "constraint_map": (
            "pk_workflow_event_type_tags": "pk_wet_tags",
            "fk_workflow_event_type_tags_workflow_event_type": "fk_wet_tags_wet",
        ),
    ),
    "indexes": (
        "driver": ("oracle": ("pk_wet_tags": ("columns": ("workflow_event_typeid", "tag"), "unique": True))),
        "sk_wet_tags_wet": ("columns": ("workflow_event_typeid")),
        "sk_wet_tags_tags": ("columns": "tag"),
    ),
    "primary_key": ("name": "pk_wet_tags", "columns": ("workflow_event_typeid", "tag")),
    "foreign_constraints": (
        "fk_wet_tags_wet": ("columns": "workflow_event_typeid", "table": "workflow_event_types"),
    ),
    "driver": (
        "pgsql": get_pgsql_trigger_func("workflow_event_types_tags"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("workflow_event_types_tags"),
            "pgsql": get_pgsql_trigger("workflow_event_types_tags"),
            "mysql": get_mysql_triggers("workflow_event_types_tags"),
        ),
    ),
);

const T_StepType = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "steptype": c_varchar(40, True),
        "description": c_varchar(240),
        "created": c_date(NN_TrueExceptMysql),
        "modified": c_date(),
    ),
    "indexes": (
        "driver": ("oracle": ("pk_step_type": ("columns": ("steptype"), "unique": True))),
    ),
    "primary_key": ("name": "pk_step_type", "columns": ("steptype")),
    "driver": (
        "pgsql": get_pgsql_trigger_func("step_type"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("step_type"),
            "pgsql": get_pgsql_trigger("step_type"),
            "mysql": get_mysql_triggers("step_type"),
        ),
    ),
);

const T_StepArrayType = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "arraytype": c_varchar(20, True),
        "description": c_varchar(240),
        "created": c_date(NN_TrueExceptMysql),
        "modified": c_date(),
    ),
    "indexes": (
        "driver": ("oracle": ("pk_step_arraytype": ("columns": ("arraytype"), "unique": True))),
    ),
    "primary_key": ("name": "pk_step_arraytype", "columns": ("arraytype")),
    "driver": (
        "pgsql": get_pgsql_trigger_func("step_arraytype"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("step_arraytype"),
            "pgsql": get_pgsql_trigger("step_arraytype"),
            "mysql": get_mysql_triggers("step_arraytype"),
        ),
    ),
);

const T_Steps = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "stepid": c_number(14, True, "unique ID for the step and the PK for this table"),
        "steptype": c_varchar(40, True),
        "arraytype": c_varchar(20, True),
        "name": c_varchar(160, True),
        "version": c_varchar(80, True),
        "patch": c_varchar(80),
        "description": c_varchar(4000),
        "author": c_varchar(240, "the author of the step"),
        "step_classid": c_number(14, False, "the classid of the step implementation, if applicable, either this or "
            "stepfunction_instanceid must be set"),
        "stepfunction_instanceid": c_number(14, False, "the functionid of the primary step function, if applicable, "
            "either this or step_classid must be set"),
        "validationfunction_instanceid": c_number(14, "the functionid of the validation step function, if applicable, "
            "may not be set if step_classid is set"),
        "endfunction_instanceid": c_number(14, "the functionid of the asynchronous end step function, if applicable, "
            "may not be set if step_classid is set"),
        "arrayfunction_instanceid": c_number(14, "the functionid of the array function, if applicable, may not be set "
            "if step_classid is set"),
        "classname": c_varchar(160, False, "the name of the class for class-based steps; if NULL then the step name "
            "is the class name; can only be set if code is not NULL"),
        "code": c_clob("for steps defined in YAML"),
        "yaml_fsm_triggers": c_clob(False, "FSM triggers serialized in YAML (method -> FSM name)"),
        "language": c_varchar(80, True, "workflow class programming language") + {"default_value": "qore"},
        "language_info": c_clob(False, "supplemental information for the step class programming language"),
        "queueid": c_number(14),
        "user_interaction": c_number(1, True, "set to 1 if the step is an asynchronous step that should support user "
            "interactions") + {"default_value": 0},
        "userdata": c_clob("additional serialized step metadata"),
        "workflow_event_typeid": c_number(14),
        "yaml_config_items": c_clob(False, "config items defined in YAML"),
        "created": c_date(NN_TrueExceptMysql),
        "modified": c_date(),
    ),
    "indexes": (
        "driver": {
            "oracle": {
                "pk_steps": {
                    "columns": ("stepid"),
                    "unique": True,
                },
            },
        },
        "sk_steps_steptype": ("columns": ("steptype")),
        "sk_steps_arraytype": ("columns": ("arraytype")),
        "sk_steps_fi1": ("columns": ("stepfunction_instanceid")),
        "sk_steps_fi2": ("columns": ("endfunction_instanceid")),
        "sk_steps_fi3": ("columns": ("validationfunction_instanceid")),
        "sk_steps_fi4": ("columns": ("arrayfunction_instanceid")),
        "sk_steps_queueid": ("columns": ("queueid")),
        "sk_steps_wfet": ("columns": ("workflow_event_typeid")),
        "sk_steps_name": ("columns": ("name", "version"), "unique": True),
    ),
    "primary_key": ("name": "pk_steps", "columns": ("stepid")),
    "unique_constraints": (
        "sk_steps_name": ("columns": ("name", "version")),
    ),
    "foreign_constraints": (
        "fk_steps_steptype": ("columns": ("steptype"), "table": "step_type"),
        "fk_steps_func_inst1": ("columns": ("stepfunction_instanceid"), "table": "function_instance", "target_columns": ("function_instanceid")),
        "fk_steps_func_inst2": ("columns": ("endfunction_instanceid"), "table": "function_instance", "target_columns": ("function_instanceid")),
        "fk_steps_func_inst3": ("columns": ("validationfunction_instanceid"), "table": "function_instance", "target_columns": ("function_instanceid")),
        "fk_steps_func_inst4": ("columns": ("arrayfunction_instanceid"), "table": "function_instance", "target_columns": ("function_instanceid")),
        "fk_steps_queues": ("columns": ("queueid"), "table": "queues"),
        "fk_steps_fwet": ("columns": ("workflow_event_typeid"), "table": "workflow_event_types"),
    ),
    "driver": (
        "pgsql": get_pgsql_trigger_func("steps", False, "stepid", "seq_steps"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("steps", False, "stepid", "seq_steps"),
            "pgsql": get_pgsql_trigger("steps"),
            "mysql": get_mysql_triggers("steps", False, "stepid", "seq_steps"),
        ),
    ),
);

const T_StepStatus = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "stepstatus": c_char(1, True),
        "description": c_varchar(240),
    ),
    "indexes": (
        "driver": ("oracle": (
                   "pk_step_status": ("columns": ("stepstatus"), "unique": True),
        )),
    ),
    "primary_key": ("name": "pk_step_status", "columns": ("stepstatus")),
);

const T_StepTags = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "stepid": c_number(14, True),
        "tag": c_varchar(255, True),
        "value": c_varchar(4000, True),
        "created": c_date(NN_TrueExceptMysql, False),
        "modified": c_date(False, False),
    ),
    "indexes": (
        "driver": ("oracle": ("pk_step_tags": ("columns": ("stepid", "tag"), "unique": True))),
        "sk_step_tags_step": ("columns": ("stepid")),
        "sk_step_tags_tags": ("columns": "tag"),
    ),
    "primary_key": ("name": "pk_step_tags", "columns": ("stepid", "tag")),
    "foreign_constraints": (
        "fk_step_tags_step": ("columns": "stepid", "table": "steps"),
    ),
    "driver": (
        "pgsql": get_pgsql_trigger_func("step_tags"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("step_tags"),
            "pgsql": get_pgsql_trigger("step_tags"),
            "mysql": get_mysql_triggers("step_tags"),
       ),
    ),
);

const T_StepConfigItems = {
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": {
        "stepid": c_number(14, True, "step metadata ID number"),
        "name": c_varchar(240, True, "the configuration item name with prefix"),
        "prefix": c_varchar(240, False, "the configuration item prefix"),
        "type": c_varchar(240, True, "the configuration item type"),
        "default_value": c_varchar(4000, False, "the configuration item default value as a serialized string"),
        "strictly_local": c_number(1, True, "allow this config item to be overridden at the next level") +
            {"default_value": 1},
        "description": c_varchar(4000, "the description of the configuration item"),
        "config_group": c_varchar(240, True, "the group of the configuration item") + {"default_value": "Default"},
        "allowed_values": c_varchar(4000, False, "the list of allowed values of the configuration item"),
        "sensitive": c_number(1, True, "sensitive field flag") + {"default_value": 0},

        "created": c_timestamp(NN_TrueExceptMysql),
        "modified": c_timestamp(),
    },
    "indexes": {
        "driver": {
            "oracle": {
                "pk_step_config_items": {
                    "columns": ("stepid", "name"),
                    "unique": True,
                },
            },
        },
    },
    "foreign_constraints": {
        "fk_step_ci_steps": {
            "columns": ("stepid"),
            "table": "steps",
        },
    },
    "primary_key": {
        "name": "pk_step_config_items",
        "columns": ("stepid", "name"),
    },
    "driver": {
        "pgsql": get_pgsql_trigger_func("step_config_items"),
    },
    "triggers": {
        "driver": {
            "oracle": get_oracle_trigger("step_config_items"),
            "pgsql": get_pgsql_trigger("step_config_items"),
            "mysql": get_mysql_triggers("step_config_items"),
        },
    },
};

const T_Workflows = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "workflowid": c_number(14, True),
        "name": c_varchar(160, True),
        "version": c_varchar(80, True),
        "patch": c_varchar(80),
        "description": c_varchar(4000),
        "author": c_varchar(240),
        "remote": c_number(1, True, "1 = the interface can run in a separate process, 0 = not") +
            {"default_value": 1},
        "manual_remote": c_number(1, True, "0 = remote has not been updated withh the API, 1 = it has") +
            {"default_value": 0},
        "workflow_modules": c_varchar(4000, "a comma-separated list of workflow modules to use with this workflow"),
        "open": c_number(1, True, "1 = the workflow session is open independently, 0 = not") + {"default_value": 0},
        "autostart": c_number(2, True) + {"default_value": 0},
        "manual_autostart": c_number(1, True) + {"default_value": 0},
        "max_instances": c_number(2),
        "enabled": c_number(1, True) + {"default_value": 1},
        "sla_threshold": c_number(14, True, "number of seconds in which a workflow should get a final status") + {"default_value": 1800},
        "manual_sla_threshold": c_number(1, True, "if the sla_threshold has been updated with the API, then it will not get overwritten by default with oload") + {"default_value": 0},
        "has_detach": c_number(1, True, "1 = the workflow has detach logic") + {"default_value": 0},
        "code": c_clob(),
        "language": c_varchar(80, True, "workflow class programming language") + {"default_value": "qore"},
        "language_info": c_clob(False, "supplemental information for the workflow class programming language"),
        "class_name": c_varchar(160, False, "the name of the class for class-based workflows; if NULL then the "
            "workflow name is the class name; can only be set if code is set"),
        "staticdata_type_path": c_varchar(4000, False, "path to the static data type"),
        "errorfunction_instanceid": c_number(14),
        "attach_func_instanceid": c_number(14),
        "detach_func_instanceid": c_number(14),
        "onetimeinit_func_instanceid": c_number(14),
        "errhandler_func_instanceid": c_number(14),
        "loggerid": c_number(14, "each workflow can have its own logger, not set = use default logger"),
        "deprecated": c_number(1, True) + {"default_value": 0},
        "created": c_date(NN_TrueExceptMysql),
        "modified": c_date(),
    ),
    "indexes": (
        "driver": (
            "oracle": (
                "pk_workflows": ("columns": ("workflowid"), "unique": True),
            ),
            "mysql": (
                "fk_workflows_errfunction": ("columns": "errorfunction_instanceid"),
                "fk_workflows_attachfunc": ("columns": "attach_func_instanceid"),
                "fk_workflows_detachfunc": ("columns": "detach_func_instanceid"),
                "fk_workflows_otifunc": ("columns": "onetimeinit_func_instanceid"),
                "fk_workflows_errhandlerfunc": ("columns": "errhandler_func_instanceid"),
            ),
        ),
        "uk_workflows_name": ("columns": ("name", "version"), "unique": True),
        "sk_workflows_name": ("columns": ("name")),
        "sk_workflows_errorfunction": ("columns": "errorfunction_instanceid"),
    ),
    "primary_key": ("name": "pk_workflows", "columns": ("workflowid")),
    "unique_constraints": (
        "uk_workflows_name": ("columns": ("name", "version")),
    ),
    "foreign_constraints": (
        "fk_workflows_errfunction": ("columns": "errorfunction_instanceid", "table": "function_instance", "target_columns": ("function_instanceid")),
        "fk_workflows_attachfunc": ("columns": "attach_func_instanceid", "table": "function_instance", "target_columns": ("function_instanceid")),
        "fk_workflows_detachfunc": ("columns": "detach_func_instanceid", "table": "function_instance", "target_columns": ("function_instanceid")),
        "fk_workflows_otifunc": ("columns": "onetimeinit_func_instanceid", "table": "function_instance", "target_columns": ("function_instanceid")),
        "fk_workflows_errhandlerfunc": ("columns": "errhandler_func_instanceid", "table": "function_instance", "target_columns": ("function_instanceid")),
        "fk_workflows_loggerid": ("columns": "loggerid", "table": "loggers"),
    ),
    "driver": (
        "pgsql": get_pgsql_trigger_func("workflows", False, "workflowid", "seq_workflows"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("workflows", False, "workflowid", "seq_workflows"),
            "pgsql": get_pgsql_trigger("workflows"),
            "mysql": get_mysql_triggers("workflows", False, "workflowid", "seq_workflows"),
        ),
    ),
);

const T_WorkflowTags = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "workflowid": c_number(14, True),
        "tag": c_varchar(255, True),
        "value": c_varchar(4000, True),
        "created": c_date(NN_TrueExceptMysql, False),
        "modified": c_date(False, False),
    ),
    "indexes": (
        "driver": ("oracle": ("pk_workflow_tags": ("columns": ("workflowid", "tag"), "unique": True))),
        "sk_workflow_tags_workflow": ("columns": ("workflowid")),
        "sk_workflow_tags_tags": ("columns": "tag"),
    ),
    "primary_key": ("name": "pk_workflow_tags", "columns": ("workflowid", "tag")),
    "foreign_constraints": (
        "fk_workflow_tags_workflow": ("columns": "workflowid", "table": "workflows"),
    ),
    "driver": (
        "pgsql": get_pgsql_trigger_func("workflow_tags"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("workflow_tags"),
            "pgsql": get_pgsql_trigger("workflow_tags"),
            "mysql": get_mysql_triggers("workflow_tags"),
        ),
    ),
);

const T_WorkflowStatus = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "workflowstatus": c_char(1, True),
        "description": c_varchar(240),
    ),
    "indexes": (
        "driver": ("oracle": ("pk_workflow_status": ("columns": ("workflowstatus"), "unique": True))),
    ),
    "primary_key": ("name": "pk_workflow_status", "columns": ("workflowstatus")),
);

const T_GlobalWorkflowErrors = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "error": c_varchar(255, True),
        "description": c_varchar(4000),
        "severity": c_varchar(80, True),
        "status": c_char(1, True) + {"default_value": "E"},
        "business_flag": c_number(1, True),
        "retry_delay_secs": c_number(14),
        "created": c_date(NN_TrueExceptMysql, False),
        "modified": c_date(False, False),
    ),
    "indexes": (
        "driver": ("oracle": ("pk_global_workflow_errors": ("columns": ("error"), "unique": True))),
    ),
    "primary_key": ("name": "pk_global_workflow_errors", "columns": ("error")),
    "driver": (
        "pgsql": get_pgsql_trigger_func("global_workflow_errors"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("global_workflow_errors"),
            "pgsql": get_pgsql_trigger("global_workflow_errors"),
            "mysql": get_mysql_triggers("global_workflow_errors"),
        ),
    ),
);

const T_WorkflowErrors = {
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": {
        "workflowid": c_number(14, True),
        "error": c_varchar(255, True),
        "description": c_varchar(4000),
        "severity": c_varchar(80),
        "status": c_char(1, True) + {"default_value": "E"},
        "business_flag": c_number(1),
        "retry_delay_secs": c_number(14),
        "manually_updated": c_number(1, True),
        "created": c_date(NN_TrueExceptMysql, False),
        "modified": c_date(False, False),
    },
    "indexes": {
        "driver": {"oracle": ("pk_workflow_errors": ("columns": ("workflowid", "error"), "unique": True))},
        "sk_workflow_errors_workflowid": {"columns": ("workflowid")},
        "sk_workflow_errors_error": {"columns": ("error")},
    },
    "foreign_constraints": {
        "fk_workflow_errors_workflowid": {"columns": ("workflowid"), "table": "workflows"},
    },
    "primary_key": {"name": "pk_workflow_errors", "columns": ("workflowid", "error")},
    "driver": {
        "pgsql": get_pgsql_trigger_func("workflow_errors"),
    },
    "triggers": {
        "driver": {
            "oracle": get_oracle_trigger("workflow_errors"),
            "pgsql": get_pgsql_trigger("workflow_errors"),
            "mysql": get_mysql_triggers("workflow_errors"),
        },
    },
};

const T_WorkflowInstance = (
    "arch" : Arch::TEMPLATE_WFIID,
    "columns": (
        "workflow_instanceid": c_number(14, True, "workflow instance ID and PK"),
        "workflowid": c_number(14, True, "workflow metadata ID"),
        "workflowstatus": c_char(1, True, "current workflow processing status"),
        "status_sessionid": c_number(14, True, "Qorus session that owns the workflow order instance"),
        "parent_workflow_instanceid": c_number(14, "optional parent workflow instance ID"),
        "subworkflow": c_number(1, "1 = has a strongly-bound parent workflow instance"),
        "synchronous": c_number(1, True, "1 = workflow executed synchronously"),
        "warnings": c_number(9, "number of warnings saved against the order"),
        "errors": c_number(9, "number of times the order got an E=ERROR status"),
        "retries": c_number(9, "number of times the order got a R=RETRY status"),
        "note_count": c_number(5, True, "the number of notes attached to this record") + {"default_value": 0},
        "business_error": c_number(1),
        "workflowstatus_orig": c_char(1, "saved workflow status in case of B=BLOCKED or X=CANCELED"),
        "custom_status": c_char(1),
        "scheduled": c_date(False, "optional date indicating that the order cannot be processed before the given date"),
        "priority": c_number(3, True, "order priority; lower numbers have high priority") + {"default_value": 500},
        "started": c_date(NN_TrueExceptMysql, True, "date/time the workflow order instance was created"),
        "completed": c_date(False, "date/time the workflow order instance got its C=COMPLETE status"),
        "modified": c_date(False, "date/time this record was last modified"),
        "operator_lock": c_varchar(100, "operator lock field"),

        "driver": (
            "oracle": ("custom_status": c_varchar(1)),
            "mysql": ("modified_date": ("native_type": "date")),
        ),
    ),
    "indexes": (
        "driver": (
            "oracle": (
                "pk_workflow_instance": ("columns": ("workflow_instanceid"), "unique": True),
                "workflow_instance_modified": ("columns": ("trunc(modified)")),
            ),
            "pgsql": (
                "workflow_instance_modified": ("columns": ("date_trunc('day'::text, modified)")),
            ),
        ),
        "sk_wfi_workflowid": ("columns": ("workflowid")),
        "sk_wfi_workflowstatus": ("columns": ("workflowstatus")),
        "sk_wfi_status_sessionid": ("columns": ("status_sessionid")),
        "sk_wfi_parent_wfiid": ("columns": ("parent_workflow_instanceid")),
    ),
    "foreign_constraints": (
        "fk_workflow_instance_workflow": ("columns": ("workflowid"), "table": "workflows"),
        "fk_wf_instance_wf_status": ("columns": ("workflowstatus"), "table": "workflow_status"),
        "fk_wf_instance_sessions": ("columns": ("status_sessionid"), "table": "sessions", "target_columns": ("sessionid")),
        "sk_wfi_parent_wfiid": ("columns": ("parent_workflow_instanceid"), "table": "workflow_instance", "target_columns": ("workflow_instanceid")),
    ),
    "primary_key": ("name": "pk_workflow_instance", "columns": ("workflow_instanceid")),
    "driver": (
        "pgsql": (
            "functions": (
                "trig_workflow_instance_insert()": "returns trigger language plpgsql as $function$
begin
  --
  if new.modified is null then
    select current_timestamp into new.modified;
  end if;
 --
  if new.started is null then
    select current_timestamp into new.started;
  end if;
  if new.workflow_instanceid is null then
    select nextval('seq_workflow_instance') into new.workflow_instanceid;
  end if;
  if new.workflowstatus is null then
    select 'I' into new.workflowstatus;
  end if;
  if new.status_sessionid is null then
    select 0 into new.status_sessionid;
  end if;
  --
  -- snapshots
  insert into workflow_instance_stats_stage
        (
        rowid,
        objectid,
        modified_orig,
        modified_new,
        status_orig,
        status_new,
        dml_operation,
        created
        )
        values
        (
        nextval('seq_workflow_instance_stats_stage'),
        new.workflowid,
        null,
        date_trunc('hour', new.modified),
        null,
        new.workflowstatus,
        'I',
        current_timestamp
        );
  -- snapshots
  return new;
end;
$function$", #",
                "trig_workflow_instance_update()": "returns trigger language plpgsql as $function$
declare
    stats_new_modified timestamp;
    stats_old_modified timestamp;
begin
  --
  if new.modified is null or new.modified = old.modified then
    select current_timestamp into new.modified;
  end if;
  --
  if new.workflowstatus = 'C' and new.completed is null then
    select current_timestamp into new.completed;
  end if;
  -- snapshots
  stats_new_modified := date_trunc('hour', new.modified);
  stats_old_modified := date_trunc('hour', old.modified);
  if (stats_old_modified != stats_new_modified
      or old.workflowstatus != new.workflowstatus) then
    insert into workflow_instance_stats_stage
        (
        rowid,
        objectid,
        modified_orig,
        modified_new,
        status_orig,
        status_new,
        dml_operation,
        created
        )
        values
        (
        nextval('seq_workflow_instance_stats_stage'),
        new.workflowid,
        stats_old_modified,
        stats_new_modified,
        old.workflowstatus,
        new.workflowstatus,
        'U',
        current_timestamp
        );
  end if;
  -- snapshots
  return new;
end;
$function$", #",
                "trig_workflow_instance_delete()": "returns trigger language plpgsql as $function$
begin
  -- snapshots
  insert into workflow_instance_stats_stage
        (
        rowid,
        objectid,
        modified_orig,
        modified_new,
        status_orig,
        status_new,
        dml_operation,
        created
        )
        values
        (
        nextval('seq_workflow_instance_stats_stage'),
        old.workflowid,
        date_trunc('hour', old.modified),
        null,
        old.workflowstatus,
        null,
        'D',
        current_timestamp
        );
  -- snapshots
  return old;
end;
$function$", #",
            ),
        ),
    ),
    "triggers": (
        "driver": (
            "oracle": (
                "trig_workflow_instance": "BEFORE INSERT OR UPDATE OR DELETE OF WORKFLOW_INSTANCEID, WORKFLOWID, WORKFLOWSTATUS,
                           -- STATUS_SESSIONID is a no-no here! Do not change MODIFIED on WF reset (where status_sessionid is handled only without any additional columns
                           PARENT_WORKFLOW_INSTANCEID, SUBWORKFLOW, SYNCHRONOUS, WARNINGS,
                           ERRORS, BUSINESS_ERROR, WORKFLOWSTATUS_ORIG,
                           CUSTOM_STATUS, SCHEDULED, PRIORITY, STARTED,
                           COMPLETED, MODIFIED, OPERATOR_LOCK, NOTE_COUNT
    ON WORKFLOW_INSTANCE
REFERENCING NEW AS NEW OLD AS OLD
FOR EACH ROW
declare
    dml_operation varchar2(1) := 'D';
    workflowid number(14) := :old.workflowid;
    stats_new_modified date;
    stats_old_modified date;
begin
  --
  if inserting or updating then
    --
    if :new.modified is null or :new.modified = :old.modified then
      :new.modified := sysdate;
    end if;
    --
  end if;
  --
  if inserting then
    if :new.started is null then
      :new.started := sysdate;
    end if;
    if :new.workflow_instanceid is null then
      select seq_workflow_instance.nextval into :new.workflow_instanceid from dual;
    end if;
    if :new.workflowstatus is null then
      :new.workflowstatus := 'I';
    end if;
    if :new.status_sessionid is null then
      :new.status_sessionid := 0;
    end if;
    --
    dml_operation := 'I';
    workflowid := :new.workflowid;
    --
  else
    if updating then
      if :new.workflowstatus = 'C' and :new.completed is null then
        :new.completed := sysdate;
      end if;
      --
      dml_operation := 'U';
    end if;
  end if;
  --
  -- snapshots
  stats_new_modified := trunc(:new.modified, 'HH24');
  stats_old_modified := trunc(:old.modified, 'HH24');
  if (inserting or deleting
      or (updating and (stats_old_modified != stats_new_modified
                        or :old.workflowstatus != :new.workflowstatus)
         )
     ) then
    insert into workflow_instance_stats_stage
        (
        objectid,
        modified_orig,
        modified_new,
        status_orig,
        status_new,
        dml_operation,
        created
        )
        values
        (
        workflowid,
        stats_old_modified,
        stats_new_modified,
        :old.workflowstatus,
        :new.workflowstatus,
        dml_operation,
        current_timestamp
        );
  end if;
  -- snapshots
end;",
            ),
            "pgsql": {
                "trig_workflow_instance_insert" :
                    "before insert on workflow_instance for each row "
                    "execute procedure trig_workflow_instance_insert()",
                "trig_workflow_instance_update" :
                            "before update OF WORKFLOW_INSTANCEID, WORKFLOWID, WORKFLOWSTATUS,
                           -- STATUS_SESSIONID is a no-no here! Do not change MODIFIED on WF reset (where status_sessionid is handled only without any additional columns
                           PARENT_WORKFLOW_INSTANCEID, SUBWORKFLOW, SYNCHRONOUS, WARNINGS,
                           ERRORS, BUSINESS_ERROR, WORKFLOWSTATUS_ORIG,
                           CUSTOM_STATUS, SCHEDULED, PRIORITY, STARTED,
                           COMPLETED, MODIFIED, OPERATOR_LOCK, NOTE_COUNT
                            on workflow_instance for each row "
                            "execute procedure trig_workflow_instance_update()",
                "trig_workflow_instance_delete" :
                            "before delete on workflow_instance for each row "
                            "execute procedure trig_workflow_instance_delete()",
            },
            "mysql": (
                "trig_workflow_instance_insert": "before insert on workflow_instance for each row
begin
  if new.started is null then
    set new.started = now();
  end if;
  if new.modified is null then
    set new.modified = now();
    set new.modified_date = date(new.modified);
  end if;
  -- snapshots
  insert into workflow_instance_stats_stage
    (
        objectid,
        modified_orig,
        modified_new,
        status_orig,
        status_new,
        dml_operation,
        created
    )
    values
    (
        new.workflowid,
        null,
        cast(date_format(new.modified, '%Y-%m-%d %H:00:00') as datetime),
        null,
        new.workflowstatus,
        'I',
        now()
    );
  -- snapshots
end",
                "trig_workflow_instance_update": "before update on workflow_instance for each row
begin
  declare stats_new_modified datetime;
  declare stats_old_modified datetime;
  --
  if new.workflowstatus = 'C' then
    set new.completed = now();
  end if;
  if (new.modified is null or new.modified = old.modified) and ((new.status_sessionid = old.status_sessionid) or (new.workflowstatus != old.workflowstatus or new.parent_workflow_instanceid != old.parent_workflow_instanceid or new.subworkflow != old.subworkflow or new.synchronous != old.synchronous or new.priority != old.priority or new.started != old.started or new.completed != old.completed or new.scheduled != old.scheduled or new.custom_status != old.custom_status or new.business_error != old.business_error or new.workflowstatus_orig != old.workflowstatus_orig or new.errors != old.errors or new.warnings != old.warnings or new.operator_lock != old.operator_lock or new.note_count != old.note_count or new.retries != old.retries)) then
    set new.modified = now();
    set new.modified_date = date(new.modified);
  end if;
  -- snapshots
  set stats_new_modified = cast(date_format(new.modified, '%Y-%m-%d %H:00:00') as datetime);
  set stats_old_modified = cast(date_format(old.modified, '%Y-%m-%d %H:00:00') as datetime);
  if (stats_old_modified != stats_old_modified or old.workflowstatus != new.workflowstatus) then
    insert into workflow_instance_stats_stage
    (
        objectid,
        modified_orig,
        modified_new,
        status_orig,
        status_new,
        dml_operation,
        created
    )
    values
    (
        old.workflowid,
        stats_old_modified,
        stats_new_modified,
        old.workflowstatus,
        new.workflowstatus,
        'U',
        now()
    );
  end if;
  -- snapshots
end",
                "trig_workflow_instance_delete": "before delete on workflow_instance for each row
begin
  -- snapshots
  insert into workflow_instance_stats_stage
    (
        objectid,
        modified_orig,
        modified_new,
        status_orig,
        status_new,
        dml_operation,
        created
    )
    values
    (
        old.workflowid,
        cast(date_format(old.modified, '%Y-%m-%d %H:00:00') as datetime),
        null,
        old.workflowstatus,
        null,
        'D',
        now()
    );
  -- snapshots
end",
            ),
        ),
    ),
);

const T_OrderInstance = (
    "arch" : Arch::TEMPLATE_WFIID,
    "columns": (
        "workflow_instanceid": c_number(14, True),
        "external_order_instanceid": c_varchar(40),
        "staticdata": c_clob(),
        "dynamicdata": c_clob(),
        "created": c_date(NN_TrueExceptMysql),
        "modified": c_date(),
    ),
    "indexes": (
        "driver": ("oracle": ("pk_order_instance": ("columns": ("workflow_instanceid"), "unique": True))),
        "sk_oi_ext_order_instanceid": ("columns": ("external_order_instanceid")),
    ),
    "foreign_constraints": (
        "fk_oi_wf_instanceid": ("columns": ("workflow_instanceid"), "table": "workflow_instance"),
    ),
    "primary_key": ("name": "pk_order_instance", "columns": ("workflow_instanceid")),
    "driver": (
        "pgsql": get_pgsql_trigger_func("order_instance"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("order_instance"),
            "pgsql": get_pgsql_trigger("order_instance"),
            "mysql": get_mysql_triggers("order_instance"),
        ),
    ),
    );

const T_OrderInstanceNotes = (
    "arch" : Arch::TEMPLATE_WFIID,
    "columns": (
    "id": c_number(14, True),
        "workflow_instanceid": c_number(14, True),
        "username": c_varchar(80),
        "note": c_clob(),
        "created": c_date(NN_TrueExceptMysql),
        "modified": c_date(),
    ),
    "indexes": (
        "order_instance_notes_wfi": ("columns": ("workflow_instanceid"), "unique": False),
        "driver": ("oracle": ("order_instance_notes_id": ("columns": ("id"), "unique": True))),
    ),
    "primary_key": ("name": "order_instance_notes_id", "columns": ("id")),
    "foreign_constraints": (
        "fk_oin_wf_instanceid": ("columns": ("workflow_instanceid"), "table": "workflow_instance"),
    ),
    "driver": (
        "pgsql": get_pgsql_trigger_func("order_instance_notes", False, "id", "seq_order_instance_notes"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("order_instance_notes", False, "id", "seq_order_instance_notes"),
            "pgsql": get_pgsql_trigger("order_instance_notes"),
            "mysql": get_mysql_triggers("order_instance_notes", False, "id", "seq_order_instance_notes"),
        ),
    ),
);

const T_SensitiveOrderData = (
    "arch" : Arch::TEMPLATE_WFIID,
    "columns": (
        "workflow_instanceid": c_number(14, True, "the workflow order instance ID"),
        "skey": c_varchar(100, True, "sensitive data key"),
        "svalue": c_varchar(140, True, "sensitive data value, base64-encoded and encrypted"),
        "data": c_blob(True, "encrypted sensitive data"),
        "iv": c_raw(12, True, "initialization vector"),
        "mac": c_raw(16, True, "message authentication code"),
        "meta": c_blob("encrypted metadata about the sensitive data with the following potential keys: 'PURPOSE': giving the purpose of processing, 'CATEGORIES': giving the categories of sensitive dat being stored, 'RECIPIENTS': listing the recipients of personal data, and 'STORAGE': indicating the storagin time or rules"),
        "miv": c_raw(12, False, "metadata initialization vector"),
        "mmac": c_raw(16, False, "metadata message authentication code"),

        "created": c_timestamp(NN_TrueExceptMysql, "the timestamp the record was created"),
        "modified": c_timestamp("the timestamp the record was modified"),
    ),
    "primary_key": ("name": "pk_sensitive_order_data", "columns": ("workflow_instanceid", "skey", "svalue")),
    "indexes": (
        "driver": ("oracle": ("pk_sensitive_order_data": ("columns": ("workflow_instanceid", "skey", "svalue"), "unique": True))),
        "sk_sod_wf_instanceid": ("columns": "workflow_instanceid"),
        "sk_sod_key_value": ("columns": ("skey", "svalue")),
    ),
    "foreign_constraints": (
        "fk_sod_wf_instanceid": ("columns": ("workflow_instanceid"), "table": "workflow_instance"),
    ),
    "driver": (
        "pgsql": get_pgsql_trigger_func("sensitive_order_data"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("sensitive_order_data"),
            "pgsql": get_pgsql_trigger("sensitive_order_data"),
            "mysql": get_mysql_triggers("sensitive_order_data"),
        ),
    ),
);

const T_SensitiveOrderDataKeys = (
    "arch" : Arch::TEMPLATE_WFIID,
    "columns": (
        "workflow_instanceid": c_number(14, True, "the workflow order instance ID"),
        "alias": c_varchar(100, True, "additional sensitive data key"),
        "skey": c_varchar(100, True, "sensitive data key"),
        "svalue": c_varchar(140, True, "sensitive data value, base64-encoded and encrypted"),

        "created": c_timestamp(NN_TrueExceptMysql, "the timestamp the record was created"),
        "modified": c_timestamp("the timestamp the record was modified"),
    ),
    "primary_key": ("name": "pk_sensitive_order_data_keys", "columns": ("workflow_instanceid", "alias")),
    "indexes": (
        "driver": ("oracle": ("pk_sensitive_order_data_keys": ("columns": ("workflow_instanceid", "alias"), "unique": True))),
        "sk_sodk_wfiid": ("columns": "workflow_instanceid"),
        "sk_sodk_key_value": ("columns": ("skey", "svalue")),
    ),
    "foreign_constraints": (
        "fk_sodk_sod": ("columns": ("workflow_instanceid", "skey", "svalue"), "table": "sensitive_order_data"),
    ),
    "driver": (
        "pgsql": get_pgsql_trigger_func("sensitive_order_data_keys"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("sensitive_order_data_keys"),
            "pgsql": get_pgsql_trigger("sensitive_order_data_keys"),
            "mysql": get_mysql_triggers("sensitive_order_data_keys"),
        ),
    ),
);

const T_WorkflowFeedback = (
    "arch" : Arch::TEMPLATE_WFIID,
    "columns": (
        "workflow_instanceid": c_number(14, True),
        "keyname": c_varchar(240, True),
        "info": c_clob(True),
        "created": c_date(NN_TrueExceptMysql),
        "modified": c_date(),
    ),
    "indexes": (
        "driver": ("oracle": ("pk_workflow_feedback": ("columns": ("workflow_instanceid", "keyname"), "unique": True))),
    ),
    "foreign_constraints": (
        "fk_wf_wf_instanceid": ("columns": ("workflow_instanceid"), "table": "workflow_instance"),
    ),
    "primary_key": ("name": "pk_workflow_feedback", "columns": ("workflow_instanceid", "keyname")),
    "driver": (
        "pgsql": get_pgsql_trigger_func("workflow_feedback"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("workflow_feedback"),
            "pgsql": get_pgsql_trigger("workflow_feedback"),
            "mysql": get_mysql_triggers("workflow_feedback"),
        ),
    ),
);

const T_WorkflowKeys = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "workflowid": c_number(14, True),
        "keyname": c_varchar(240, True),
        "description": c_varchar(4000)
    ),
    "indexes": (
        "driver": ("oracle": ("pk_workflow_keys": ("columns": ("workflowid", "keyname"), "unique": True))),
        "sk_workflow_keys_wfid": ("columns": ("workflowid")),
    ),
    "foreign_constraints": (
        "fk_workflow_keys_wfid": ("columns": ("workflowid"), "table": "workflows"),
    ),
    "primary_key": ("name": "pk_workflow_keys", "columns": ("workflowid", "keyname")),
);

const T_OrderInstanceKeys = (
    "arch" : Arch::TEMPLATE_WFIID,
    "columns": (
        "workflow_instanceid": c_number(14, True),
        "keyname": c_varchar(240, True),
        #  Innodb will only allow a key of 767 bytes. Since we are using a utf8 character set and MySQL uses 3 bytes per character, you get a limit of 255.67 characters, which in practice means a maximum of 255 characters
        "value": c_varchar(4000, True) + ("driver":("mysql":("size":255))),
        "workflowid": c_number(14, True),
        "created": c_date(NN_TrueExceptMysql),
        "modified": c_date(),
    ),
    "indexes": (
        "driver": ("oracle": ("pk_order_instance_keys": ("columns": ("workflow_instanceid", "keyname", "value"), "unique": True))),
        "sk_oik_wfid": ("columns": ("workflowid")),
        "sk_oik_wfid_key": ("columns": ("workflowid", "keyname")),
        "sk_oik_wfid_value": ("columns": ("workflowid", "value")),
        "sk_oik_value": ("columns": ("value")),
    ),
    "foreign_constraints": (
        "fk_oik_wf_instanceid": ("columns": ("workflow_instanceid"), "table": "workflow_instance"),
        "fk_oik_wfid": ("columns": ("workflowid"), "table": "workflows"),
        "fk_oik_wfid_key": ("columns": ("workflowid", "keyname"), "table": "workflow_keys"),
    ),
    "primary_key": ("name": "pk_order_instance_keys", "columns": ("workflow_instanceid", "keyname", "value")),
    "driver": (
        "pgsql": get_pgsql_trigger_func("order_instance_keys"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("order_instance_keys"),
            "pgsql": get_pgsql_trigger("order_instance_keys"),
            "mysql": get_mysql_triggers("order_instance_keys"),
        ),
    ),
);

const T_WorkflowOptions = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "workflowid": c_number(14, True),
        "config": c_number(1),
        "name": c_varchar(80, True),
        "description": c_varchar(4000, True),
        "value": c_varchar(4000),
        "created": c_date(NN_TrueExceptMysql),
        "modified": c_date(),
    ),
    "indexes": (
        "driver": ("oracle": ("pk_workflow_options": ("columns": ("workflowid", "name"), "unique": True))),
    ),
    "foreign_constraints": (
        "fk_wfo_workflowid": ("columns": ("workflowid"), "table": "workflows"),
    ),
    "primary_key": ("name": "pk_workflow_options", "columns": ("workflowid", "name")),
    "driver": (
        "pgsql": get_pgsql_trigger_func("workflow_options"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("workflow_options"),
            "pgsql": get_pgsql_trigger("workflow_options"),
            "mysql": get_mysql_triggers("workflow_options"),
        ),
    ),
);

const T_WorkflowSteps = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "workflowid": c_number(14, True),
        "stepid": c_number(14, True),
        "dependson_stepid": c_number(14, True),
        "created": c_date(NN_TrueExceptMysql),
        "modified": c_date(),
    ),
    "indexes": (
        "driver": ("oracle": ("pk_workflow_steps": ("columns": ("workflowid", "stepid", "dependson_stepid"), "unique": True))),
        "sk_workflow_steps_steps1": ("columns": ("stepid")),
        "sk_workflow_steps_steps2": ("columns": ("dependson_stepid")),
    ),
    "foreign_constraints": (
        "fk_workflow_steps_workflow": ("columns": ("workflowid"), "table": "workflows"),
        "fk_workflow_steps_steps": ("columns": ("stepid"), "table": "steps"),
        "fk_workflow_steps_steps1": ("columns": ("dependson_stepid"), "table": "steps", "target_columns": "stepid"),
    ),
    "primary_key": ("name": "pk_workflow_steps", "columns": ("workflowid", "stepid", "dependson_stepid")),
    "driver": (
        "pgsql": get_pgsql_trigger_func("workflow_steps"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("workflow_steps"),
            "pgsql": get_pgsql_trigger("workflow_steps"),
            "mysql": get_mysql_triggers("workflow_steps"),
        ),
    ),
);

const T_StepInstance = (
    "arch" : Arch::TEMPLATE_WFIID,
    "columns": (
        "workflow_instanceid": c_number(14, True),
        "stepid": c_number(14, True),
        "ind": c_number(5, True),
        "stepstatus": c_char(1, True) + {"default_value": "I"},
        "retries": c_number(4),
        "skip": c_number(1, True) + {"default_value": 0},
        "custom_status": c_char(1),
        "started": c_date(NN_TrueExceptMysql),
        "completed": c_date(),

        "driver": ("oracle": ("custom_status": c_varchar(1))),
    ),
    "indexes": (
        "driver": ("oracle": ("pk_step_instance": ("columns": ("workflow_instanceid", "stepid", "ind"), "unique": True))),
        "sk_stepinst_steps": ("columns": ("stepid")),
        "sk_stepinst_status": ("columns": ("stepstatus")),
    ),
    "foreign_constraints": (
        "fk_step_inst_workflow_inst": ("columns": ("workflow_instanceid"), "table": "workflow_instance"),
        "fk_step_instance_step": ("columns": ("stepid"), "table": "steps"),
        "fk_step_instance_step_status": ("columns": ("stepstatus"), "table": "step_status"),
    ),
    "primary_key": ("name": "pk_step_instance", "columns": ("workflow_instanceid", "stepid", "ind")),
    "driver": (
        "pgsql": (
            "functions": (
                "trig_step_instance()": "returns trigger language plpgsql as $function$
begin
  if (tg_op = 'INSERT') then
    if new.started is null then
      select current_timestamp into new.started;
    end if;
  else
    if (tg_op = 'UPDATE') then
      if new.stepstatus = 'C' and new.completed is null then
        select current_timestamp into new.completed;
      end if;
    end if;
  end if;
  return new;
end;
$function$", #",
            ),
        ),
    ),
    "triggers": (
        "driver": (
            "oracle": (
                "trig_step_instance": "BEFORE INSERT OR UPDATE ON STEP_INSTANCE
REFERENCING NEW AS NEW OLD AS OLD
FOR EACH ROW
begin
  if inserting then
    if :new.started is null then
      :new.started := sysdate;
    end if;
  else
    if updating then
      if :new.stepstatus = 'C' and :new.completed is null then
        :new.completed := sysdate;
      end if;
    end if;
  end if;
end;",
            ),
            "pgsql": get_pgsql_trigger("step_instance"),
            "mysql": (
                "trig_step_instance_insert": "before insert on step_instance for each row
begin
  set new.started = now();
end",
                "trig_step_instance_update": "before update on step_instance for each row
begin
  if new.stepstatus = 'C' and new.completed is null then
    set new.completed = now();
  end if;
end",
            ),
        ),
    ),
);

const T_StepInstanceData = (
    "arch" : Arch::TEMPLATE_WFIID,
    "columns": {
        "workflow_instanceid": c_number(14, True, "the workflow instance ID"),
        "stepid": c_number(14, True, "the stepid for the step"),
        "ind": c_number(5, True, "the step index number for arraysteps; always 0 for a non-array-step"),
        "data": c_clob(True, "the data for the step instance"),
        "created": c_timestamp(NN_TrueExceptMysql, "created timestamp"),
        "modified": c_timestamp("modified timestamp"),
    },
    "indexes": {
        "driver": ("oracle": ("pk_step_instance_data": ("columns": ("workflow_instanceid", "stepid", "ind"), "unique": True))),
    },
    "foreign_constraints": {
        "fk_step_instannce_data_si": {"columns": ("workflow_instanceid", "stepid", "ind"), "table": "step_instance"},
    },
    "primary_key": {"name": "pk_step_instance_data", "columns": ("workflow_instanceid", "stepid", "ind")},
    "driver": {
        "pgsql": get_pgsql_trigger_func("step_instance_data"),
    },
    "triggers": {
        "driver": {
            "oracle": get_oracle_trigger("step_instance_data"),
            "pgsql": get_pgsql_trigger("step_instance_data"),
            "mysql": get_mysql_triggers("step_instance_data"),
        },
    },
);

const T_SubworkflowInstance = (
    "arch" : Arch::TEMPLATE_WFIID,
    "columns": (
        "workflow_instanceid": c_number(14, True),
        "stepid": c_number(14, True),
        "ind": c_number(5, True),
        "subworkflow_instanceid": c_number(14, True),
        "corrected": c_number(1),
    ),
    "indexes": (
        "driver": ("oracle": ("pk_subworkflow_instance": ("columns": ("workflow_instanceid", "stepid", "ind"), "unique": True))),
        "fk_swfi_workflow_instance": ("columns": ("subworkflow_instanceid")),
    ),
    "foreign_constraints": (
        "fk_swfi_step_instance": ("columns": ("workflow_instanceid", "stepid", "ind"), "table": "step_instance"),
        "fk_swfi_workflow_instance": ("columns": ("subworkflow_instanceid"), "table": "workflow_instance", "target_columns": ("workflow_instanceid")),
    ),
    "primary_key": ("name": "pk_subworkflow_instance", "columns": ("workflow_instanceid", "stepid", "ind")),
);

const T_WorkflowEvents = (
    "arch" : (
        "type" : Arch::TYPE_LIVE,
        "data" : Arch::DATA_DATE_UPSERT,
    ),
    "columns": (
        "workflow_event_typeid": c_number(14, True),
        "eventkey": c_varchar(240, True),
        "event_posted": c_number(1, True) + {"default_value": 0},
        "created": c_date(NN_TrueExceptMysql),
        "modified": c_date(),
    ),
    "indexes": (
        "driver": ("oracle": ("pk_workflow_events": ("columns": ("workflow_event_typeid", "eventkey"), "unique": True))),
    ),
    "foreign_constraints": (
        "fk_workflow_event_typeid": ("columns": ("workflow_event_typeid"), "table": "workflow_event_types"),
    ),
    "primary_key": ("name": "pk_workflow_events", "columns": ("workflow_event_typeid", "eventkey")),
    "driver": (
        "pgsql": get_pgsql_trigger_func("workflow_events"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("workflow_events"),
            "pgsql": get_pgsql_trigger("workflow_events"),
            "mysql": get_mysql_triggers("workflow_events"),
        ),
    ),
);

const T_StepInstanceEvents = (
    "arch" : Arch::TEMPLATE_WFIID,
    "columns": (
        "workflow_instanceid": c_number(14, True),
        "stepid": c_number(14, True),
        "ind": c_number(5, True),
        "workflow_event_typeid": c_number(14, True),
        "eventkey": c_varchar(240, True),
        "created": c_date(NN_TrueExceptMysql),
        "modified": c_date(),
    ),
    "indexes": (
        "driver": ("oracle": ("pk_step_instance_events": ("columns": ("workflow_instanceid", "stepid", "ind"), "unique": True))),
        "sk_step_instance_events": ("columns": ("workflow_event_typeid", "eventkey")),
    ),
    "foreign_constraints": (
        # missing a foreign constraint to step_instance
        "fk_step_instance_events": ("columns": ("workflow_event_typeid", "eventkey"), "table": "workflow_events"),
    ),
    "primary_key": ("name": "pk_step_instance_events", "columns": ("workflow_instanceid", "stepid", "ind")),
    "driver": (
        "pgsql": get_pgsql_trigger_func("step_instance_events"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("step_instance_events"),
            "pgsql": get_pgsql_trigger("step_instance_events"),
            "mysql": get_mysql_triggers("step_instance_events"),
        ),
    ),
);

const T_ErrorSeverity = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "severity": c_varchar(20, True),
        "description": c_varchar(250, True),
        "created": c_date(NN_TrueExceptMysql),
        "modified": c_date(),
    ),
    "indexes": (
        "driver": ("oracle": ("pk_error_severity": ("columns": ("severity"), "unique": True))),
    ),
    "primary_key": ("name": "pk_error_severity", "columns": ("severity")),
    "driver": (
        "pgsql": get_pgsql_trigger_func("error_severity"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("error_severity"),
            "pgsql": get_pgsql_trigger("error_severity"),
            "mysql": get_mysql_triggers("error_severity"),
        ),
    ),
);

const T_ErrorInstance = (
    "arch" : Arch::TEMPLATE_WFIID,
    "columns": (
        "error_instanceid": c_number(14, True),
        "workflow_instanceid": c_number(14),
        "stepid": c_number(14),
        "ind": c_number(5),
        "severity": c_varchar(20, True),
        "retry": c_number(1, True),
        "error": c_varchar(240, True),
        "description": c_varchar(4000),
        "info": c_clob(),
        "business_error": c_number(1),
        "created": c_date(NN_TrueExceptMysql),
        ),
    "indexes": (
        "driver": ("oracle": ("pk_error_instance": ("columns": ("error_instanceid"), "unique": True))),
        "fk_error_instance_si": ("columns": ("workflow_instanceid", "stepid", "ind")),
        "sk_error_instance_sev": ("columns": ("severity")),
    ),
    "foreign_constraints": (
        "fk_error_instance_wfi": ("columns": ("workflow_instanceid"), "table": "workflow_instance"),
        "fk_error_instance_si": ("columns": ("workflow_instanceid", "stepid", "ind"), "table": "step_instance"),
        "fk_error_instance_es": ("columns": ("severity"), "table": "error_severity"),
    ),
    "primary_key": ("name": "pk_error_instance", "columns": ("error_instanceid")),
    "driver": (
        "pgsql": (
            "functions": (
                "trig_error_instance()": "returns trigger language plpgsql as $function$
begin
  if (tg_op = 'INSERT') then
    if new.created is null then
      select current_timestamp into new.created;
    end if;
    if new.error_instanceid is null then
      select nextval('seq_error_instance') into new.error_instanceid;
    end if;
    if new.workflow_instanceid is not null then
      if new.severity in ('WARNING', 'INFO', 'MINOR') then
        update workflow_instance set warnings = coalesce(warnings::numeric(14), 0) + 1 where workflow_instanceid = new.workflow_instanceid;
      else
        if new.retry = 1 then
          update workflow_instance set errors = coalesce(errors::numeric(14), 0) + 1, retries = coalesce(retries::numeric(14), 0) + 1 where workflow_instanceid = new.workflow_instanceid;
        else
          update workflow_instance set errors = coalesce(errors::numeric(14), 0) + 1 where workflow_instanceid = new.workflow_instanceid;
        end if;
      end if;
    end if;
  end if;
  return new;
end;
$function$", #",
            ),
        ),
    ),
    "triggers": (
        "driver": (
            "oracle": (
                "trig_error_instance": "BEFORE INSERT ON ERROR_INSTANCE
REFERENCING NEW AS NEW OLD AS OLD
FOR EACH ROW
begin
  if inserting then
    if :new.created is null then
      :new.created := sysdate;
    end if;
    if :new.error_instanceid is null then
      select seq_error_instance.nextval into :new.error_instanceid from dual;
    end if;
    if :new.workflow_instanceid is not null then
      if :new.severity in ('WARNING', 'INFO', 'MINOR') then
        update workflow_instance set warnings = nvl(warnings, 0) + 1 where workflow_instanceid = :new.workflow_instanceid;
      else
        if :new.retry = 1 then
          update workflow_instance set errors = nvl(errors, 0) + 1, retries = nvl(retries, 0) + 1 where workflow_instanceid = :new.workflow_instanceid;
        else
          update workflow_instance set errors = nvl(errors, 0) + 1 where workflow_instanceid = :new.workflow_instanceid;
        end if;
      end if;
    end if;
  end if;
end;",
            ),
            "pgsql": get_pgsql_trigger("error_instance", True),
            "mysql": (
                "trig_error_instance_insert": "before insert on error_instance for each row
begin
  if new.created is null then
    set new.created = now();
  end if;
  if new.error_instanceid = 0 then
    set new.error_instanceid = my_nextval('seq_error_instance');
  end if;
  if new.workflow_instanceid is not null then
    if new.severity in ('WARNING', 'INFO', 'MINOR') then
      update workflow_instance set warnings = coalesce(warnings, 0) + 1 where workflow_instanceid = new.workflow_instanceid;
    else
      if new.retry = 1 then
        update workflow_instance set errors = coalesce(errors, 0) + 1, retries = coalesce(retries, 0) + 1 where workflow_instanceid = new.workflow_instanceid;
      else
        update workflow_instance set errors = coalesce(errors, 0) + 1 where workflow_instanceid = new.workflow_instanceid;
      end if;
    end if;
  end if;
end",
            ),
        ),
    ),
);

const T_QueueDataStatus = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "queue_data_status": c_char(1, True),
        "description": c_varchar(240),
    ),
    "indexes": (
        "driver": ("oracle": ("pk_queue_data_status": ("columns": ("queue_data_status"), "unique": True))),
    ),
    "primary_key": ("name": "pk_queue_data_status", "columns": ("queue_data_status")),
);

const T_QueueData = {
    "arch" : Arch::TEMPLATE_WFIID,
    "columns": {
        "queueid": c_number(14, True),
        "queuekey": c_varchar(240, True),
        "queue_data_status": c_char(1, True) + {"default_value": "W"},
        "data": c_clob(),
        "workflow_instanceid": c_number(14, True),
        "stepid": c_number(14, True),
        "ind": c_number(5, True),
        "corrected": c_number(1),
        "user_interaction_locked": c_number(1, True, "1=locked for user interaction, 0=unlocked") +
            {"default_value": 0},
        "user_interaction_user": c_varchar(80, "username for when user_interaction_lock = 1"),
        "user_interaction_modified": c_timestamp("the timestamp the record was modified"),
        "created": c_date(NN_TrueExceptMysql),
        "modified": c_date(),
    },
    "indexes": (
        "driver": ("oracle": ("pk_queue_data": ("columns": ("queueid", "queuekey"), "unique": True))),
        "sk_queue_data_qdstatus": ("columns": ("queue_data_status")),
        "sk_queue_data_wistep": ("columns": ("workflow_instanceid", "stepid", "ind"), "unique": True),
    ),
    "foreign_constraints": (
        "fk_queue_data_queueid": ("columns": ("queueid"), "table": "queues"),
        "fk_queue_data_status": ("columns": ("queue_data_status"), "table": "queue_data_status"),
        "fk_queue_data_wk_instanceid": ("columns": ("workflow_instanceid"), "table": "workflow_instance"),
        "fk_queue_data_wistepid": ("columns": ("workflow_instanceid", "stepid", "ind"), "table": "step_instance"),
    ),
    "primary_key": ("name": "pk_queue_data", "columns": ("queueid", "queuekey")),
    "unique_constraints": (
        "sk_queue_data_wistep": ("columns": ("workflow_instanceid", "stepid", "ind")),
    ),
    "driver": (
        "pgsql": (
            "functions": (
                "trig_queue_data()": "returns trigger language plpgsql as $function$
begin
  if (tg_op = 'INSERT') then
    if new.created is null then
      select current_timestamp into new.created;
    end if;
    if new.modified is null then
      select current_timestamp into new.modified;
    end if;
    if (new.user_interaction_user is not null) then
      new.user_interaction_modified := current_timestamp;
    end if;
  else
    if (tg_op = 'UPDATE') then
      if new.modified is null or new.modified = old.modified then
        select current_timestamp into new.modified;
      end if;
      if ((new.user_interaction_user is not null
          and ((old.user_interaction_user is not null
                  and new.user_interaction_user != old.user_interaction_user) or old.user_interaction_user is null))
          or (new.user_interaction_user is null and old.user_interaction_user is not null)) then
          new.user_interaction_modified := current_timestamp;
      end if;
    end if;
  end if;
  return new;
end;
$function$", #",
            ),
        ),
    ),
    "triggers": (
        "driver": (
            "oracle": (
                "trig_queue_data": "BEFORE INSERT OR UPDATE ON QUEUE_DATA
REFERENCING NEW AS NEW OLD AS OLD
FOR EACH ROW
begin
  if inserting then
    if :new.created is null then
      :new.created := sysdate;
    end if;
    if (:new.user_interaction_user is not null) then
      :new.user_interaction_modified := localtimestamp;
    end if;
  else
    if updating then
      if ((:new.user_interaction_user is not null
            and ((:old.user_interaction_user is not null
                    and :new.user_interaction_user != :old.user_interaction_user) or :old.user_interaction_user is null))
            or (:new.user_interaction_user is null and :old.user_interaction_user is not null)) then
            :new.user_interaction_modified := localtimestamp;
      end if;
    end if;
  end if;
  --
  if :new.modified is null or :new.modified = :old.modified then
    :new.modified := sysdate;
  end if;
end;",
            ),
            "pgsql": get_pgsql_trigger("queue_data"),
            "mysql": (
                "trig_queue_data_insert": "before insert on queue_data for each row
begin
  if new.created is null then
    set new.created = now();
  end if;
  if new.modified is null then
    set new.modified = now();
  end if;
  if new.user_interaction_user is not null then
    set new.user_interaction_user = now();
  end if;
end",
                "trig_queue_data_update": "before update on queue_data for each row
begin
  if new.modified is null or new.modified = old.modified then
    set new.modified = now();
  end if;
  if ((new.user_interaction_user is not null
       and ((old.user_interaction_user is not null
             and new.user_interaction_user != old.user_interaction_user) or old.user_interaction_user is null))
      or (new.user_interaction_user is null and old.user_interaction_user is not null)) then
    set new.user_interaction_modified = now();
  end if;
end",
            ),
        ),
    ),
};

const T_SegmentDependencies = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "workflowid": c_number(14, True),
        "segmentid": c_number(14, True),
        "dependson_segmentid": c_number(14, True),
        "created": c_date(NN_TrueExceptMysql),
        "modified": c_date(),
    ),
    "indexes": (
        "driver": ("oracle": ("pk_segment_dependencies": ("columns": ("workflowid", "segmentid", "dependson_segmentid"), "unique": True))),
    ),
    "foreign_constraints": (
        "fk_segdeps_workflowid": ("columns": ("workflowid"), "table": "workflows"),
    ),
    "primary_key": ("name": "pk_segment_dependencies", "columns": ("workflowid", "segmentid", "dependson_segmentid")),
    "driver": (
        "pgsql": get_pgsql_trigger_func("segment_dependencies"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("segment_dependencies"),
            "pgsql": get_pgsql_trigger("segment_dependencies"),
            "mysql": get_mysql_triggers("segment_dependencies"),
        ),
    ),
);

const T_SegmentSteps = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "workflowid": c_number(14, True),
        "segmentid": c_number(14, True),
        "stepid": c_number(14, True),
        "dependson_stepid": c_number(14, True),
        "created": c_date(NN_TrueExceptMysql),
        "modified": c_date(),
    ),
    "indexes": (
        "driver": ("oracle": ("pk_segment_steps": ("columns": ("workflowid", "segmentid", "stepid", "dependson_stepid"), "unique": True))),
        "sk_segsteps_steps1": ("columns": ("stepid")),
        "sk_segsteps_steps2": ("columns": ("dependson_stepid")),
    ),
    "foreign_constraints": (
        "fk_segsteps_workflowid": ("columns": ("workflowid"), "table": "workflows"),
        "fk_segsteps_stepid_1": ("columns": ("stepid"), "table": "steps"),
        "fk_segsteps_stepid_2": ("columns": ("dependson_stepid"), "table": "steps", "target_columns": ("stepid")),
    ),
    "primary_key": ("name": "pk_segment_steps", "columns": ("workflowid", "segmentid", "stepid", "dependson_stepid")),
    "driver": (
        "pgsql": get_pgsql_trigger_func("segment_steps"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("segment_steps"),
            "pgsql": get_pgsql_trigger("segment_steps"),
            "mysql": get_mysql_triggers("segment_steps"),
        ),
    ),
);

const T_SegmentInstance = (
    "arch" : Arch::TEMPLATE_WFIID,
    "columns": (
        "workflowid": c_number(14, True),
        "workflow_instanceid": c_number(14, True),
        "segmentid": c_number(14, True),
        "segmentstatus": c_char(1, True) + {"default_value": "I"},
        "custom_status": c_varchar(1),
        "retry_trigger": c_date(),
        "created": c_date(NN_TrueExceptMysql),
        "modified": c_date(),
    ),
    "indexes": (
        "driver": ("oracle": ("pk_segment_instance": ("columns": ("workflow_instanceid", "segmentid"), "unique": True))),
        "sk_seginst_workflowid": ("columns": ("workflowid")),
        "sk_seginst_status": ("columns": ("segmentstatus")),
    ),
    "foreign_constraints": (
        "fk_seginst_workflowid": ("columns": ("workflowid"), "table": "workflows"),
        "fk_seginst_wf_instanceid": ("columns": ("workflow_instanceid"), "table": "workflow_instance"),
        "fk_seginst_segstatus": ("columns": ("segmentstatus"), "table": "workflow_status", "target_columns": ("workflowstatus")),
    ),
    "primary_key": ("name": "pk_segment_instance", "columns": ("workflow_instanceid", "segmentid")),
    "driver": (
        "pgsql": get_pgsql_trigger_func("segment_instance"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("segment_instance"),
            "pgsql": get_pgsql_trigger("segment_instance"),
            "mysql": get_mysql_triggers("segment_instance"),
        ),
    ),
);

const T_SegmentAsyncLink = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "workflowid": c_number(14, True),
        "segmentid": c_number(14, True),
        "stepid": c_number(14, True),
        "frontend_segmentid": c_number(14, True),
        "created": c_date(NN_TrueExceptMysql),
        "modified": c_date(),
    ),
    "indexes": (
        "driver": ("oracle": ("pk_segment_async_link": ("columns": ("workflowid", "segmentid"), "unique": True))),
        "sk_segment_async_link_steps": ("columns": ("stepid")),
    ),
    "foreign_constraints": (
        "fk_sal_workflowid": ("columns": ("workflowid"), "table": "workflows"),
        "fk_sal_stepid": ("columns": ("stepid"), "table": "steps"),
    ),
    "primary_key": ("name": "pk_segment_async_link", "columns": ("workflowid", "segmentid")),
    "driver": (
        "pgsql": get_pgsql_trigger_func("segment_async_link"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("segment_async_link"),
            "pgsql": get_pgsql_trigger("segment_async_link"),
            "mysql": get_mysql_triggers("segment_async_link"),
        ),
    ),
);

const T_Jobs = {
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": {
        "jobid": c_number(14, True, "job metadata ID number"),
        "name": c_varchar(160, True, "job name"),
        "description": c_varchar(4000, "job description"),
        "version": c_varchar(80, True, "job version"),
        "author": c_varchar(240, "job author"),
        "job_modules": c_varchar(4000, "a comma-separated list of job modules to use with this job"),
        "sessionid": c_number(14, True) + {"default_value": 0},
        "active": c_number(1, True),
        "manual_active": c_number(1, True, "0 = active has not been updated withh the API, 1 = it has") +
            {"default_value": 0},
        "remote": c_number(1, True, "1 = the interface can run in a separate process, 0 = not") +
            {"default_value": 1},
        "manual_remote": c_number(1, True, "0 = remote has not been updated withh the API, 1 = it has") +
            {"default_value": 0},
        "open": c_number(1, True, "1 = the job session is open independently, 0 = not") + {"default_value": 0},
        "run_skipped": c_number(1, True, "if 1, then run immediately if a job was skipped because the system was "
            "down (only applicable with date/time recurring tasks"),
        "enabled": c_number(1, True) + {"default_value": 1},
        "code": c_clob(True),
        "class_based": c_number(1, True, "is this job class-based or function-based") + {"default_value": 0},
        "class_name": c_varchar(160, False, "the name of the class for class-based jobs; if NULL then the job name "
            "is the class name; can only be set if class_based = 1"),
        "language": c_varchar(80, True, "programming language") + {"default_value": "qore"},
        "language_info": c_clob(False, "supplemental information for the programming language"),

        "yaml_config_items": c_clob(False, "config items defined in YAML"),

        "yaml_fsm_triggers": c_clob(False, "FSM triggers serialized in YAML (method -> FSM name)"),

        # columns month - minute are for recurring tasks that occur at a certain time every day, week, or month
        "month": c_varchar(40, "-1: every month, 1-12: Jan-Dec"),
        "day": c_varchar(80, "-1: every day, 1-31"),
        "wday": c_varchar(40, "-1: every week day, 0-6: Sun-Sat"),
        "hour": c_varchar(80, "-1: every hour, 0-23"),
        "minute": c_varchar(80, "-1: every minute, 0-59"),

        "recurring": c_number(7, "value = seconds between repetitions; if this column is not null, then the "
            "date/time recurring fields are ignored"),

        "last_executed": c_timestamp("date/time the job was last executed"),
        "last_executed_job_instanceid": c_number(14, C_NULL, "job instance id of the job was last executed"),
        "expiry_date": c_date("date/time the job expires"),

        "manually_updated": c_number(1, True) + {"default_value": 0},

        "custom_trigger": c_date("a custom trigger tim"),

        "slaid": c_number(14, "SLA associated to this job"),
        "loggerid": c_number(14, "each job can have its own logger, not set = use default logger"),

        "created": c_date(NN_TrueExceptMysql),
        "modified": c_date(),
    },
    "indexes": {
        "driver": {
            "oracle": {
                "pk_jobs": {"columns": ("jobid"), "unique": True},
            },
        },
        "sk_jobs_status_sessionid": {"columns": ("sessionid")},
        "sk_jobs_name": {"columns": ("name"), "unique": True},
        "sk_jobs_sla": {"columns": "slaid"},
        "sk_jobs_logger": {"columns": "loggerid"},
    },
    "foreign_constraints": {
        "fk_jobs_sessions": {"columns": ("sessionid"), "table": "sessions"},
        "fk_jobs_sla": {"columns": "slaid", "table": "sla"},
        "fk_jobs_loggerid": ("columns": "loggerid", "table": "loggers"),
    },
    "primary_key": {
        "name": "pk_jobs", "columns": ("jobid"),
    },
    "unique_constraints": {
        "sk_jobs_name": {
            "columns": ("name"),
        },
    },
    "driver": {
        "pgsql": get_pgsql_trigger_func("jobs", False, "jobid", "seq_jobs"),
    },
    "triggers": {
        "driver": {
            "oracle": get_oracle_trigger("jobs", False, "jobid", "seq_jobs"),
            "pgsql": get_pgsql_trigger("jobs"),
            "mysql": get_mysql_triggers("jobs", False, "jobid", "seq_jobs"),
        },
    },
};

const T_JobTags = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "jobid": c_number(14, True),
        "tag": c_varchar(255, True),
        "value": c_varchar(4000, True),
        "created": c_date(NN_TrueExceptMysql, False),
        "modified": c_date(False, False),
    ),
    "indexes": (
        "driver": ("oracle": ("pk_job_tags": ("columns": ("jobid", "tag"), "unique": True))),
        "sk_job_tags_job": ("columns": ("jobid")),
        "sk_job_tags_tags": ("columns": "tag"),
    ),
    "primary_key": ("name": "pk_job_tags", "columns": ("jobid", "tag")),
    "foreign_constraints": (
        "fk_job_tags_job": ("columns": "jobid", "table": "jobs"),
    ),
    "driver": (
        "pgsql": get_pgsql_trigger_func("job_tags"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("job_tags"),
            "pgsql": get_pgsql_trigger("job_tags"),
            "mysql": get_mysql_triggers("job_tags"),
        ),
    ),
);

const T_JobStateData = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "jobid": c_number(14, True, "job metadata ID number"),
        "data": c_clob("job state recovery data"),

        "created": c_timestamp(NN_TrueExceptMysql),
        "modified": c_timestamp(),
    ),

    "indexes": (
        "driver": (
            "oracle": (
                "pk_job_state_data": ("columns": ("jobid"), "unique": True),
            ),
        ),
    ),
    "foreign_constraints": (
        "fk_job_sd_jobs": ("columns": ("jobid"), "table": "jobs"),
    ),
    "primary_key": ("name": "pk_job_state_data", "columns": ("jobid")),
    "driver": (
        "pgsql": get_pgsql_trigger_func("job_state_data"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("job_state_data"),
            "pgsql": get_pgsql_trigger("job_state_data"),
            "mysql": get_mysql_triggers("job_state_data"),
        ),
    ),
);

const T_JobPersistentStateData = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "jobid": c_number(14, True, "job metadata ID number"),
        "data": c_clob("job persistent state data"),

        "created": c_timestamp(NN_TrueExceptMysql),
        "modified": c_timestamp(),
    ),

    "indexes": (
        "driver": (
            "oracle": (
                "pk_job_pstate_data": ("columns": ("jobid"), "unique": True),
            ),
        ),
    ),
    "foreign_constraints": (
        "fk_job_psd_jobs": ("columns": ("jobid"), "table": "jobs"),
    ),
    "primary_key": ("name": "pk_job_pstate_data", "columns": ("jobid")),
    "driver": (
        "pgsql": get_pgsql_trigger_func("job_persistent_state_data"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("job_persistent_state_data"),
            "pgsql": get_pgsql_trigger("job_persistent_state_data"),
            "mysql": get_mysql_triggers("job_persistent_state_data"),
        ),
    ),
);

const T_JobConfigItems = {
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": {
        "jobid": c_number(14, True, "job metadata ID number"),
        "name": c_varchar(240, True, "the configuration item name prefix"),
        "prefix": c_varchar(240, False, "the configuration item prefix"),
        "type": c_varchar(240, True, "the configuration item type"),
        "default_value": c_varchar(4000, False, "the configuration item default value as a serialized string"),
        "strictly_local": c_number(1, True, "allow this config item to be overridden at the next level") +
            {"default_value": 1},
        "description": c_varchar(4000, "the description of the configuration item"),
        "config_group": c_varchar(240, True, "the group of the configuration item") + {"default_value": "Default"},
        "allowed_values": c_varchar(4000, False, "the list of allowed values of the configuration item"),
        "sensitive": c_number(1, True, "sensitive field flag") + {"default_value": 0},

        "created": c_timestamp(NN_TrueExceptMysql),
        "modified": c_timestamp(),
    },
    "indexes": {
        "driver": {
            "oracle": {
                "pk_job_config_items": {
                    "columns": ("jobid", "name"),
                    "unique": True,
                },
            },
        },
    },
    "foreign_constraints": {
        "fk_job_ci_jobs": {
            "columns": ("jobid"),
            "table": "jobs",
        },
    },
    "primary_key": {
        "name": "pk_job_config_items",
        "columns": ("jobid", "name"),
    },
    "driver": {
        "pgsql": get_pgsql_trigger_func("job_config_items"),
    },
    "triggers": {
        "driver": {
            "oracle": get_oracle_trigger("job_config_items"),
            "pgsql": get_pgsql_trigger("job_config_items"),
            "mysql": get_mysql_triggers("job_config_items"),
        },
    },
};

const T_JobOptions = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "jobid": c_number(14, True),
        "config": c_number(1),
        "name": c_varchar(80, True),
        "description": c_varchar(4000, True),
        "value": c_varchar(4000),
        "created": c_date(NN_TrueExceptMysql),
        "modified": c_date(),
    ),
    "indexes": (
        "driver": ("oracle": ("pk_job_options": ("columns": ("jobid", "name"), "unique": True))),
    ),
    "foreign_constraints": (
        "fk_jobo_jobs": ("columns": ("jobid"), "table": "jobs"),
    ),
    "primary_key": ("name": "pk_job_options", "columns": ("jobid", "name")),
    "driver": (
        "pgsql": get_pgsql_trigger_func("job_options"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("job_options"),
            "pgsql": get_pgsql_trigger("job_options"),
            "mysql": get_mysql_triggers("job_options"),
        ),
    ),
);

const T_WorkflowLib = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "workflowid": c_number(14, True),
        "type": c_varchar(20, True),
        "name": c_varchar(160, True),
        "load_order": c_number(4, True) + {"default_value": 1},
    ),
    "indexes": (
        "driver": (
            "oracle": ("pk_workflow_lib": ("columns": ("workflowid", "type", "name"), "unique": True)),
            "mysql": (
                "fk_workflow_lib_type": ("columns": "type"),
                "fk_workflow_lib_wfid": ("columns": "workflowid"),
            ),
        ),
    ),
    "primary_key": ("name": "pk_workflow_lib", "columns": ("workflowid", "type", "name")),
    "foreign_constraints": (
        "fk_workflow_lib_type": ("columns": "type", "table": "library_type", "target_columns": ("name")),
        "fk_workflow_lib_wfid": ("columns": "workflowid", "table": "workflows"),
    ),
);

const T_ServiceLib = (
    "arch" : Arch::TEMPLATE_META_FULL,
    "columns": (
        "serviceid": c_number(14, True),
        "type": c_varchar(20, True),
        "name": c_varchar(160, True),
        "load_order": c_number(4, True) + {"default_value": 1},
    ),
    "rename": (
        "constraint_map": (
            "fk_service_lib_wfid": "fk_service_lib_svcid",
        ),
    ),
    "indexes": (
        "driver": (
            "oracle": (
                "pk_service_lib": ("columns": ("serviceid", "type", "name"), "unique": True),
            ),
            "mysql": (
                "fk_service_lib_type": ("columns": "type"),
                "fk_service_lib_svcid": ("columns": "serviceid"),
            ),
        ),
    ),
    "primary_key": ("name": "pk_service_lib", "columns": ("serviceid", "type", "name")),
    "foreign_constraints": (
        "fk_service_lib_type": ("columns": "type", "table": "library_type", "target_columns": ("name")),
        "fk_service_lib_svcid": ("columns": "serviceid", "table": "services"),
    ),
);

const T_JobLib = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "jobid": c_number(14, True),
        "type": c_varchar(20, True),
        "name": c_varchar(160, True),
        "load_order": c_number(4, True) + {"default_value": 1},
    ),
    "rename": (
        "index_map": (
            "sk_job_lib_svcid_type": "sk_job_lib_type",
            "sk_job_lib_serviceid": "sk_job_lib_jobid",
        ),
        "constraint_map": (
            "fk_job_lib_wfid": "fk_job_lib_jobid",
        ),
    ),
    "indexes": (
        "driver": (
            "oracle": (
                "pk_job_lib": ("columns": ("jobid", "type", "name"), "unique": True)
            ),
            "mysql": (
                "fk_job_lib_type": ("columns": "type"),
            ),
        ),
        "sk_job_lib_type": ("columns": ("jobid", "type")),
        "sk_job_lib_jobid": ("columns": ("jobid")),
    ),
    "primary_key": ("name": "pk_job_lib", "columns": ("jobid", "type", "name")),
    "foreign_constraints": (
        "fk_job_lib_type": ("columns": "type", "table": "library_type", "target_columns": ("name")),
        "fk_job_lib_jobid": ("columns": "jobid", "table": "jobs"),
    ),
);

const T_StepLib = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "stepid": c_number(14, True),
        "type": c_varchar(20, True),
        "name": c_varchar(160, True),
        "load_order": c_number(4, True) + {"default_value": 1},
    ),
    "indexes": (
        "driver": (
            "oracle": (
                "pk_step_lib": ("columns": ("stepid", "type", "name"), "unique": True)
            ),
            "mysql": (
                "fk_step_lib_type": ("columns": "type"),
            ),
        ),
        "sk_step_lib_type": ("columns": ("stepid", "type")),
        "sk_step_lib_stepid": ("columns": ("stepid")),
    ),
    "primary_key": ("name": "pk_step_lib", "columns": ("stepid", "type", "name")),
    "foreign_constraints": (
        "fk_step_lib_type": ("columns": "type", "table": "library_type", "target_columns": ("name")),
        "fk_step_lib_stepid": ("columns": "stepid", "table": "steps"),
    ),
);

const T_WorkflowMappers = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "workflowid": c_number(14, True),
        "mapperid": c_number(14, True),
    ),
    "indexes": (
        "driver": (
            "oracle": ("pk_workflow_mappers": ("columns": ("workflowid", "mapperid"), "unique": True)),
        ),
        "fk_workflow_mappers_mapperid": ("columns": "mapperid"),
        "fk_workflow_mappers_wfid": ("columns": "workflowid"),
    ),
    "primary_key": ("name": "pk_workflow_mappers", "columns": ("workflowid", "mapperid")),
    "foreign_constraints": (
        "fk_workflow_mappers_mapperid": ("columns": "mapperid", "table": "mappers"),
        "fk_workflow_mappers_wfid": ("columns": "workflowid", "table": "workflows"),
    ),
);

const T_ServiceMappers = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "serviceid": c_number(14, True),
        "mapperid": c_number(14, True),
    ),
    "indexes": (
        "driver": (
            "oracle": ("pk_service_mappers": ("columns": ("serviceid", "mapperid"), "unique": True)),
        ),
        "fk_service_mappers_mapperid": ("columns": "mapperid"),
        "fk_service_mappers_svcid": ("columns": "serviceid"),
    ),
    "primary_key": ("name": "pk_service_mappers", "columns": ("serviceid", "mapperid")),
    "foreign_constraints": (
        "fk_service_mappers_mapperid": ("columns": "mapperid", "table": "mappers"),
        "fk_service_mappers_svcid": ("columns": "serviceid", "table": "services"),
    ),
);

const T_JobMappers = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "jobid": c_number(14, True),
        "mapperid": c_number(14, True),
    ),
    "indexes": (
        "driver": (
            "oracle": ("pk_job_mappers": ("columns": ("jobid", "mapperid"), "unique": True)),
        ),
        "fk_job_mappers_mapperid": ("columns": "mapperid"),
        "fk_job_mappers_jobid": ("columns": "jobid"),
    ),
    "primary_key": ("name": "pk_job_mappers", "columns": ("jobid", "mapperid")),
    "foreign_constraints": (
        "fk_job_mappers_mapperid": ("columns": "mapperid", "table": "mappers"),
        "fk_job_mappers_jobid": ("columns": "jobid", "table": "jobs"),
    ),
);

const T_StepMappers = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "stepid": c_number(14, True),
        "mapperid": c_number(14, True),
    ),
    "indexes": (
        "driver": (
            "oracle": ("pk_step_mappers": ("columns": ("stepid", "mapperid"), "unique": True)),
        ),
        "fk_step_mappers_mapperid": ("columns": "mapperid"),
        "fk_step_mappers_stepid": ("columns": "stepid"),
    ),
    "primary_key": ("name": "pk_step_mappers", "columns": ("stepid", "mapperid")),
    "foreign_constraints": (
        "fk_step_mappers_mapperid": ("columns": "mapperid", "table": "mappers"),
        "fk_step_mappers_stepid": ("columns": "stepid", "table": "steps"),
    ),
);

const T_WorkflowVMaps = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "workflowid": c_number(14, True),
        "id": c_number(14, True),
    ),
    "indexes": (
        "driver": (
            "oracle": ("pk_workflow_vmaps": ("columns": ("workflowid", "id"), "unique": True)),
        ),
        "fk_workflow_vmaps_id": ("columns": "id"),
        "fk_workflow_vmaps_wfid": ("columns": "workflowid"),
    ),
    "primary_key": ("name": "pk_workflow_vmaps", "columns": ("workflowid", "id")),
    "foreign_constraints": (
        "fk_workflow_vmaps_id": ("columns": "id", "table": "value_maps"),
        "fk_workflow_vmaps_wfid": ("columns": "workflowid", "table": "workflows"),
    ),
);

const T_ServiceVMaps = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "serviceid": c_number(14, True),
        "id": c_number(14, True),
    ),
    "indexes": (
        "driver": (
            "oracle": ("pk_service_vmaps": ("columns": ("serviceid", "id"), "unique": True)),
        ),
        "fk_service_vmaps_id": ("columns": "id"),
        "fk_service_vmaps_svcid": ("columns": "serviceid"),
    ),
    "primary_key": ("name": "pk_service_vmaps", "columns": ("serviceid", "id")),
    "foreign_constraints": (
        "fk_service_vmaps_id": ("columns": "id", "table": "value_maps"),
        "fk_service_vmaps_svcid": ("columns": "serviceid", "table": "services"),
    ),
);

const T_JobVMaps = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "jobid": c_number(14, True),
        "id": c_number(14, True),
    ),
    "indexes": (
        "driver": (
            "oracle": ("pk_job_vmaps": ("columns": ("jobid", "id"), "unique": True)),
        ),
        "fk_job_vmaps_id": ("columns": "id"),
        "fk_job_vmaps_jobid": ("columns": "jobid"),
    ),
    "primary_key": ("name": "pk_job_vmaps", "columns": ("jobid", "id")),
    "foreign_constraints": (
        "fk_job_vmaps_id": ("columns": "id", "table": "value_maps"),
        "fk_job_vmaps_jobid": ("columns": "jobid", "table": "jobs"),
    ),
);

const T_StepVMaps = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "stepid": c_number(14, True),
        "id": c_number(14, True),
    ),
    "indexes": (
        "driver": (
            "oracle": ("pk_step_vmaps": ("columns": ("stepid", "id"), "unique": True)),
        ),
        "fk_step_vmaps_id": ("columns": "id"),
        "fk_step_vmaps_svcid": ("columns": "stepid"),
    ),
    "primary_key": ("name": "pk_step_vmaps", "columns": ("stepid", "id")),
    "foreign_constraints": (
        "fk_step_vmaps_id": ("columns": "id", "table": "value_maps"),
        "fk_step_vmaps_svcid": ("columns": "stepid", "table": "steps"),
    ),
);

const T_JobStatus = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "jobstatus": c_char(1, True),
        "description": c_varchar(240),
    ),
    "indexes": (
        "driver": ("oracle": ("pk_job_status": ("columns": ("jobstatus"), "unique": True))),
    ),
    "primary_key": ("name": "pk_job_status", "columns": ("jobstatus")),
);

const T_JobInstance = (
    "arch" : Arch::TEMPLATE_JOBID,
    "columns": (
        "job_instanceid": c_number(14, True),
        "jobid": c_number(14, True),
        "sessionid": c_number(14, True),
        "jobstatus": c_char(1, True),
        "info": c_clob(),
        "started": c_timestamp(NN_TrueExceptMysql),
        "completed": c_timestamp(),
        "modified": c_timestamp(),
    ),
    "indexes": (
        "driver": (
                "oracle": (
                        "pk_job_instance": ("columns": ("job_instanceid"), "unique": True),
                        "job_instance_modified": ("columns": ("trunc(modified)")),
                    ),
                "pgsql": (
                        "job_instance_modified": ("columns": ("date_trunc('day'::text, modified)")),
                    ),
            ),
        "sk_ji_jobid": ("columns": "jobid"),
        "sk_ji_jobstatus": ("columns": ("jobstatus")),
        "sk_job_instance_sessionid": ("columns": ("sessionid")),
    ),
    "primary_key": ("name": "pk_job_instance", "columns": ("job_instanceid")),
    "foreign_constraints": (
        "fk_job_instance_job": ("columns": "jobid", "table": "jobs"),
        "fk_job_instance_jobstatus": ("columns": "jobstatus", "table": "job_status"),
        "fk_job_instance_sessions": ("columns": "sessionid", "table": "sessions"),
    ),
    "driver": (
        "pgsql": (
            "functions": (
                "trig_job_instance_insert()": "returns trigger language plpgsql as $function$
begin
  --
  if new.modified is null then
    select current_timestamp into new.modified;
  end if;
  --
  if new.started is null then
    select current_timestamp into new.started;
  end if;
  if new.job_instanceid is null then
    select nextval('seq_job_instance') into new.job_instanceid;
  end if;
  if new.jobstatus is null then
    select 'I' into new.jobstatus;
  end if;
  -- snapshots
  insert into job_instance_stats_stage
        (
        rowid,
        objectid,
        modified_orig,
        modified_new,
        status_orig,
        status_new,
        dml_operation,
        created
        )
        values
        (
        nextval('seq_job_instance_stats_stage'),
        new.jobid,
        null,
        date_trunc('hour', new.modified),
        null,
        new.jobstatus,
        'I',
        current_timestamp
        );
  -- snapshots
  return new;
end;
$function$", #",
                "trig_job_instance_update()": "returns trigger language plpgsql as $function$
declare
    stats_new_modified timestamp;
    stats_old_modified timestamp;
begin
  --
  if new.modified is null or new.modified = old.modified then
    select current_timestamp into new.modified;
  end if;
  --
  if new.jobstatus = 'C' and new.completed is null then
    select current_timestamp into new.completed;
  end if;
  -- snapshots
  stats_new_modified := date_trunc('hour', new.modified);
  stats_old_modified := date_trunc('hour', old.modified);
  if (stats_old_modified != stats_new_modified or old.jobstatus != new.jobstatus) then
    insert into job_instance_stats_stage
        (
        rowid,
        objectid,
        modified_orig,
        modified_new,
        status_orig,
        status_new,
        dml_operation,
        created
        )
        values
        (
        nextval('seq_job_instance_stats_stage'),
        new.jobid,
        stats_old_modified,
        stats_new_modified,
        old.jobstatus,
        new.jobstatus,
        'U',
        current_timestamp
        );
  end if;
  -- snapshots
  return new;
end;
$function$", #",
                "trig_job_instance_delete()": "returns trigger language plpgsql as $function$
begin
  -- snapshots
  insert into job_instance_stats_stage
        (
        rowid,
        objectid,
        modified_orig,
        modified_new,
        status_orig,
        status_new,
        dml_operation,
        created
        )
        values
        (
        nextval('seq_job_instance_stats_stage'),
        old.jobid,
        date_trunc('hour', old.modified),
        null,
        old.jobstatus,
        null,
        'D',
        current_timestamp
        );
  -- snapshots
  return old;
end;
$function$", #",
            ),
        ),
    ),
    "triggers": (
        "driver": (
            "oracle": (
                "trig_job_instance": "BEFORE INSERT OR UPDATE OR DELETE ON JOB_INSTANCE
REFERENCING NEW AS NEW OLD AS OLD
FOR EACH ROW
declare
    dml_operation varchar2(1) := 'D';
    jobid number(14) := :old.jobid;
    stats_new_modified date;
    stats_old_modified date;
begin
  --
  if inserting or updating then
    --
    if :new.modified is null or :new.modified = :old.modified then
      :new.modified := localtimestamp;
    end if;
    --
  end if;
  --
  if inserting then
    if :new.job_instanceid is null then
      select seq_job_instance.nextval into :new.job_instanceid from dual;
    end if;
    if :new.jobstatus is null then
      select 'I' into :new.jobstatus from dual;
    end if;
    if :new.started is null then
      :new.started := localtimestamp;
    end if;
    --
    dml_operation := 'I';
    jobid := :new.jobid;
    --
  else
    if updating then
      if :new.jobstatus = 'C' and :new.completed is null then
        :new.completed := localtimestamp;
      end if;
      --
      dml_operation := 'U';
      --
    end if;
  end if;
  -- snapshots
  stats_new_modified := trunc(:new.modified, 'HH24');
  stats_old_modified := trunc(:old.modified, 'HH24');
  if (inserting or deleting
      or (updating and (stats_old_modified != stats_new_modified
                        or :old.jobstatus != :new.jobstatus)
         )
     ) then
    insert into job_instance_stats_stage
        (
        objectid,
        modified_orig,
        modified_new,
        status_orig,
        status_new,
        dml_operation,
        created
        )
        values
        (
        jobid,
        stats_old_modified,
        stats_new_modified,
        :old.jobstatus,
        :new.jobstatus,
        dml_operation,
        current_timestamp
        );
  end if;
  -- snapshots
end;",
            ),
            "pgsql": {
                "trig_job_instance_insert" :
                    "before insert on job_instance for each row "
                    "execute procedure trig_job_instance_insert()",
                "trig_job_instance_update" :
                            "before update on job_instance for each row "
                            "execute procedure trig_job_instance_update()",
                "trig_job_instance_delete" :
                            "before delete on job_instance for each row "
                            "execute procedure trig_job_instance_delete()",
            },
            "mysql": (
                "trig_job_instance_insert": "before insert on job_instance for each row
begin
  if new.started is null then
    set new.started = now();
  end if;
  if new.modified is null then
    set new.modified = now();
  end if;
  -- snapshots
  insert into job_instance_stats_stage
    (
        objectid,
        modified_orig,
        modified_new,
        status_orig,
        status_new,
        dml_operation,
        created
    )
    values
    (
        new.jobid,
        null,
        cast(date_format(new.modified, '%Y-%m-%d %H:00:00') as datetime),
        null,
        new.jobstatus,
        'I',
        now()
    );
  -- snapshots
end",
                "trig_job_instance_update": "before update on job_instance for each row
begin
  declare stats_new_modified datetime;
  declare stats_old_modified datetime;
  if new.modified is null or new.modified = old.modified then
    set new.modified = now();
  end if;
  if new.jobstatus = 'C' and new.completed is null then
    set new.completed = now();
  end if;
  -- snapshots
  set stats_new_modified = cast(date_format(new.modified, '%Y-%m-%d %H:00:00') as datetime);
  set stats_old_modified = cast(date_format(old.modified, '%Y-%m-%d %H:00:00') as datetime);
  if (stats_old_modified != stats_new_modified or old.jobstatus != new.jobstatus) then
    insert into job_instance_stats_stage
    (
        objectid,
        modified_orig,
        modified_new,
        status_orig,
        status_new,
        dml_operation,
        created
    )
    values
    (
        new.jobid,
        old.modified,
        new.modified,
        old.jobstatus,
        new.jobstatus,
        'U',
        now()
    );
  end if;
  -- snapshots
end",
                "trig_job_instance_delete": "before delete on job_instance for each row
begin
  -- snapshots
  insert into job_instance_stats_stage
    (
        objectid,
        modified_orig,
        modified_new,
        status_orig,
        status_new,
        dml_operation,
        created
    )
    values
    (
        old.jobid,
        cast(date_format(old.modified, '%Y-%m-%d %H:00:00') as datetime),
        null,
        old.jobstatus,
        null,
        'D',
        now()
    );
  -- snapshots
end",
            ),
        ),
    ),
);

const T_JobErrors = (
    "arch" : Arch::TEMPLATE_JOBID,
    "columns": (
        "job_errorid": c_number(14, True),
        "job_instanceid": c_number(14),
        "severity": c_varchar(20, True),
        "error": c_varchar(240, True),
        "description": c_varchar(4000),
        "info": c_clob(),
        "business_error": c_number(1, True),
        "created": c_timestamp(NN_TrueExceptMysql),
    ),
    "indexes": (
        "driver": ("oracle": ("pk_job_errors": ("columns": ("job_errorid"), "unique": True))),
        "sk_je_job_instanceid": ("columns": "job_instanceid"),
        "sk_job_errors_sev": ("columns": ("severity")),
    ),
    "primary_key": ("name": "pk_job_errors", "columns": ("job_errorid")),
    "foreign_constraints": (
        "fk_job_errors_ji": ("columns": "job_instanceid", "table": "job_instance"),
        "fk_job_errors_es": ("columns": "severity", "table": "error_severity"),
    ),
    "driver": (
        "pgsql": get_pgsql_trigger_func("job_errors", True, "job_errorid", "seq_job_errorid", False),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("job_errors", True, "job_errorid", "seq_job_errorid"),
            "pgsql": get_pgsql_trigger("job_errors"),
            "mysql": get_mysql_triggers("job_errors", True, "job_errorid", "seq_job_errorid"),
        ),
    ),
);

const T_AuditEventCodes = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "audit_event_code": c_number(14, True),
        "description": c_varchar(4000),
        "created": c_date(NN_TrueExceptMysql),
        "modified": c_date(),
    ),
    "indexes": (
        "driver": ("oracle": ("pk_audit_event_codes": ("columns": ("audit_event_code"), "unique": True))),
    ),
    "primary_key": ("name": "pk_audit_event_codes", "columns": ("audit_event_code")),
    "driver": (
        "pgsql": get_pgsql_trigger_func("audit_event_codes"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("audit_event_codes"),
            "pgsql": get_pgsql_trigger("audit_event_codes"),
            "mysql": get_mysql_triggers("audit_event_codes"),
        ),
    ),
);

const T_AuditEvents = (
    "arch" : (
        "type" : Arch::TYPE_LIVE,
        "data" : Arch::DATA_CUSTOM,
    ),
    "columns": (
        "audit_eventid": c_number(14, True),
        "related_audit_eventid": c_number(14),

        "workflowid": c_number(14),
        "workflow_instanceid": c_number(14),
        "stepid": c_number(14),
        "ind": c_number(5),
        "jobid": c_number(14),
        "job_instanceid": c_number(14),
        "serviceid": c_number(14),

        "audit_event_code": c_number(14, True),
        "audit_user_event": c_varchar(80),

        "reason": c_varchar(4000),
        "who": c_varchar(4000),
        "source": c_varchar(4000),

        "info1": c_varchar(4000),
        "info2": c_varchar(4000),

        "created": c_timestamp(NN_TrueExceptMysql),
    ),
    "indexes": (
        "driver": ("oracle": ("pk_audit_events": ("columns": ("audit_eventid"), "unique": True))),
        "sk_audit_events_related": ("columns": "related_audit_eventid"),
        "sk_audit_events_wfid": ("columns": ("workflowid")),
        "sk_audit_events_wf": ("columns": ("workflow_instanceid")),
        "sk_audit_events_step": ("columns": ("workflow_instanceid", "stepid", "ind")),
        "sk_audit_events_job": ("columns": ("jobid")),
        "sk_audit_events_job_instance": ("columns": ("job_instanceid")),
        "sk_audit_events_service": ("columns": ("serviceid")),
        "sk_audit_events_code": ("columns": ("audit_event_code")),
        "sk_audit_events_user": ("columns": ("audit_user_event")),
    ),
    "primary_key": ("name": "pk_audit_events", "columns": ("audit_eventid")),
    "foreign_constraints": (
        # bug #1945 - do not enforce FK for related_audit_eventid "fk_audit_events_related": ("columns": "related_audit_eventid", "table": "audit_events", "target_columns": ("audit_eventid")),
        "fk_audit_events_wfid": ("columns": "workflowid", "table": "workflows"),
        "fk_audit_events_wf": ("columns": "workflow_instanceid", "table": "workflow_instance"),
        "fk_audit_events_step": ("columns": ("workflow_instanceid", "stepid", "ind"), "table": "step_instance"),
        "fk_audit_events_job": ("columns": "jobid", "table": "jobs"),
        "fk_audit_events_job_instance": ("columns": "job_instanceid", "table": "job_instance"),
        "fk_audit_events_service": ("columns": "serviceid", "table": "services"),
        "fk_audit_events_code": ("columns": "audit_event_code", "table": "audit_event_codes"),
    ),
    "driver": (
        "pgsql": get_pgsql_trigger_func("audit_events", True, "audit_eventid", "seq_audit_eventid", False),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("audit_events", True, "audit_eventid", "seq_audit_eventid"),
            "pgsql": get_pgsql_trigger("audit_events"),
            "mysql": get_mysql_triggers("audit_events", True, "audit_eventid", "seq_audit_eventid"),
        ),
    ),
);

const T_Groups = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "groupid": c_number(14, True),
        "name": c_varchar(80, True),
        "description": c_varchar(4000),
        "enabled": c_number(1, True),
        "created": c_date(NN_TrueExceptMysql),
        "modified": c_date(),
    ),
    "indexes": (
        "driver": (
            "oracle": (
                "pk_groups": ("columns": ("groupid"), "unique": True),
            ),
        ),
        "sk_groups_name": ("columns": ("name"), "unique": True),
    ),
    "primary_key": ("name": "pk_groups", "columns": ("groupid")),
    "unique_constraints": (
        "sk_groups_name": ("columns": ("name")),
    ),
    "driver": (
        "pgsql": get_pgsql_trigger_func("groups", False, "groupid", "seq_groups"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("groups", False, "groupid", "seq_groups"),
            "pgsql": get_pgsql_trigger("groups", True),
            "mysql": get_mysql_triggers("groups", False, "groupid", "seq_groups")
        ),
    ),
);

const T_GroupWorkflows = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "groupid": c_number(14, True),
        "workflowid": c_number(14, True),
        "created": c_date(NN_TrueExceptMysql),
        "modified": c_date(),
    ),
    "indexes": (
        "driver": ("oracle": ("pk_group_workflows": ("columns": ("groupid", "workflowid"), "unique": True))),
        "fk_group_workflows_groupid": ("columns": ("groupid")),
        "fk_group_workflows_wfid": ("columns": ("workflowid")),
    ),
    "primary_key": ("name": "pk_group_workflows", "columns": ("groupid", "workflowid")),
    "foreign_constraints": (
        "fk_group_workflows_groupid": ("columns": ("groupid"), "table": "groups"),
        "fk_group_workflows_wfid": ("columns": ("workflowid"), "table": "workflows"),
    ),
    "driver": (
        "pgsql": get_pgsql_trigger_func("group_workflows"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("group_workflows"),
            "pgsql": get_pgsql_trigger("group_workflows"),
            "mysql": get_mysql_triggers("group_workflows"),
        ),
    ),
);

const T_GroupServices = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "groupid": c_number(14, True),
        "serviceid": c_number(14, True),
        "created": c_date(NN_TrueExceptMysql),
        "modified": c_date(),
    ),
    "indexes": (
        "driver": ("oracle": ("pk_group_services": ("columns": ("groupid", "serviceid"), "unique": True))),
        "fk_group_services_groupid": ("columns": ("groupid")),
        "fk_group_services_svcid": ("columns": ("serviceid")),
    ),
    "primary_key": ("name": "pk_group_services", "columns": ("groupid", "serviceid")),
    "foreign_constraints": (
        "fk_group_services_groupid": ("columns": ("groupid"), "table": "groups"),
        "fk_group_services_svcid": ("columns": ("serviceid"), "table": "services"),
    ),
    "driver": (
        "pgsql": get_pgsql_trigger_func("group_services"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("group_services"),
            "pgsql": get_pgsql_trigger("group_services"),
            "mysql": get_mysql_triggers("group_services"),
        ),
    ),
);

const T_GroupJobs = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "groupid": c_number(14, True),
        "jobid": c_number(14, True),
        "created": c_date(NN_TrueExceptMysql),
        "modified": c_date(),
    ),
    "indexes": (
        "driver": ("oracle": ("pk_group_jobs": ("columns": ("groupid", "jobid"), "unique": True))),
        "fk_group_jobs_groupid": ("columns": ("groupid")),
        "fk_group_jobs_jobid": ("columns": ("jobid")),
    ),
    "primary_key": ("name": "pk_group_jobs", "columns": ("groupid", "jobid")),
    "foreign_constraints": (
        "fk_group_jobs_groupid": ("columns": ("groupid"), "table": "groups"),
        "fk_group_jobs_jobid": ("columns": ("jobid"), "table": "jobs"),
    ),
    "driver": (
        "pgsql": get_pgsql_trigger_func("group_jobs"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("group_jobs"),
            "pgsql": get_pgsql_trigger("group_jobs"),
            "mysql": get_mysql_triggers("group_jobs"),
        ),
    ),
);

const T_GroupMappers = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "groupid": c_number(14, True),
        "mapperid": c_number(14, True),
        "created": c_date(NN_TrueExceptMysql),
        "modified": c_date(),
    ),
    "indexes": (
        "driver": ("oracle": ("pk_group_mappers": ("columns": ("groupid", "mapperid"), "unique": True))),
        "fk_group_mappers_groupid": ("columns": ("groupid")),
        "fk_group_mappers_mapperid": ("columns": ("mapperid")),
    ),
    "primary_key": ("name": "pk_group_mappers", "columns": ("groupid", "mapperid")),
    "foreign_constraints": (
        "fk_group_mappers_groupid": ("columns": ("groupid"), "table": "groups"),
        "fk_group_mappers_mapperid": ("columns": ("mapperid"), "table": "mappers"),
    ),
    "driver": (
        "pgsql": get_pgsql_trigger_func("group_mappers"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("group_mappers"),
            "pgsql": get_pgsql_trigger("group_mappers"),
            "mysql": get_mysql_triggers("group_mappers"),
        ),
    ),
);

const T_GroupVMaps = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "groupid": c_number(14, True),
        "id": c_number(14, True),
        "created": c_date(NN_TrueExceptMysql),
        "modified": c_date(),
    ),
    "indexes": (
        "driver": ("oracle": ("pk_group_vmaps": ("columns": ("groupid", "id"), "unique": True))),
        "fk_group_vmaps_groupid": ("columns": ("groupid")),
        "fk_group_vmaps_id": ("columns": ("id")),
    ),
    "primary_key": ("name": "pk_group_vmaps", "columns": ("groupid", "id")),
    "foreign_constraints": (
        "fk_group_vmaps_groupid": ("columns": ("groupid"), "table": "groups"),
        "fk_group_vmaps_id": ("columns": ("id"), "table": "value_maps"),
    ),
    "driver": (
        "pgsql": get_pgsql_trigger_func("group_vmaps"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("group_vmaps"),
            "pgsql": get_pgsql_trigger("group_vmaps"),
            "mysql": get_mysql_triggers("group_vmaps"),
        ),
    ),
);

const T_GroupFsms = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "groupid": c_number(14, True),
        "fsm": c_varchar(160, True, "unique Finite State Machine name"),
        "created": c_date(NN_TrueExceptMysql),
        "modified": c_date(),
    ),
    "indexes": (
        "driver": ("oracle": ("pk_group_fsms": ("columns": ("groupid", "fsm"), "unique": True))),
        "fk_group_fsms_groupid": ("columns": ("groupid")),
        "fk_group_fsms_fsm": ("columns": ("fsm")),
    ),
    "primary_key": ("name": "pk_group_fsms", "columns": ("groupid", "fsm")),
    "foreign_constraints": (
        "fk_group_fsms_groupid": ("columns": ("groupid"), "table": "groups"),
        "fk_group_fsms_fsm": ("columns": ("fsm"), "table": "fsm", "target_columns": "name"),
    ),
    "driver": (
        "pgsql": get_pgsql_trigger_func("group_fsms"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("group_fsms"),
            "pgsql": get_pgsql_trigger("group_fsms"),
            "mysql": get_mysql_triggers("group_fsms"),
        ),
    ),
);

const T_GroupPipelines = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "groupid": c_number(14, True),
        "pipeline": c_varchar(160, True, "unique data pipeline name"),
        "created": c_date(NN_TrueExceptMysql),
        "modified": c_date(),
    ),
    "indexes": (
        "driver": ("oracle": ("pk_group_pipelines": ("columns": ("groupid", "pipeline"), "unique": True))),
        "fk_group_pipelines_groupid": ("columns": ("groupid")),
        "fk_group_pipelines_pipeline": ("columns": ("pipeline")),
    ),
    "primary_key": ("name": "pk_group_pipelines", "columns": ("groupid", "pipeline")),
    "foreign_constraints": (
        "fk_group_pipelines_groupid": ("columns": ("groupid"), "table": "groups"),
        "fk_group_pipelines_pipeline": ("columns": ("pipeline"), "table": "pipelines", "target_columns": "name"),
    ),
    "driver": (
        "pgsql": get_pgsql_trigger_func("group_pipelines"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("group_pipelines"),
            "pgsql": get_pgsql_trigger("group_pipelines"),
            "mysql": get_mysql_triggers("group_pipelines"),
        ),
    ),
);

const T_OmqSequences = (
    "columns": (
        "name": c_varchar(40, True),
        "id": c_number(14, True),
    ),
    "primary_key": ("name": "pk_omqsequences", "columns": ("name")),
);

const T_Connections = {
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": {
        "connectionid": c_number(14, True),
        "name": c_varchar(100, True),
        "description": c_varchar(4000, True),
        "url": c_varchar(1000, True),
        "options": c_varchar(4000, False),
        "monitor": c_number(1, True) + {"default_value": 1},
        "created": c_date(NN_TrueExceptMysql),
        "modified": c_date(),
        "manually_updated": c_number(1, True) + {"default_value": 0},
        "enabled": c_number(1, C_NOT_NULL) + {"default_value": 1},
        "debug_data": c_number(1, True) + {"default_value": 0},
        "connection_type": c_varchar(10, C_NOT_NULL, "FK to CONNECTION_TYPES") + {"default_value": "USER"},
        "loggerid": c_number(14, "datasources can have their own loggers, not set = use default logger"),
    },
    "indexes": {
        "driver": {
            "oracle": {
                "pk_connections": {
                    "columns": "connectionid",
                    "unique": True,
                },
            },
        },
        "sk_connections_type": {"columns": "connection_type"},
        "sk_connections": {
            "columns": ("name"),
            "unique": True,
        },
    },
    "primary_key": {
        "name": "pk_connections",
        "columns": "connectionid",
    },
    "foreign_constraints": {
        "sk_connections_type": {"columns": ("connection_type",), "table": "connection_types"},
        "fk_conn_loggerid": {"columns": "loggerid", "table": "loggers"},
    },
    "driver": {
        "pgsql": get_pgsql_trigger_func("connections", False, "connectionid", "seq_connections"),
    },
    "triggers": {
        "driver": {
            "oracle": get_oracle_trigger("connections", False, "connectionid", "seq_connections"),
            "pgsql": get_pgsql_trigger("connections"),
            "mysql": get_mysql_triggers("connections", False, "connectionid", "seq_connections"),
        },
    },
};

const T_ConnectionTags = {
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": {
        "connectionid": c_number(14, True),
        "tag": c_varchar(255, True),
        "value": c_varchar(4000, True),
        "created": c_timestamp(NN_TrueExceptMysql),
        "modified": c_timestamp(False),
    },
    "indexes": {
        "driver": {
            "oracle": {
                "pk_connection_tags": {
                    "columns": ("connectionid", "tag"),
                    "unique": True,
                },
            },
        },
        "sk_conntags_connections": {"columns": "connectionid"},
        "sk_conntags_tags": {
            "columns": "tag",
        },
    },
    "primary_key": {
        "name": "pk_connection_tags",
        "columns": ("connectionid", "tag")
    },
    "foreign_constraints": {
        "fk_conn_tags_connections": {
            "columns": ("connectionid"),
            "table": "connections",
        },
    },
    "driver": {
        "pgsql": get_pgsql_trigger_func("connection_tags"),
    },
    "triggers": {
        "driver": {
            "oracle": get_oracle_trigger("connection_tags"),
            "pgsql": get_pgsql_trigger("connection_tags"),
            "mysql": get_mysql_triggers("connection_tags"),
        },
    },
};

const T_ConnectionTypes = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "connection_type": c_varchar(10, C_NOT_NULL),
        "description": c_varchar(4000, C_NOT_NULL),
        "created": c_date(NN_TrueExceptMysql),
        "modified": c_date(),
    ),
    "indexes": (
        "driver": ("oracle": ("pk_connection_types": ("columns": ("connection_type"), "unique": True))),
    ),
    "primary_key": ("name": "pk_connection_types", "columns": ("connection_type")),
    "driver": (
        "pgsql": get_pgsql_trigger_func("connection_types"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("connection_types"),
            "pgsql": get_pgsql_trigger("connection_types"),
            "mysql": get_mysql_triggers("connection_types"),
        ),
    ),
);

const T_Releases = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "release_name": c_varchar(100, True, "the name or label of the release"),
        "description": c_varchar(4000, False, "an optional description for the release"),
        "os_user": c_varchar(200, True),
        "os_host": c_varchar(200, True),
        "created": c_timestamp(NN_TrueExceptMysql, "the created timestamp for the release"),
        "modified": c_timestamp("the modified timestamp for the release"),
    ),
    "indexes": (
        "driver": ("oracle": ("pk_releases": ("columns": ("release_name"), "unique": True))),
    ),
    "primary_key": ("name": "pk_releases", "columns": ("release_name")),
    "driver": (
        "pgsql": get_pgsql_trigger_func("releases"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("releases"),
            "pgsql": get_pgsql_trigger("releases"),
            "mysql": get_mysql_triggers("releases"),
        ),
    ),
);

const T_ReleaseFiles = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "release_name": c_varchar(100, True, "the name or label of the release"),
        "file_name": c_varchar(1000, True, "the complete path of the source file") + (
            "driver": (
                # due to limitations with InnoDB, columns particuipating in primary keys cannot be longer than 254 chars
                "mysql": ("size": 254,),
            ),
        ),
        "file_type": c_varchar(100, True, "the type of file"),
        "in_db": c_number(1, True, "flag if the component is in the database"),
        "hash_type": c_varchar(20, "the type of hash"),
        "hash": c_varchar(512, "the cryptographic hash for the component"),
        "created": c_timestamp(NN_TrueExceptMysql, "the created timestamp for the release"),
        "modified": c_timestamp("the modified timestamp for the release"),
    ),
    "indexes": (
        "driver": ("oracle": ("pk_release_files": ("columns": ("release_name", "file_name"), "unique": True))),
        "sk_release_files_release": ("columns": "release_name"),
    ),
    "primary_key": ("name": "pk_releases_files", "columns": ("release_name", "file_name")),
    "foreign_constraints": (
        "sk_release_files_release": ("columns": ("release_name"), "table": "releases"),
    ),
    "driver": (
        "pgsql": get_pgsql_trigger_func("release_files"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("release_files"),
            "pgsql": get_pgsql_trigger("release_files"),
            "mysql": get_mysql_triggers("release_files"),
        ),
    ),
);

const T_ReleaseFileContents = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "id": c_number(14, True, "the primary key for this table"),
        "release_name": c_varchar(100, True, "the name or label of the release"),
        "file_name": c_varchar(1000, True, "the complete path of the source file") + (
            "driver": (
                # due to limitations with InnoDB, columns particuipating in primary keys cannot be longer than 254 chars
                "mysql": ("size": 254,),
            ),
        ),
        "component": c_varchar(200, True, "the name of the component"),
        "component_version": c_varchar(40, "the version of the component"),
        "component_id": c_number(14, "the ID of the component"),
        "hash_type": c_varchar(20, "the type of hash"),
        "hash": c_varchar(512, "the cryptographic hash for the component"),
        "created": c_timestamp(NN_TrueExceptMysql, "the created timestamp for the component"),
        "modified": c_timestamp("the modified timestamp for the component"),
    ),
    "indexes": (
        "driver": ("oracle": ("pk_release_file_contents": ("columns": ("id"), "unique": True))),
        "sk_rfc_release": ("columns": ("release_name")),
        "sk_rfc_release_files": ("columns": ("release_name", "file_name")),
    ),
    "primary_key": ("name": "pk_releases_contents", "columns": ("id")),
    "foreign_constraints": (
        "sk_rfc_release": ("columns": ("release_name"), "table": "releases"),
        "sk_rfc_release_files": ("columns": ("release_name", "file_name"), "table": "release_files"),
    ),
    "driver": (
        "pgsql": get_pgsql_trigger_func("release_file_contents", False, "id", "seq_release_file_contents"),
    ),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("release_file_contents", False, "id", "seq_release_file_contents"),
            "pgsql": get_pgsql_trigger("release_file_contents"),
            "mysql": get_mysql_triggers("release_file_contents", False, "id", "seq_release_file_contents"),
        ),
    ),
);

# arch service calculations for WFIIDs
const T_ArchWfInstances = (
    "arch" : {"type" : Arch::TYPE_EXCLUDED},
    "columns" : (
            "top_parent"            : c_number(14, True, "Top level WFIID"),
            "workflow_instanceid"   : c_number(14, True, "Current WFIID"),
            "workflowstatus"        : c_char(1, True, "workflow instance status"),
            "wf_level"              : c_number(14, True, "Level of the current WFIID"),
        ),
);

# arch service calculations for JOBIDs
const T_ArchJobInstances = (
    "arch" : {"type" : Arch::TYPE_EXCLUDED},
    "columns" : (
            "job_instanceid"        : c_number(14, True, "Job instance ID"),
        ),
);

const T_ValueMaps = (
    "arch": Arch::TEMPLATE_META_UPSERT,
    "columns": (
        "id": c_number(14, True, "the primary key for the value map"),
        "name": c_varchar(160, True, "the name of the value map object"),
        "description": c_varchar(4000, "the description of the value map object"),
        "author": c_varchar(240, "the author of the value map object"),
        "throws_exception": c_number(1, True, "flag if a missing value for a key throws an exception instead of returning NOTHING") + ( "default_value" : 0 ),
        "valuetype": c_varchar(6, True, "the type used for values"),
        "dateformat": c_varchar(100, False, "the date conversion mask"),
        "mapsize": c_number(14, True, "count of values in the set") + ( "default_value" : 0 ),
        "created": c_timestamp(NN_TrueExceptMysql, "the created date for the value map object"),
        "modified": c_timestamp(False, "the last modified date for the value map object"),
    ),
    "indexes": (
        "driver": ( "oracle": ("pk_value_maps": ("columns": "id", "unique": True))),
        "sk_value_maps_name": ("columns": "name", "unique" : True),
    ),
    "primary_key": ("name": "pk_value_maps", "columns": "id"),
    "driver": ("pgsql": get_pgsql_trigger_func("value_maps", False, "id", "seq_value_maps")),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("value_maps", False, "id", "seq_value_maps"),
            "pgsql": get_pgsql_trigger("value_maps"),
            "mysql": get_mysql_triggers("value_maps", False, "id", "seq_value_maps"),
        ),
    ),
);

const T_ValueMapValues = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns" : (
        "value_map_id": c_number(14, True, "the foreign key for the value map"),
        "keyname": c_varchar(160, True, "the key of the value map value"),
        "value": c_clob(True, "the serialized value for the key"),
        "enabled": c_number(1, True, "flag if the value can be the used or not (for testing, or prod unusual handling)") + ( "default_value" : 1 ),
        "created": c_timestamp(NN_TrueExceptMysql, "the created date for the value map object"),
        "modified": c_timestamp(False, "the last modified date for the value map object"),
    ),
    "indexes": (
        "driver": ( "oracle": ("pk_value_map_values": ("columns": ("value_map_id", "keyname"), "unique": True))),
    ),
    "primary_key": ("name": "pk_value_map_values", "columns": ("value_map_id", "keyname")),
    "foreign_constraints": (
        "fk_value_maps": ("columns": "value_map_id", "table": "value_maps", "target_columns": "id"),
    ),
    "driver": ("pgsql": get_pgsql_trigger_func("value_map_values")),
    "triggers": (
        "driver": (
            "oracle": get_oracle_trigger("value_map_values"),
            "pgsql": get_pgsql_trigger("value_map_values"),
            "mysql": get_mysql_triggers("value_map_values"),
        ),
    ),
);

const T_ServiceAuthLabels = (
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns" : {
            "authlabelid" : c_varchar(240, True, "label id/label name"),
            "serviceid" : c_number(14, True),
            "value" : c_varchar(265, True, "label value"),
            "created": c_timestamp(NN_TrueExceptMysql, "the created date for the authentication label"),
            "modified": c_timestamp(False, "the last modified date for the authentication label"),
    },
    "primary_key": ("name": "pk_auth_labels", "columns": ("authlabelid", "serviceid")),
    "foreign_constraints": (
        "fk_label_service": ("columns": "serviceid", "table": "services", "target_columns": "serviceid"),
    ),
);

const T_WorkflowInstanceStats = {
    "arch" : { "type" : Arch::TYPE_EXCLUDED },
    "columns" : {
        "objectid" : c_number(14, C_NOT_NULL),
        "modified" : c_date(C_NOT_NULL),
        "status" : c_char(1, C_NOT_NULL),
        "total_count" : Schema::c_number(C_NOT_NULL),
    },
    "foreign_constraints": {
        "fk_workflow_instance_stats": {"columns": "objectid", "table": "workflows", "target_columns": "workflowid"},
    },
    "indexes" : {
        "pk_workflow_instance_stats" : {"columns": ("objectid", "modified", "status"), "unique" : True},
    }
};

const T_WorkflowInstanceStatsStage = {
    "arch" : { "type" : Arch::TYPE_EXCLUDED },
    "columns" : {
        "driver" : { "pgsql" : { "rowid" : c_number(C_NOT_NULL) },
                     "mysql" : { "rowid" : c_int(C_NOT_NULL) + { "native_type" : "bigint", "auto_increment" : True, }, },
        },
        "objectid" : c_number(14, C_NOT_NULL),
        "modified_orig" : c_date(C_NULL),
        "modified_new" : c_date(C_NULL),
        "status_orig" : c_char(1, C_NULL),
        "status_new" : c_char(1, C_NULL),
        "dml_operation" : c_varchar(1, C_NOT_NULL),
        "created" : c_timestamp(C_NOT_NULL),
    },
    "indexes" : {
        "driver" : { "pgsql" : { "pk_workflow_instances_stats_stage" : {"columns" : "rowid", "unique" : True}},
                     #"mysql" : { "pk_workflow_instances_stats_stage" : {"columns" : "rowid", "unique" : True}},
        },
    },
    "primary_key": {
        "driver": { "mysql" : {"name": "pk_workflow_instance_stats_stage", "columns": "rowid"}},
    },
    "foreign_constraints": {
        "fk_workflow_instance_stage": {"columns": "objectid", "table": "workflows", "target_columns": "workflowid"},
    },
    # This should be a nologging one - qore#2975
};

const T_JobInstanceStats = {
    "arch" :{ "type" : Arch::TYPE_EXCLUDED },
    "columns" : {
        "objectid" : c_number(14, C_NOT_NULL),
        "modified" : c_date(C_NOT_NULL),
        "status" : c_char(1, C_NOT_NULL),
        "total_count" : c_number(C_NOT_NULL),
    },
    "foreign_constraints": {
        "fk_job_instance_stats": {"columns": "objectid", "table": "jobs", "target_columns": "jobid"},
    },
    "indexes" : {
        "pk_job_instance_stats" : {"columns": ("objectid", "modified", "status"), "unique" : True},
    },
};

const T_JobInstanceStatsStage = {
    "arch": {
        "type": Arch::TYPE_EXCLUDED,
    },
    "columns": {
        "driver": {
            "pgsql": {
                "rowid": c_int(C_NOT_NULL),
            },
            "mysql": {
                "rowid": c_int(C_NOT_NULL) + {
                    "native_type": "bigint",
                    "auto_increment": True,
                },
            },
        },
        "objectid": c_number(14, C_NOT_NULL),
        "modified_orig": c_date(C_NULL),
        "modified_new": c_date(C_NULL),
        "status_orig": c_char(1, C_NULL),
        "status_new": c_char(1, C_NULL),
        "dml_operation": c_varchar(1, C_NOT_NULL),
        "created": c_timestamp(C_NOT_NULL),
    },
    "indexes": {
        "driver": {
            "pgsql": {
                "pk_job_instances_stats_stage": {
                    "columns": "rowid",
                    "unique": True,
                },
            },
            #"mysql": {"pk_job_instances_stats_stage": {"columns": "rowid", "unique": True}},
        },
    },
    "primary_key": {
        "driver": {
            "mysql": {
                "name": "pk_workflow_instance_stats_stage",
                "columns": "rowid",
            },
        },
    },
    "foreign_constraints": {
        "fk_job_instance_stage": {
            "columns": "objectid",
            "table": "jobs",
            "target_columns": "jobid",
        },
    },
    # This should be a nologging one - qore#2975
};

const T_DataTypes = {
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": {
        "path": c_varchar(4000, True, "the unique path for the type and PK"),
        "typeinfo": c_blob(True, "the serialized type information"),
        "created": c_timestamp(NN_TrueExceptMysql, "the created timestamp for the type"),
        "modified": c_timestamp("the modified timestamp for the type"),
        "driver": {
            "mysql": {
                "path": c_varchar(767, True, "the unique path for the type and PK"),
            },
        },
    },
    "indexes": {
        "driver": {
            "oracle": {
                "pk_data_types": {
                    "columns": ("path"),
                    "unique": True,
                },
            },
        },
    },
    "primary_key": {
        "name": "pk_data_types",
        "columns": ("path"),
    },
    "driver": {
        "pgsql": get_pgsql_trigger_func("data_types"),
    },
    "triggers": {
        "driver": {
            "oracle": get_oracle_trigger("data_types"),
            "pgsql": get_pgsql_trigger("data_types"),
            "mysql": get_mysql_triggers("data_types"),
        },
    },
};

const T_Pipelines = {
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": {
        "name": c_varchar(160, True, "the name of the pipeline object"),
        "description": c_varchar(4000),
        "children": c_clob(False, "pipeline elements defined in YAML"),
        "options": c_clob(False, "any pipeline options in serialized YAML"),
        "created": c_timestamp(NN_TrueExceptMysql, "the created timestamp for the pipeline"),
        "modified": c_timestamp("the modified timestamp for the pipeline"),
    },
    "indexes": {
        "driver": {
            "oracle": {
                "pk_pipelines": {
                    "columns": ("name"),
                    "unique": True,
                },
            },
        },
    },
    "primary_key": {
        "name": "pk_pipelines",
        "columns": ("name"),
    },
    "driver": {
        "pgsql": get_pgsql_trigger_func("pipelines"),
    },
    "triggers": {
        "driver": {
            "oracle": get_oracle_trigger("pipelines"),
            "pgsql": get_pgsql_trigger("pipelines"),
            "mysql": get_mysql_triggers("pipelines"),
        },
    },
};

const T_PipelineLib = {
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": {
        "pipeline": c_varchar(160, True),
        "type": c_varchar(20, True),
        "name": c_varchar(160, True),
        "load_order": c_number(4, True) + {"default_value": 1},
    },
    "indexes": {
        "driver": {
            "oracle": {
                "pk_pipeline_lib": {"columns": ("pipeline", "type", "name"), "unique": True}
            },
            "mysql": {
                "fk_pipeline_lib_type": {"columns": "type"},
            },
        },
        "sk_pipeline_lib_type": {"columns": ("pipeline", "type")},
        "sk_pipeline_lib_pipeline": {"columns": ("pipeline")},
    },
    "primary_key": {"name": "pk_pipeline_lib", "columns": ("pipeline", "type", "name")},
    "foreign_constraints": {
        "fk_pipeline_lib_type": {"columns": "type", "table": "library_type", "target_columns": ("name")},
        "fk_pipeline_lib_pipeline": {"columns": "pipeline", "table": "pipelines", "target_columns": ("name")},
    },
};

const T_PipelineConfigItems = {
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": {
        "pipeline": c_varchar(160, True, "the name of the pipeline object"),
        "name": c_varchar(240, True, "the configuration item name with prefix"),
        "prefix": c_varchar(240, False, "the configuration item prefix"),
        "type": c_varchar(240, True, "the configuration item type"),
        "default_value": c_varchar(4000, False, "the configuration item default value as a serialized string"),
        "strictly_local": c_number(1, True, "allow this config item to be overridden at the next level") +
            {"default_value": 1},
        "description": c_varchar(4000, "the description of the configuration item"),
        "config_group": c_varchar(240, True, "the group of the configuration item") + {"default_value": "Default"},
        "allowed_values": c_varchar(4000, False, "the list of allowed values of the configuration item"),
        "sensitive": c_number(1, True, "sensitive field flag") + {"default_value": 0},

        "created": c_timestamp(NN_TrueExceptMysql),
        "modified": c_timestamp(),
    },
    "indexes": {
        "driver": {
            "oracle": {
                "pk_pipeline_config_items": {
                    "columns": ("pipeline", "name"),
                    "unique": True,
                },
            },
        },
    },
    "foreign_constraints": {
        "fk_pipeline_ci_pl": {
            "columns": "pipeline",
            "table": "pipelines",
            "target_columns": "name",
        },
    },
    "primary_key": {
        "name": "pk_pipeline_config_items",
        "columns": ("pipeline", "name"),
    },
    "driver": {
        "pgsql": get_pgsql_trigger_func("pipeline_config_items"),
    },
    "triggers": {
        "driver": {
            "oracle": get_oracle_trigger("pipeline_config_items"),
            "pgsql": get_pgsql_trigger("pipeline_config_items"),
            "mysql": get_mysql_triggers("pipeline_config_items"),
        },
    },
};

const T_FSM = {
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": {
        "name": c_varchar(160, True, "the name of the Finite State Machine object"),
        "description": c_varchar(4000),
        "states": c_clob(False, "FSM states defined in YAML"),
        "options": c_clob(False, "FSM options defined in YAML"),
        "input_type": c_clob(False, "FSM input type defined in YAML"),
        "output_type": c_clob(False, "FSM output type defined in YAML"),
        "created": c_timestamp(NN_TrueExceptMysql, "the created timestamp for the Finite State Machine"),
        "modified": c_timestamp("the modified timestamp for the Finite State Machine"),
    },
    "indexes": {
        "driver": {
            "oracle": {
                "pk_fsm": {
                    "columns": ("name"),
                    "unique": True,
                },
            },
        },
    },
    "primary_key": {
        "name": "pk_fsm",
        "columns": ("name"),
    },
    "driver": {
        "pgsql": get_pgsql_trigger_func("fsm"),
    },
    "triggers": {
        "driver": {
            "oracle": get_oracle_trigger("fsm"),
            "pgsql": get_pgsql_trigger("fsm"),
            "mysql": get_mysql_triggers("fsm"),
        },
    },
};

const T_FSMLib = {
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": {
        "fsm": c_varchar(160, True),
        "type": c_varchar(20, True),
        "name": c_varchar(160, True),
        "load_order": c_number(4, True) + {"default_value": 1},
    },
    "indexes": {
        "driver": {
            "oracle": {
                "pk_fsm_lib": {"columns": ("fsm", "type", "name"), "unique": True}
            },
            "mysql": {
                "fk_fsm_lib_type": {"columns": "type"},
            },
        },
        "sk_fsm_lib_type": {"columns": ("fsm", "type")},
        "sk_fsm_lib_fsm": {"columns": ("fsm")},
    },
    "primary_key": {"name": "pk_fsm_lib", "columns": ("fsm", "type", "name")},
    "foreign_constraints": {
        "fk_fsm_lib_type": {"columns": "type", "table": "library_type", "target_columns": ("name")},
        "fk_fsm_lib_fsm": {"columns": "fsm", "table": "fsm", "target_columns": ("name")},
    },
};

const T_FsmConfigItems = {
    "arch" : Arch::TEMPLATE_META_UPSERT,
    "columns": {
        "fsm": c_varchar(160, True, "the name of the Finite State Machine object"),
        "name": c_varchar(240, True, "the configuration item name with prefix"),
        "prefix": c_varchar(240, False, "the configuration item prefix"),
        "type": c_varchar(240, True, "the configuration item type"),
        "default_value": c_varchar(4000, False, "the configuration item default value as a serialized string"),
        "strictly_local": c_number(1, True, "allow this config item to be overridden at the next level") +
            {"default_value": 1},
        "description": c_varchar(4000, "the description of the configuration item"),
        "config_group": c_varchar(240, True, "the group of the configuration item") + {"default_value": "Default"},
        "allowed_values": c_varchar(4000, False, "the list of allowed values of the configuration item"),
        "sensitive": c_number(1, True, "sensitive field flag") + {"default_value": 0},

        "created": c_timestamp(NN_TrueExceptMysql),
        "modified": c_timestamp(),
    },
    "indexes": {
        "driver": {
            "oracle": {
                "pk_fsm_config_items": {
                    "columns": ("fsm", "name"),
                    "unique": True,
                },
            },
        },
    },
    "foreign_constraints": {
        "fk_fsm_ci_fsm": {
            "columns": "fsm",
            "table": "fsm",
            "target_columns": "name",
        },
    },
    "primary_key": {
        "name": "pk_fsm_config_items",
        "columns": ("fsm", "name"),
    },
    "driver": {
        "pgsql": get_pgsql_trigger_func("fsm_config_items"),
    },
    "triggers": {
        "driver": {
            "oracle": get_oracle_trigger("fsm_config_items"),
            "pgsql": get_pgsql_trigger("fsm_config_items"),
            "mysql": get_mysql_triggers("fsm_config_items"),
        },
    },
};

# tables
const Tables = (
    "cluster_processes": T_ClusterProcesses,
    "system_properties": T_SystemProperties,
    "session_status": T_SessionStatus,
    "sessions": T_Sessions,
    "value_maps" : T_ValueMaps,
    "value_map_values" : T_ValueMapValues,
    "function_type": T_FunctionType,
    "function_instance": T_FunctionInstance,
    "function_instance_tags": T_FunctionInstanceTags,
    "classes": T_Classes,
    "class_dependencies": T_ClassDependencies,
    "class_tags": T_ClassTags,
    "constants": T_Constants,
    "constant_tags": T_ConstantTags,
    "custom_statuses": T_CustomStatuses,
    "library_type": T_LibraryType,
    "sla": T_Sla,
    "sla_events": T_SlaEvents,
    "config_item_values": T_ConfigItemValues,
    "service_type": T_ServiceType,
    "loggers": T_Loggers,
    "services": T_Services,
    "service_tags": T_ServiceTags,
    "service_methods": T_ServiceMethods,
    "service_method_tags": T_ServiceMethodTags,
    "service_file_resource_types": T_ServiceFileResourceTypes,
    "service_file_resources": T_ServiceFileResources,
    "service_state_data": T_ServiceStateData,
    "service_config_items": T_ServiceConfigItems,
    "service_options": T_ServiceOptions,
    "queues": T_Queues,
    "queue_tags": T_QueueTags,
    "workflow_event_types": T_WorkflowEventTypes,
    "workflow_event_types_tags": T_WorkflowEventTypesTags,
    "step_type": T_StepType,
    "step_arraytype": T_StepArrayType,
    "steps": T_Steps,
    "step_status": T_StepStatus,
    "step_tags": T_StepTags,
    "step_config_items": T_StepConfigItems,
    "workflows": T_Workflows,
    "workflow_tags": T_WorkflowTags,
    "workflow_status": T_WorkflowStatus,
    "global_workflow_errors": T_GlobalWorkflowErrors,
    "workflow_errors": T_WorkflowErrors,
    "workflow_instance": T_WorkflowInstance,
    "order_instance": T_OrderInstance,
    "workflow_feedback": T_WorkflowFeedback,
    "workflow_keys": T_WorkflowKeys,
    "order_instance_keys": T_OrderInstanceKeys,
    "workflow_options": T_WorkflowOptions,
    "workflow_steps": T_WorkflowSteps,
    "step_instance": T_StepInstance,
    "step_instance_data": T_StepInstanceData,
    "subworkflow_instance": T_SubworkflowInstance,
    "workflow_events": T_WorkflowEvents,
    "step_instance_events": T_StepInstanceEvents,
    "error_severity": T_ErrorSeverity,
    "error_instance": T_ErrorInstance,
    "queue_data_status": T_QueueDataStatus,
    "queue_data": T_QueueData,
    "segment_dependencies": T_SegmentDependencies,
    "segment_steps": T_SegmentSteps,
    "segment_instance": T_SegmentInstance,
    "segment_async_link": T_SegmentAsyncLink,
    "jobs": T_Jobs,
    "job_tags": T_JobTags,
    "job_state_data": T_JobStateData,
    "job_persistent_state_data": T_JobPersistentStateData,
    "job_config_items": T_JobConfigItems,
    "job_options": T_JobOptions,
    "workflow_lib": T_WorkflowLib,
    "service_lib": T_ServiceLib,
    "job_lib": T_JobLib,
    "step_lib": T_StepLib,
    "mappers": T_Mappers,
    "workflow_mappers": T_WorkflowMappers,
    "step_mappers": T_StepMappers,
    "service_mappers": T_ServiceMappers,
    "job_mappers": T_JobMappers,
    "workflow_vmaps": T_WorkflowVMaps,
    "step_vmaps": T_StepVMaps,
    "service_vmaps": T_ServiceVMaps,
    "job_vmaps": T_JobVMaps,
    "mapper_tags": T_MapperTags,
    "mapper_lib": T_MapperLib,
    "job_status": T_JobStatus,
    "job_instance": T_JobInstance,
    "job_errors": T_JobErrors,
    "audit_event_codes": T_AuditEventCodes,
    "audit_events": T_AuditEvents,
    "pipelines": T_Pipelines,
    "pipeline_lib": T_PipelineLib,
    "pipeline_config_items": T_PipelineConfigItems,
    "fsm": T_FSM,
    "fsm_lib": T_FSMLib,
    "fsm_config_items": T_FsmConfigItems,
    "groups": T_Groups,
    "group_workflows": T_GroupWorkflows,
    "group_services": T_GroupServices,
    "group_jobs": T_GroupJobs,
    "group_mappers": T_GroupMappers,
    "group_vmaps": T_GroupVMaps,
    "group_fsms": T_GroupFsms,
    "group_pipelines": T_GroupPipelines,
    "connection_types": T_ConnectionTypes,
    "connections": T_Connections,
    "connection_tags": T_ConnectionTags,
    "order_instance_notes" : T_OrderInstanceNotes,
    "sensitive_order_data" : T_SensitiveOrderData,
    "sensitive_order_data_keys" : T_SensitiveOrderDataKeys,
    "releases": T_Releases,
    "release_files": T_ReleaseFiles,
    "release_file_contents": T_ReleaseFileContents,
    "arch_wf_instances" : T_ArchWfInstances,
    "arch_job_instances" : T_ArchJobInstances,
    "service_auth_labels" : T_ServiceAuthLabels,
    "workflow_instance_stats" : T_WorkflowInstanceStats,
    "workflow_instance_stats_stage" : T_WorkflowInstanceStatsStage,
    "job_instance_stats" : T_JobInstanceStats,
    "job_instance_stats_stage" : T_JobInstanceStatsStage,
    "data_types": T_DataTypes,

    "driver": (
        "mysql": (
            "omq_sequences": T_OmqSequences,
        ),
    ),
);

const ORACLE_PKG_Types = (
    "src": "types as

type cursorType is ref cursor;

-- wf, steps, segments statuses
-- WARNING: keep these constants synchronized with qorus.ql consts!
OMQSQLSTATCOMPLETE     constant workflow_status.workflowstatus%type := 'C';
OMQSQLSTATERROR        constant workflow_status.workflowstatus%type := 'E';
OMQSQLSTATWAITING      constant workflow_status.workflowstatus%type := 'W';
OMQSQLSTATINPROGRESS   constant workflow_status.workflowstatus%type := 'I';
OMQSQLSTATINCOMPLETE   constant workflow_status.workflowstatus%type := 'N';
OMQSQLSTATASYNCWAITING constant workflow_status.workflowstatus%type := 'A';
OMQSQLSTATRETRY        constant workflow_status.workflowstatus%type := 'R';
OMQSQLSTATCANCELED     constant workflow_status.workflowstatus%type := 'X';
OMQSQLSTATREADY        constant workflow_status.workflowstatus%type := 'Y';
OMQSQLSTATBLOCKED      constant workflow_status.workflowstatus%type := 'B';
OMQSQLSTATEVENTWAITING constant workflow_status.workflowstatus%type := 'V';
OMQSQLSTATSCHEDULED    constant workflow_status.workflowstatus%type := 'S';

-- queue statuses
-- WARNING: keep these constants synchronized with qorus.ql consts!
QSWAITING   constant queue_data.queue_data_status%type := 'W';
QSRECEIVED  constant queue_data.queue_data_status%type := 'R';
QSERROR     constant queue_data.queue_data_status%type := 'E';
QSUSED      constant queue_data.queue_data_status%type := 'X';

OMQSESSIONACTIVE    constant sessions.sessionstatus%type := 'ACTIVE';
OMQSESSIONRECOVERED constant sessions.sessionstatus%type := 'RECOVERED';
OMQSESSIONCOMPLETE  constant sessions.sessionstatus%type := 'COMPLETE';

end;",
);

const ORACLE_PKG_QorusAudit = (
    "src": "qorus_audit
is

-- Internal DBA-friendly auditing
procedure set_audit (
    in_module in varchar2 default NULL,
    in_action in varchar2 default NULL
);

procedure set_client_info;


end qorus_audit;",
    "body": "qorus_audit
is

-- Internal DBA-friendly auditing
procedure set_audit (
    in_module in varchar2 default NULL,
    in_action in varchar2 default NULL
)
is
begin
    --
    -- execute immediate is used here because it's not sure
    -- the package is available/granted so all exceptions are ignored here
    execute immediate 'begin dbms_application_info.set_module(:module, :action); end;'
        using in_module, in_action;
    --
exception when others then
    -- It's a valid exception catch. It is not allowed to fail in auditing at all!
    null;
end set_audit;


procedure set_client_info
is
    info varchar2(16) := 'Qorus System API';
begin
    --
    -- execute immediate is used here because it's not sure
    -- the package is available/granted so all exceptions are ignored here
    execute immediate 'begin dbms_application_info.set_client_info(:info); end;'
        using info;
    --
exception when others then
    -- It's a valid exception catch. It is not allowed to fail in auditing at all!
    null;
end set_client_info;


end qorus_audit;",
);

const ORACLE_PKG_QorusApi = (
    "src": "qorus_api as

procedure cache_workflow_data (
    in_workflow_instanceid in order_instance_keys.workflow_instanceid%type,
    resultset out sys_refcursor,
    feedback out sys_refcursor,
    sensitive_data out sys_refcursor,
    sensitive_data_keys out sys_refcursor,
    step_data out sys_refcursor
);

procedure sm_set_error_intern (
    in_workflow_instanceid in workflow_instance.workflow_instanceid%type,
    in_qsid in workflow_instance.status_sessionid%type,
    in_operator_lock in workflow_instance.operator_lock%type,
    --
    out_status_sessionid out workflow_instance.status_sessionid%type,
    out_workflowstatus out varchar2, --workflow_instance.workflowstatus%type,
    out_parent_workflow_instanceid out workflow_instance.parent_workflow_instanceid%type,
    out_subworkflow out workflow_instance.subworkflow%type,
    out_priority out workflow_instance.priority%type,
    out_operator_lock out varchar2, --workflow_instance.operator_lock
    --
    out_stepcount out number,
    out_segcount out number,
    --
    out_err out varchar2
);

procedure sm_skip_step_sql (
    in_workflow_instanceid in workflow_instance.workflow_instanceid%type,
    in_qsid in workflow_instance.status_sessionid%type,
    in_stepid in step_instance.stepid%type,
    in_ind in step_instance.ind%type,
    in_operator_lock in workflow_instance.operator_lock%type,
    --
    out_err out varchar2,
    out_operator_lock out varchar2, --workflow_instance.operator_lock
    -- only for logging
    out_wfstat out varchar2, --workflow_instance.workflowstatus%type,
    out_statsid out workflow_instance.status_sessionid%type,
    out_stepstat out varchar2 --step_instance.stepstatus%type
);

procedure sm_get_wf_instance_status_sql (
    in_workflow_instanceid in workflow_instance.workflow_instanceid%type,
    out_status out number,
    wq out sys_refcursor,
    seg out sys_refcursor
);

procedure sm_queue_events_intern (
    in_workflow_instanceid in segment_instance.workflow_instanceid%type,
    out_segmentids out sys_refcursor,
    out_subworkflows out sys_refcursor,
    out_asyncs out sys_refcursor,
    out_retries out sys_refcursor,
    out_sync out sys_refcursor
);

procedure update_final_job_inst_status (
    in_jid in number,
    in_jiid in number,
    in_stat in varchar2,
    in_last_executed in date
);

end qorus_api;",
    "body": "qorus_api as

procedure cache_workflow_data (
    in_workflow_instanceid in order_instance_keys.workflow_instanceid%type,
    resultset out sys_refcursor,
    feedback out sys_refcursor,
    sensitive_data out sys_refcursor,
    sensitive_data_keys out sys_refcursor,
    step_data out sys_refcursor
)
is
begin
    --
    qorus_audit.set_audit('qorus_api', 'cache_workflow_data');
    --
    open resultset for
        select workflowid, workflowstatus, status_sessionid,
               parent_workflow_instanceid, subworkflow, external_order_instanceid,
               staticdata, dynamicdata, business_error,
               wi.workflowstatus_orig, wi.custom_status,
               operator_lock, scheduled, priority, started, errors, retries
            from workflow_instance wi, order_instance oi
            where wi.workflow_instanceid = oi.workflow_instanceid
                and wi.workflow_instanceid = in_workflow_instanceid;
    open feedback for
        select keyname, info
            from workflow_feedback
            where workflow_instanceid = in_workflow_instanceid;
    open sensitive_data for
        select skey, svalue, data, iv, mac, meta, miv, mmac
            from sensitive_order_data
            where workflow_instanceid = in_workflow_instanceid;
    open sensitive_data_keys for
        select alias, skey, svalue
            from sensitive_order_data_keys
            where workflow_instanceid = in_workflow_instanceid;
    open step_data for
        select stepid, ind, data
            from step_instance_data
            where workflow_instanceid = in_workflow_instanceid;
    --
    qorus_audit.set_audit();
    --
end cache_workflow_data;

procedure sm_set_error_intern (
    in_workflow_instanceid in workflow_instance.workflow_instanceid%type,
    in_qsid in workflow_instance.status_sessionid%type,
    in_operator_lock in workflow_instance.operator_lock%type,
    --
    out_status_sessionid out workflow_instance.status_sessionid%type,
    out_workflowstatus out varchar2, --workflow_instance.workflowstatus%type,
    out_parent_workflow_instanceid out workflow_instance.parent_workflow_instanceid%type,
    out_subworkflow out workflow_instance.subworkflow%type,
    out_priority out workflow_instance.priority%type,
    out_operator_lock out varchar2, --workflow_instance.operator_lock
    --
    out_stepcount out number,
    out_segcount out number,
    --
    out_err out varchar2
)
is
    tmp_stat workflow_instance.status_sessionid%type;
begin
    --
    qorus_audit.set_audit('qorus_api', 'sm_set_error_intern');
    --
    -- # try to lock workflow
    select status_sessionid, workflowstatus, parent_workflow_instanceid, subworkflow,
           operator_lock, priority
        into out_status_sessionid, out_workflowstatus, out_parent_workflow_instanceid, out_subworkflow,
             out_operator_lock, out_priority
        from workflow_instance
        where workflow_instanceid = in_workflow_instanceid
        for update;

    if out_operator_lock is not null and out_operator_lock != in_operator_lock then
        out_err := 'OPERATOR-LOCK-ERROR';
        --
        qorus_audit.set_audit();
        --
        return;
    end if;

    if out_status_sessionid != 0 and out_status_sessionid != in_qsid then
                out_err := 'WORKFLOW-SESSION-ERROR';
        --
        qorus_audit.set_audit();
        --
        return;
    end if;

    if out_workflowstatus not in (types.OMQSQLSTATRETRY, types.OMQSQLSTATCANCELED,
                                  types.OMQSQLSTATASYNCWAITING, types.OMQSQLSTATERROR,
                                  types.OMQSQLSTATBLOCKED)
    then
                out_err := 'WORKFLOW-STATUS-ERROR';
        --
        qorus_audit.set_audit();
        --
        return;
    end if;
    --
    qorus_audit.set_audit('qorus_api', 'sm_set_error_intern 1');
    --
    --# update all steps
    update step_instance
        set stepstatus = types.OMQSQLSTATERROR,
            custom_status = NULL
        where workflow_instanceid = in_workflow_instanceid
            and stepstatus = types.OMQSQLSTATRETRY;
    out_stepcount := sql%rowcount;
    --
    qorus_audit.set_audit('qorus_api', 'sm_set_error_intern 2');
    --
    --# update all segments
    update segment_instance
        set segmentstatus = types.OMQSQLSTATERROR,
            custom_status = NULL
        where workflow_instanceid = in_workflow_instanceid
            and segmentstatus in (types.OMQSQLSTATRETRY, types.OMQSQLSTATCANCELED);
    out_segcount := sql%rowcount;
    --
    --# update workflow status
    if out_workflowstatus = types.OMQSQLSTATCANCELED then
        tmp_stat := in_qsid;
    else
        tmp_stat := 0;
    end if;
    --
    qorus_audit.set_audit('qorus_api', 'sm_set_error_intern 3');
    --
    update workflow_instance
        set workflowstatus = types.OMQSQLSTATERROR,
            status_sessionid = tmp_stat,
            custom_status = NULL
        where workflow_instanceid = in_workflow_instanceid;
    --
    qorus_audit.set_audit();
    --
exception when no_data_found then
    out_err := 'WORKFLOW-ERROR';
    --
    qorus_audit.set_audit();
    --
end sm_set_error_intern;

procedure sm_skip_step_sql (
    in_workflow_instanceid in workflow_instance.workflow_instanceid%type,
    in_qsid in workflow_instance.status_sessionid%type,
    in_stepid in step_instance.stepid%type,
    in_ind in step_instance.ind%type,
    in_operator_lock in workflow_instance.operator_lock%type,
    --
    out_err out varchar2,
    out_operator_lock out varchar2, --workflow_instance.operator_lock
    -- only for logging
    out_wfstat out varchar2, --workflow_instance.workflowstatus%type,
    out_statsid out workflow_instance.status_sessionid%type,
    out_stepstat out varchar2 --step_instance.stepstatus%type
)
is
    tmp_wfi_row workflow_instance%rowtype;
    tmp_si_row step_instance%rowtype;
begin
    --
    qorus_audit.set_audit('qorus_api', 'sm_skip_step_sql');
    --
    --# try to lock flow
    begin
        select * into tmp_wfi_row
            from workflow_instance
            where workflow_instanceid = in_workflow_instanceid
            for update;
    exception when no_data_found then
        out_err := 'SKIP-STEP-ERROR-WF';
        --
        qorus_audit.set_audit();
        --
        return;
    end;

    if tmp_wfi_row.operator_lock is not null and tmp_wfi_row.operator_lock != in_operator_lock then
        out_err := 'OPERATOR-LOCK-ERROR';
        out_operator_lock := tmp_wfi_row.operator_lock;
        --
        qorus_audit.set_audit();
        --
        return;
    end if;

    if tmp_wfi_row.workflowstatus in (types.OMQSQLSTATINPROGRESS, types.OMQSQLSTATCANCELED) then
        out_err := 'WORKFLOW-IN-PROGRESS';
        out_wfstat := tmp_wfi_row.workflowstatus;
        --
        qorus_audit.set_audit();
        --
        return;
    end if;

    if tmp_wfi_row.status_sessionid != 0
            and tmp_wfi_row.status_sessionid != in_qsid
    then
                out_err := 'SESSION-ERROR';
        out_statsid := tmp_wfi_row.status_sessionid;
        --
        qorus_audit.set_audit();
        --
        return;
    end if;
    --
    qorus_audit.set_audit('qorus_api', 'sm_skip_step_sql 1');
    --
    --# get step info
    begin
        select * into tmp_si_row
            from step_instance
            where workflow_instanceid = in_workflow_instanceid
                and stepid = in_stepid
                and ind = in_ind
            for update;
    exception when no_data_found then
        out_err := 'SKIP-STEP-ERROR';
        --
        qorus_audit.set_audit();
        --
        return;
    end;

    if tmp_si_row.stepstatus not in (types.OMQSQLSTATRETRY, types.OMQSQLSTATERROR,
                                     types.OMQSQLSTATASYNCWAITING) then
        out_err := 'STEP-STATUS-ERROR';
        out_stepstat := tmp_si_row.stepstatus;
        --
        qorus_audit.set_audit();
        --
        return;
    end if;
    --
    qorus_audit.set_audit('qorus_api', 'sm_skip_step_sql 2');
    --
    update step_instance
        set skip = 1
        where workflow_instanceid = in_workflow_instanceid
            and stepid = in_stepid
            and ind = in_ind;
    --
    qorus_audit.set_audit();
    --
end sm_skip_step_sql;

procedure sm_get_wf_instance_status_sql (
    in_workflow_instanceid in workflow_instance.workflow_instanceid%type,
    out_status out number,
    wq out sys_refcursor,
    seg out sys_refcursor
)
is
begin
    --
    qorus_audit.set_audit('qorus_api', 'sm_get_wf_instance_status_sql');
    --
    -- 0 = all statements are done; 1 = only the 1st one
        out_status := 0;
    -- # get workflow and workflow_instance information
    open wq for
        select
            name, version, author,
            workflowstatus, w.workflowid,
            status_sessionid, parent_workflow_instanceid,
            started, completed,
            warnings as \"warning_count\", errors as \"error_count\",
            wi.modified, business_error,
            wi.custom_status, wi.scheduled,
            priority, operator_lock, note_count
        from
            workflow_instance wi, workflows w
        where
                w.workflowid = wi.workflowid
            and wi.workflow_instanceid = in_workflow_instanceid;
    --
    qorus_audit.set_audit('qorus_api', 'sm_get_wf_instance_status_sql 1');
    --
    -- # get segment information
    -- TODO/FIXME: the original select took wfiid from wq cursor. It's duplicity, isn't it?
    open seg for
        select si.segmentid, si.segmentstatus,
               si.created, si.modified,
               si.custom_status
            from segment_instance si
            where workflow_instanceid = in_workflow_instanceid
            order by segmentid;
    --
    qorus_audit.set_audit();
    --
end sm_get_wf_instance_status_sql;

procedure sm_queue_events_intern (
    in_workflow_instanceid in segment_instance.workflow_instanceid%type,
    out_segmentids out sys_refcursor,
    out_subworkflows out sys_refcursor,
    out_asyncs out sys_refcursor,
    out_retries out sys_refcursor,
    out_sync out sys_refcursor
)
is
begin
    --
    qorus_audit.set_audit('qorus_api', 'sm_queue_events_intern');
    --
    open out_segmentids for
        select segmentid
            from segment_instance
            where workflow_instanceid = in_workflow_instanceid
            and segmentstatus = types.OMQSQLSTATREADY;
    --
    qorus_audit.set_audit('qorus_api', 'sm_queue_events_intern 1');
    --
    open out_subworkflows for
        select swi.workflow_instanceid as \"subworkflow_instanceid\",
               si.stepid, si.ind, swi.workflowstatus as \"status\",
               corrected
            from
                step_instance si, subworkflow_instance sswi,
                workflow_instance swi
            where
                    si.workflow_instanceid = in_workflow_instanceid
                and si.stepstatus != types.OMQSQLSTATCOMPLETE
                and si.workflow_instanceid = sswi.workflow_instanceid
                and si.stepid = sswi.stepid and si.ind = sswi.ind
                and sswi.subworkflow_instanceid = swi.workflow_instanceid
                and ((corrected is null
                        and swi.workflowstatus in (types.OMQSQLSTATCOMPLETE, types.OMQSQLSTATERROR)
                        and stepstatus != swi.workflowstatus)
                     or corrected = 1);
    --
    qorus_audit.set_audit('qorus_api', 'sm_queue_events_intern 2');
    --
    open out_asyncs for
        select queuekey, stepid, ind, corrected
            from queue_data
            where workflow_instanceid = in_workflow_instanceid
                and queue_data_status = types.OMQSQLSTATRETRY;
    --
    qorus_audit.set_audit('qorus_api', 'sm_queue_events_intern 3');
    --
    open out_retries for
        select segmentid, modified, segmentstatus, retry_trigger
            from segment_instance
            where workflow_instanceid = in_workflow_instanceid
                and segmentstatus in (types.OMQSQLSTATASYNCWAITING, types.OMQSQLSTATRETRY)
            order by modified;
    --
    qorus_audit.set_audit('qorus_api', 'sm_queue_events_intern 4');
    --
    open out_sync for
         select si.stepid, si.ind, si.skip as \"corrected\"
             from step_instance si, step_instance_events sie, workflow_events we
             where si.workflow_instanceid = in_workflow_instanceid
                 and si.stepstatus != 'C'
                 and si.workflow_instanceid = sie.workflow_instanceid
                 and si.stepid = sie.stepid
                 and si.ind = sie.ind
                   --
                 and sie.workflow_event_typeid = we.workflow_event_typeid
                 and sie.eventkey = we.eventkey
                 and (we.event_posted = 1 or si.skip = 1)
             order by sie.modified;
    --
    qorus_audit.set_audit();
    --
end sm_queue_events_intern;

procedure update_final_job_inst_status (
    in_jid in number,
    in_jiid in number,
    in_stat in varchar2,
    in_last_executed in date
)
is
    tmp_sessionid number(1) := 0;
begin
    --
    qorus_audit.set_audit('qorus_api', 'update_final_job_inst_status');
    --
    update job_instance set jobstatus = in_stat, sessionid = tmp_sessionid where job_instanceid = in_jiid;
    update jobs set last_executed = in_last_executed, last_executed_job_instanceid = in_jiid  where jobid = in_jid;
    --
    qorus_audit.set_audit();
    --
end update_final_job_inst_status;

end qorus_api;",
);

const ORACLE_PKG_QorusSystemInfo = (
    "src": "qorus_system_info
is

procedure process_workflow_metadata (
    in_workflowid in number,
    keyname out sys_refcursor,
    steps out sys_refcursor,
    steps_deps out sys_refcursor,
    seg_deps out sys_refcursor,
    seg_steps out sys_refcursor,
    options out sys_refcursor,
    groups out sys_refcursor
);

procedure get_service_metadata (
    in_serviceid_list in sys.odcinumberlist,
    resultset out sys_refcursor
);

procedure get_service_metadata_name (
    in_service_type in services.service_type%type,
    in_name in services.name%type,
    in_version in services.version%type,
    resultset out sys_refcursor
);

end qorus_system_info;",

    "body": "qorus_system_info
is

procedure process_workflow_metadata (
    in_workflowid in number,
    keyname out sys_refcursor,
    steps out sys_refcursor,
    steps_deps out sys_refcursor,
    seg_deps out sys_refcursor,
    seg_steps out sys_refcursor,
    options out sys_refcursor,
    groups out sys_refcursor
)
is
begin
    --
    qorus_audit.set_audit('qorus_system_info', 'process_workflow_metadata');
    --
    open keyname for
        select keyname
            from workflow_keys
            where workflowid = in_workflowid;
    --
    qorus_audit.set_audit('qorus_system_info', 'process_workflow_metadata 1');
    --
    open steps for
        -- original:
        --select * from steps where stepid in (select stepid from workflow_steps where workflowid = in_workflowid);
        select s.*
            from steps s
            where exists (select 1
                              from workflow_steps w
                              where w.workflowid = in_workflowid
                                 and s.stepid = w.stepid
                         );
    --
    qorus_audit.set_audit('qorus_system_info', 'process_workflow_metadata 2');
    --
    open steps_deps for
        select *
            from workflow_steps
            where workflowid = in_workflowid;
    --
    qorus_audit.set_audit('qorus_system_info', 'process_workflow_metadata 3');
    --
    open seg_deps for
        select *
            from segment_dependencies
            where workflowid = in_workflowid;
    --
    qorus_audit.set_audit('qorus_system_info', 'process_workflow_metadata 4');
    --
    open seg_steps for
        select *
            from segment_steps where workflowid = in_workflowid;
    --
    qorus_audit.set_audit('qorus_system_info', 'process_workflow_metadata 5');
    --
    open options for
        select *
            from workflow_options
            where workflowid = in_workflowid;
    --
    qorus_audit.set_audit('qorus_system_info', 'process_workflow_metadata 6');
    --
    open groups for
        select name
             from group_workflows gw, groups g
             where workflowid = in_workflowid and gw.groupid = g.groupid;
    --
    qorus_audit.set_audit();
    --
end process_workflow_metadata;

--private
procedure cout (
    in_string in varchar2,
    p_line_width number default 100)
is
    out_string_in long default in_string;
    str_len number;
    loop_count number default 0;
begin
-- does our output already contain a linebreak? output up to the first linebreak
-- if so, then output the rest as well (will recursive work through all chr(10) instances).
    if instr(in_string, chr(10), 1, 1) > 0 then
        cout ( substr(in_string, 1, instr(in_string, chr(10), 1, 1)-1), p_line_width);
        cout ( substr(in_string, instr(in_string, chr(10), 1, 1)+1), p_line_width);
    else
        str_len := length(out_string_in);
        while loop_count < str_len loop
            dbms_output.put_line( substr( out_string_in, loop_count +1, p_line_width ) );
            loop_count := loop_count + p_line_width;
        end loop;
    end if;
end cout;

procedure get_service_metadata (
    in_serviceid_list in sys.odcinumberlist,
    resultset out sys_refcursor
)
is
begin
    --
    if in_serviceid_list is null then
        --
        qorus_audit.set_audit('qorus_system_info', 'get_service_metadata 1');
        --
        open resultset for
            select *
                from services
                where (name, created) in (
                            select name, max(created) as created
                                from services group by name
                            );
    else
        --
        qorus_audit.set_audit('qorus_system_info', 'get_service_metadata 2');
        --
        open resultset for
            select *
                from services
                where serviceid in (
                            select column_value
                                from table(in_serviceid_list)
                          );
    end if;
    --
    qorus_audit.set_audit();
    --
end get_service_metadata;

procedure get_service_metadata_name (
    in_service_type in services.service_type%type,
    in_name in services.name%type,
    in_version in services.version%type,
    resultset out sys_refcursor
)
is
begin
    --
    if in_version is null then
        --
        qorus_audit.set_audit('qorus_system_info', 'get_service_metadata_name 1');
        --
        open resultset for
            select *
                from services
                    where service_type = in_service_type
                        and (name, created) in (
                                select name, max(created) as created
                                    from services
                                    where name = in_name
                                    group by name);
    else
        --
        qorus_audit.set_audit('qorus_system_info', 'get_service_metadata_name 2');
        --
        open resultset for
            select *
                from services
                where serviceid in (
                            select serviceid
                                from services
                                where service_type = in_service_type
                                    and name = in_name
                                    and version = in_version);
    end if;
    --
    qorus_audit.set_audit();
    --
end get_service_metadata_name;

end qorus_system_info;",
);

const ORACLE_Packages = (
    "types": ORACLE_PKG_Types,
    "qorus_audit": ORACLE_PKG_QorusAudit,
    "qorus_api": ORACLE_PKG_QorusApi,
    "qorus_system_info": ORACLE_PKG_QorusSystemInfo,
);

const MYSQL_Functions = (
    "my_nextval": "my_nextval(seq_name varchar(40)) returns decimal(14)
begin
  update omq_sequences set id = last_insert_id(id + 1) where name = seq_name;
  return last_insert_id();
end",
);

const Schema = (
    "sequences": Sequences,
    "tables": Tables,
    "driver": (
        "oracle": (
            "packages": ORACLE_Packages,
        ),
        "mysql": (
            "functions": MYSQL_Functions,
        ),
    ),
);

const SchemaOpts = (
    "driver": (
        "mysql": (
            "sequence_table": "omq_sequences",
            "sequence_function": "my_nextval",
        ),
    ),
);

const SRD_SessionStatus = (
    ("sessionstatus", "description"),
    ("ACTIVE", "The session is current active"),
    ("COMPLETE", "The session terminated normally"),
    ("ABNORMAL TERMINATION", "The session terminated abnormally and has not been recoved"),
    ("RECOVERED", "The session terminated abnormally and was recoved"),
);

const SRD_StepType = (
    ("steptype", "description"),
    ("NORMAL", "Normal steps"),
    ("ASYNC", "Asynchronously pipelined steps"),
    ("SUBWORKFLOW", "steps that execute child workflows"),
    ("EVENT", "steps that wait on a common event"),
);

const SRD_StepArrayType = (
    ("arraytype", "description"),
    ("NONE", "single execution"),
    ("SERIES", "array step executed in series"),
    ("PARALLEL", "array step executed in parallel"),
);

const SRD_FunctionType = (
    ("name", "description"),
    ("STEP", "Qorus Step Code"),
    ("GENERIC", "Generic User Code"),
    ("ASYNC-START", "asynchronous step start code"),
    ("ASYNC-END", "asynchronous step end code"),
    ("VALIDATION", "step validation code"),
    ("ARRAY", "returns array for array steps"),
    ("SUBWORKFLOW", "step starts a subworkflow bound to the step"),
);

const SRD_WorkflowStatus = (
    ("workflowstatus", "description"),
    ("I", "IN-PROGRESS"),
    ("C", "COMPLETE"),
    ("E", "ERROR"),
    ("A", "ASYNC-WAITING"),
    ("W", "WAITING"),
    ("V", "EVENT-WAITING"),
    ("N", "INCOMPLETE"),
    ("X", "CANCELED"),
    ("R", "RETRY"),
    ("Y", "READY"),
    ("B", "BLOCKED"),
    ("S", "SCHEDULED"),
);

const SRD_StepStatus = (
    ("stepstatus", "description"),
    ("I", "IN-PROGRESS"),
    ("C", "COMPLETE"),
    ("E", "ERROR"),
    ("A", "ASYNC-WAITING"),
    ("W", "WAITING"),
    ("R", "RETRY"),
    ("V", "EVENT-WAITING"),
);

const SRD_JobStatus = (
    ("jobstatus", "description"),
    ("I", "IN-PROGRESS"),
    ("E", "ERROR"),
    ("C", "COMPLETE"),
    ("Z", "CRASH"),
);

const SRD_ServiceType = (
    ("service_type", "description"),
    ("SYSTEM", "OMQ System Service"),
    ("USER", "OMQ User Service"),
);

const SRD_ErrorSeverity = (
    ("severity", "description"),
    ("INFO", "informational message, does not necessarily indicate an error"),
    ("WARNING", "the error does not affect the workflow logic but should be logged"),
    ("MINOR", "the error has some affect on the workflow logic but the workflow can continue"),
    ("MAJOR", "the workflow instance will receive an error status"),
    ("FATAL", "the workflow will be stopped"),
    ("SYSTEM-FATAL", "all executing workflows of this workflow will be stopped"),
    ("ABORT", "the Qorus system will be terminated immediately"),
    ("UNKNOWN", "unknown severity"),
);

const SRD_QueueDataStatus = (
    ("queue_data_status", "description"),
    ("W", "WAITING: data has been submitted and is awaiting a response"),
    ("R", "RECEIVED: response has been received and is awaiting processing"),
    ("E", "ERROR: the queue data cannot be parsed"),
    ("X", "USED: the queue data has already been processed"),
);

const SRD_LibraryType = (
    ("name", "description"),
    ("CONSTANT", "shared constant definitions"),
    ("CLASS", "shared class definitions"),
    ("FUNCTION", "shared function definitions"),
    ("PIPELINE", "shared pipeline definitions"),
    ("FSM", "shared FSM definitions"),
    ("MAPPER", "shared mapper definitions"),
);

const SRD_AuditEventCodes = (
    ("audit_event_code", "description"),
    (1, "USER-EVENT"),
    (2, "SYSTEM-STARTUP"),
    (3, "SYSTEM-SHUTDOWN"),
    (4, "SYSTEM-RECOVERY-START"),
    (5, "SYSTEM-RECOVERY-COMPLETE"),
    (6, "WORKFLOW-STATUS-CHANGE"),
    (7, "WORKFLOW-START"),
    (8, "WORKFLOW-STOP"),
    (9, "SERVICE-START"),
    (10, "SERVICE-STOP"),
    (11, "JOB-START"),
    (12, "JOB-STOP"),
    (13, "JOB-INSTANCE-START"),
    (14, "JOB-INSTANCE-STOP"),
    (15, "API-CALL"),
    (16, "JOB-RECOVERY"),
    (17, "WORKFLOW-DATA-CREATED"),
    (18, "ALERT-ONGOING-RAISED"),
    (19, "ALERT-ONGOING-CLEARED"),
    (20, "ALERT-TRANSIENT-RAISED"),
    (21, "SOURCE-FILE-LOADED"),
    (22, "GROUP-STATUS-CHANGED"),
);

const SRD_ServiceFileResourceTypes = (
    ("resource_type", "description"),
    ("N", "normal file resource"),
    ("T", "template file resource"),
    ("B", "binary file resource"),
);

const SRD_ConnectionTypes = (
    ("connection_type", "description"),
    ("USER", "an user connection, regular AbstractConnection object"),
    ("DATASOURCE", "a datasource/pool connection with additional functionality"),
    ("REMOTE", "a qorus remote connection with additional functionality"),
);

const RD_SystemProperties = (
    ("domain", "keyname", "value"),
    ("omq", "schema-version", OMQ::datamodel),
    ("omq", "schema-compatibility", OMQ::compat_datamodel),
    ("omq", "schema-load-compatibility", OMQ::load_datamodel),
);

const RD_Connections = (
    ("connectionid", "name", "description", "url", "connection_type"),
    (0, "omq", "system datasource", "db://pgsql:ignored/do_not_use@ignored", "DATASOURCE"),
);

const RD_Sessions = (
    ("sessionid", "instancekey", "sessionstatus", "hostname", "xmlrpc_server"),
    (0, "none - default session for unowned data", "COMPLETE", "none", "none"),
);

const RD_WorkflowEventTypes = (
    ("workflow_event_typeid", "name", "description"),
    (0, "OMQ-SYSTEM-DEFAULT-EVENT-TYPE", "default system event type"),
);

const RD_WorkflowEvents = (
    ("workflow_event_typeid", "eventkey", "event_posted"),
    (0, "OMQ-SYSTEM-DEFAULT-EVENT", 1),
);

const RD_Groups = (
    ("groupid", "name", "description", "enabled"),
    (0, "DEFAULT", "default group containing all workflows and services", 1),
);

const CORD_Sessions = (
    ("sessionid", "instancekey", "sessionstatus", "hostname", "xmlrpc_server", "started", "ended"),
    (0, "none - default session for unowned data", "COMPLETE", "none", "none", now_us(), now_us()),
);

const IORD_GlobalWorkflowErrors = (
    ("error", "description", "severity", "status", "business_flag"),
    # Socket technical errors
    ("SOCKET-SSL-ERROR", "An SSL error occurred while sending or receiving data on a socket", "MAJOR", 'R', 0),
    ("SOCKET-SEND-ERROR", "An I/O error occurred while sending socket data", "MAJOR", 'R', 0),
    ("SOCKET-RECV-ERROR", "An I/O error occurred while receiving socket data", "MAJOR", 'R', 0),
    ("SOCKET-TIMEOUT", "The socket transfer exceeded the timeout period", "MAJOR", 'R', 0),
    ("SOCKET-CONNECT-ERROR", "An I/O error occurred while attempting to connect to a remote socket", "MAJOR", 'R', 0),
    ("SOCKET-CLOSED", "An I/O error occurred while sending or receiving data on a socket", "MAJOR", 'R', 0),

    # HTTPClient technical errors
    ("HTTP-CLIENT-RECEIVE-ERROR", "I/O or protocol error occurred while reading HTTP data", "MAJOR", 'R', 0),
    ("SOCKET-HTTP-ERROR", "An I/O or protocol error occurred while reading HTTP data on the socket", "MAJOR", 'R', 0),

    # FtpClient technical errors
    ("FTP-RECEIVE-ERROR", "An I/O or protocol error occurred while reading FTP data", "MAJOR", 'R', 0),
    ("FTP-CONNECT-ERROR", "An error occurred connecting to the FTP server", "MAJOR", 'R', 0),
    ("FTPS-SECURE-DATA-ERROR", "An I/O or protocol error occurred on the secure FTP data channel", "MAJOR", 'R', 0),
    ("FTP-DATA-SOCKET-CLOSED", "The FTP data channel was closed prematurely", "MAJOR", 'R', 0),
    ("FTP-DATA-SOCKET-RECV-ERROR", "An I/O error occurred on the FTP data channel", "MAJOR", 'R', 0),
    ("FTP-TIMEOUT-ERROR", "the FTP transfer exceeded the timeout period", "MAJOR", 'R', 0),

    # ssh2 module technical errors
    ("SSH2-ERROR", "An error occurred communicating with the remote server", "MAJOR", 'R', 0),
    ("SFTPCLIENT-TIMEOUT", "A timeout occurred communicating with the remote server", "MAJOR", 'R', 0),
    ("SFTPCLIENT-LIST-ERROR", "An error occurred communicating with the remote server in the SFTPClient::list() method", "MAJOR", 'R', 0),
    ("SFTPCLIENT-LISTFULL-ERROR", "An error occurred communicating with the remote server in the SFTPClient::listFull() method", "MAJOR", 'R', 0),
    ("SFTPCLIENT-CHMOD-ERROR", "An error occurred communicating with the remote server in the SFTPClient::chmod() method", "MAJOR", 'R', 0),
    ("SFTPCLIENT-MKDIR-ERROR", "An error occurred communicating with the remote server in the SFTPClient::mkdir() method", "MAJOR", 'R', 0),
    ("SFTPCLIENT-RMDIR-ERROR", "An error occurred communicating with the remote server in the SFTPClient::rmdir() method", "MAJOR", 'R', 0),
    ("SFTPCLIENT-RENAME-ERROR", "An error occurred communicating with the remote server in the SFTPClient::rename() method", "MAJOR", 'R', 0),
    ("SFTPCLIENT-REMOVEFILE-ERROR", "An error occurred communicating with the remote server in the SFTPClient::removeFile() method", "MAJOR", 'R', 0),
    ("SFTPCLIENT-CONNECT-ERROR", "An error occurred communicating while connecting to the remote server", "MAJOR", 'R', 0),
    ("SFTPCLIENT-GETFILE-ERROR", "An error occurred communicating with the remote server in the SFTPClient::getFile() method", "MAJOR", 'R', 0),
    ("SFTPCLIENT-GETTEXTFILE-ERROR", "An error occurred communicating with the remote server in the SFTPClient::getTextFile() method", "MAJOR", 'R', 0),
    ("SFTPCLIENT-PUTFILE-ERROR", "An error occurred communicating with the remote server in the SFTPClient::putFile() method", "MAJOR", 'R', 0),
    ("SFTPCLIENT-STAT-ERROR", "An error occurred communicating with the remote server in the SFTPClient::stat() method", "MAJOR", 'R', 0),
    ("SSH2CLIENT-SCPGET-ERROR", "An error occurred communicating with the remote server in the SSH2Client::scpGet() method", "MAJOR", 'R', 0),
    ("SSH2CLIENT-SCPPUT-ERROR", "An error occurred communicating with the remote server in the SSH2Client::scpPut() method", "MAJOR", 'R', 0),
    ("SSH2CLIENT-TIMEOUT", "A timeout error occurred communicating with the remote server", "MAJOR", 'R', 0),
    ("REST-CONNECTION-ERROR", "An error occurred with a REST request", "MAJOR", 'R', 0),

    # java technical errors
    ("java.io.InterruptedIOException", "Signals that an I/O operation has been interrupted. An InterruptedIOException is thrown to indicate that an input or output transfer has been terminated because the thread performing it was interrupted", "MAJOR", 'R', 0),
    ("java.net.SocketTimeoutException", "Signals that a timeout has occurred on a socket read or accept", "MAJOR", 'R', 0),
    ("java.net.ConnectException", "Signals that an error occurred while attempting to connect a socket to a remote address and port. Typically, the connection was refused remotely (e.g., no process is listening on the remote address/port)", "MAJOR", 'R', 0),
    ("java.net.NoRouteToHostException", "Signals that an error occurred while attempting to connect a socket to a remote address and port. Typically, the remote host cannot be reached because of an intervening firewall, or if an intermediate router is down", "MAJOR", 'R', 0),
    ("java.net.HttpRetryException", "Thrown to indicate that a HTTP request needs to be retried but cannot be retried automatically, due to streaming mode being enabled", "MAJOR", 'R', 0),
    ("javax.imageio.IIOException", "An exception class used for signaling run-time failure of reading and writing operations", "MAJOR", 'R', 0),
    ("java.nio.channels.InterruptedByTimeoutException", "Checked exception received by a thread when a timeout elapses before an asynchronous operation completes", "MAJOR", 'R', 0),
    ("java.net.ProtocolException", "Thrown to indicate that there is an error in the underlying protocol, such as a TCP error.", "MAJOR", 'R', 0),
    ("java.rmi.ConnectException", "A ConnectException is thrown if a connection is refused to the remote host for a remote method call", "MAJOR", 'R', 0),
    ("java.rmi.ConnectIOException", "A ConnectIOException is thrown if an IOException occurs while making a connection to the remote host for a remote method call", "MAJOR", 'R', 0),
    ("java.net.SocketException", "Thrown to indicate that there is an error creating or accessing a Socket", "MAJOR", 'R', 0),
    ("javax.net.ssl.SSLException", "Indicates some kind of error detected by an SSL subsystem", "MAJOR", 'R', 0),
    ("javax.net.ssl.SSLHandshakeException", "Indicates that the client and server could not negotiate the desired level of security. The connection is no longer usable", "MAJOR", 'R', 0),
    ("javax.net.ssl.SSLProtocolException", "Reports an error in the operation of the SSL protocol", "MAJOR", 'R', 0),
    ("javax.xml.soap.SOAPException", "An exception that signals that a SOAP exception has occurred", "MAJOR", 'R', 0),

    # misc technical errors resulting in a retry
    ("TRANSACTION-LOCK-TIMEOUT", "a shared database connection could not be acquired within the timeout period", "MAJOR", 'R', 0),

    # generic technical errors - user code can throw these errors explicitly to get a retry
    ("DATASOURCE-RETRY-ERROR", "An error occurred communicating with the database", "MAJOR", 'R', 0),
    ("RETRY-ERROR", "An error occured that results in a workflow order retry; see info for details", "MAJOR", 'R', 0),

    # generic business error: non-retry
    ("BUSINESS-ERROR", "A business error was detected; see info for details", "MAJOR", 'E', 1),

    # generic business error: retry
    ("BUSINESS-RETRY-ERROR", "A business error was detected that results in a workflow order retry; see info for details", "MAJOR", 'R', 1),

    # generic warnings
    ("BUSINESS-WARNING", "A condition was detected affecting the business logic that results in a warning; see info for details", "WARNING", 'E', 1),
    ("TECHNICAL-WARNING", "A technical condition was detected that results in a warning; see info for details", "WARNING", 'E', 0),

    # generic errors
    ("RETRIES-EXCEEDED-ERROR", "the workflow order instance has exceeeded its retry limit and will be set to ERROR", "MAJOR", 'E', 0),
);

const StrictReferenceData = (
    "session_status": SRD_SessionStatus,
    "step_type": SRD_StepType,
    "step_arraytype": SRD_StepArrayType,
    "function_type": SRD_FunctionType,
    "step_status": SRD_StepStatus,
    "service_type": SRD_ServiceType,
    "error_severity": SRD_ErrorSeverity,
    "queue_data_status": SRD_QueueDataStatus,
    "library_type": SRD_LibraryType,
    "workflow_status": SRD_WorkflowStatus,
    "job_status": SRD_JobStatus,
    "audit_event_codes": SRD_AuditEventCodes,
    "service_file_resource_types": SRD_ServiceFileResourceTypes,
    "connection_types": SRD_ConnectionTypes,
);

const ReferenceData = (
    "system_properties": RD_SystemProperties,
    "connections": RD_Connections,
    "sessions": RD_Sessions,
    "workflow_event_types": RD_WorkflowEventTypes,
    "workflow_events": RD_WorkflowEvents,
    "groups": RD_Groups,
);

const CreateOnlyReferenceData = (
    "sessions": CORD_Sessions,
);

const InsertOnlyReferenceData = (
    "global_workflow_errors": IORD_GlobalWorkflowErrors,
);

# logger IDs will be generated / matched as necessary
const DefaultLoggers = (
    "workflows": {
        "params": "{level: 20000, name: \"DefaultWorkflowLogger\", additivity: false, appenders: {\"1\": "
            "{name: \"DefaultWorkflowAppender\", layoutPattern: \"%d{YYYY-MM-DD HH:mm:SS.xx} %h:%P T%t [%p]: %m%n\", "
            "rotationCount: 10, appenderType: \"LoggerAppenderFileRotate\", "
            "filename: \"$pathOMQ-$instance-WF-$name.log\", encoding: \"UTF-8\", archivePattern: \"%p%f.%i\"}}}",
    },
    "services": {
        "params": "{level: 20000, name: \"DefaultServiceLogger\", additivity: false, appenders: {\"1\": "
            "{name: \"DefaultServiceAppender\", layoutPattern: \"%d{YYYY-MM-DD HH:mm:SS.xx} %h:%P T%t [%p]: %m%n\", "
            "rotationCount: 10, appenderType: \"LoggerAppenderFileRotate\", "
            "filename: \"$pathOMQ-$instance-SVC-$name.log\", encoding: \"UTF-8\", archivePattern: \"%p%f.%i\"}}}",
    },
    "jobs": {
        "params": "{level: 20000, name: \"DefaultJobLogger\", additivity: false, appenders: {\"1\": "
            "{name: \"DefaultJobAppender\", layoutPattern: \"%d{YYYY-MM-DD HH:mm:SS.xx} %h:%P T%t [%p]: %m%n\", "
            "rotationCount: 10, appenderType: \"LoggerAppenderFileRotate\", "
            "filename: \"$pathOMQ-$instance-JOB-$name.log\", encoding: \"UTF-8\", archivePattern: \"%p%f.%i\"}}}",
    },
    "qdsp": {
        "params": "{level: 20000, name: \"DefaultQdspLogger\", additivity: false, appenders: {\"1\": "
            "{name: \"DefaultQdspAppender\", layoutPattern: \"%d{YYYY-MM-DD HH:mm:SS.xx} %h:%P T%t [%p]: %m%n\", "
            "rotationCount: 10, appenderType: \"LoggerAppenderFileRotate\", "
            "filename: \"$pathOMQ-$instance-QDSP-$name.log\", encoding: \"UTF-8\", archivePattern: \"%p%f.%i\"}}}",
    },
    "system": {
        "params": "{level: 20000, name: \"DefaultSystemLogger\", additivity: false, appenders: {\"1\": "
            "{name: \"DefaultSystemAppender\", layoutPattern: \"%d{YYYY-MM-DD HH:mm:SS.xx} %h:%P T%t [%p]: %m%n\", "
            "rotationCount: 10, appenderType: \"LoggerAppenderFileRotate\", "
            "filename: \"$pathOMQ-$instance-$name.log\", encoding: \"UTF-8\", archivePattern: \"%p%f.%i\"}}}",
    },
);

# arch keys to migrate to config items; old -> config
const ArchMigrationKeys = {
    "active": {
        "new": "active",
        "type": "bool",
    },
    "datasource": {
        "new": "datasource",
        "type": "string",
    },
    "days-interval": {
        "new": "day-interval",
        "type": "int",
    },
    "days-interval-workflows": {
        "new": "day-interval-workflows",
        "type": "int",
    },
    "days-interval-jobs": {
        "new": "day-interval-jobs",
        "type": "int",
    },
    "batch-size": {
        "new": "batch-size",
        "type": "int",
    },
    "batch-sleep": {
        "new": "batch-sleep",
        "type": "int",
    },
    "max-loops": {
        "new": "max-loops",
        "type": "int",
    },
    "no-metadata": {
        "new": "no-metadata",
        "type": "bool",
    },
    "archive": {
        "new": "archive",
        "type": "bool",
    },
    "purge": {
        "new": "purge",
        "type": "bool",
    },
    "space-management": {
        "new": "space-management",
        "type": "bool",
    },
    "filter": {
        "new": "filter",
        "type": "hash",
    },
    "statistics": {
        "new": "statistics",
        "type": "bool",
    },
    "statistics-options": {
        "new": "statistics-options",
        "type": "hash",
    },
    "shadow-datasources": {
        "new": "shadow-datasources",
        "type": "list",
    },
};

public namespace QorusSchema {
    public QorusSchema sub get_schema_object(AbstractDatasource ds, *string dts, *string its) {
        return new QorusSchema(ds, dts, its);
    }

    public sub clear_logger_id(*Tables table_cache, AbstractDatasource ds, string name, *int verbose) {
        if (verbose) {
            stdout.printf("Clearing loggerid from table %y...\n", name);
        }

        AbstractTable t = table_cache
            ? table_cache.get(ds, name)
            : (new Table(ds, name)).getTable();
        t.update(("loggerid": NOTHING));
    }

    public sub clear_logger_params(AbstractDatasource ds, Table loggers, *int verbose) {
        if (verbose) {
            stdout.printf("Clearing logger params...\n");
        }

        clear_logger_id(NOTHING, ds, "workflows", verbose);
        clear_logger_id(NOTHING, ds, "services", verbose);
        clear_logger_id(NOTHING, ds, "jobs", verbose);
        clear_logger_id(NOTHING, ds, "connections", verbose);

        loggers.del();
    }

    public sub set_logger_def_params(AbstractDatasource ds, Table loggers, *int verbose) {
        if (verbose) {
            stdout.printf("Set default logger params...\n");
        }

        Database db(ds, SchemaOpts);
        foreach hash<auto> i in (DefaultLoggers.pairIterator()) {
            *hash<auto> logger_row = loggers.selectRow({"where": {"interface_table_name": i.key}});
            # only insert if there is no logger
            if (logger_row) {
                continue;
            }

            logger_row = {
                "loggerid": db.getNextSequenceValue("seq_loggers"),
                "interface_table_name": i.key,
                "params": i.value.params,
            };

            loggers.insert(logger_row);
        }
    }

    public class QorusSchema inherits AbstractVersionedSchema {
        constructor(AbstractDatasource ds, string dts = "omq_data", string its = "omq_index") : AbstractVersionedSchema(ds, dts, its, SchemaOpts) {
            # validate the presence of arch-prefixed attributes. These are
            # a must for each table in this module.
            HashIterator it(Tables);
            while (it.next()) {
                if (it.getKey() == "driver")
                    continue;

                if (!it.getValue().hasKey("arch")) {
                    throw "QORUS-SCHEMA-ERROR",
                          sprintf("Table %s does not contain an 'arch' hash attribute", it.getKey());
                }

                if (!inlist(it.getValue().arch.type, Arch::TYPES)) {
                    throw "QORUS-SCHEMA-ERROR",
                           sprintf("Table %s does not contain a correct 'arch.type' hash attribute", it.getKey());
                }

                if (it.getValue().arch.type != Arch::TYPE_EXCLUDED
                    && !inlist(it.getValue().arch.data, Arch::DATAS)) {
                    throw "QORUS-SCHEMA-ERROR",
                          sprintf("Table %s does not contain a correct 'arch.data' hash attribute", it.getKey());
                }
            }
        }

        private string getNameImpl() {
            return "Qorus";
        }

        private string getVersionImpl() {
            return OMQ::datamodel;
        }

        private *softstring getSchemaVersion() {
            Table vt(ds, version_table);
            if (!vt.checkExistence())
                return;

            # support earlier Qorus versions with column "key" instead of "keyname"
            if (vt.describe().hasKey("key"))
                version_where."key" = remove version_where.keyname;
            return vt.selectRow(("columns": "value", "where": version_where)).value;
        }

        private string getVersionTableImpl() {
            return "system_properties";
        }

        private string getVersionColumnImpl() {
            return "value";
        }

        private hash<auto> getVersionWhereImpl() {
            return ("domain": "omq", "keyname": "schema-version");
        }

        *hash<auto> getTablesImpl() {
            # plain Tables constatnt cannot be returned here.
            # To remove of 'arch' key is mandatory to prevent SqlUtil errors
            # about disallowed keys for Table objects.
            hash<auto> ret;
            HashIterator it(Tables);
            while (it.next()) {
                ret{it.getKey()} = it.getValue() - "arch";
            }
            return ret;
        }

        #! A helper method for system.arch service. It returns raw Tables hash with all key/values.
        hash<auto> getRawTables() {
            return Tables;
        }

        *hash<auto> getSequencesImpl() {
            return Sequences;
        }

        *hash<auto> getTypesImpl() {
        }

        *hash<auto> getFunctionsImpl() {
            switch (drv) {
                case "mysql": return MYSQL_Functions;
            }
        }

        *hash<auto> getProceduresImpl() {
        }

        *hash<auto> getPackagesImpl() {
            switch (drv) {
                case "oracle": return ORACLE_Packages;
            }
        }

        *hash<auto> getIndexOptionsImpl() {
            return IndexOptions;
        }

        *hash<auto> getGenericOptionsImpl() {
            return GenericOptions;
        }

        *hash<auto> getColumnOptionsImpl() {
            return ColumnOptions;
        }

        #! returns a hash of "strict reference data", describing the only data that can appear in the target table
        *hash<auto> getStrictReferenceDataHashImpl() {
            return StrictReferenceData;
        }

        #! returns a hash of "normal reference data", describing data that must appear in the target table, however additional rows are also acceptable
        *hash<auto> getReferenceDataHashImpl() {
            return ReferenceData;
        }

        #! returns a hash of "create-only reference data", describing data that is written to the table when the table is created
        *hash<auto> getCreateOnlyReferenceDataImpl() {
            return CreateOnlyReferenceData;
        }

        #! returns a hash of "create-only reference data", describing data that will only be inserted if missing, otherwise existing rows with changed data are left unchanged
        *hash<auto> getInsertOnlyReferenceDataImpl() {
            hash<auto> rv = InsertOnlyReferenceData;
            if (drv == "mysql") {
                # create mysql sequence table based on sequences required for Qorus
                list<list<auto>> l = ();
                push l, ("name", "id");
                map (push l, ($1, 1)), keys SequenceHash;
                rv.omq_sequences = l;
            }
            return rv;
        }

        private bool checkFirstTimeInstall() {
            bool rc = AbstractVersionedSchema::checkFirstTimeInstall();
            if (!rc) {
                # ensure we have reference data
                *AbstractTable t = db.getTable("session_status");
                if (!t || t.emptyData())
                    rc = True;
            }

            return rc;
        }

        private bool checkUpgrade(string current_version) {
            # this is where special logic would go for schema upgrades that cannot be performed completely automatically
            return True;
        }

        private bool checkDowngrade(string current_version) {
            return True;
        }

        private doPostAlignment(Tables table_cache, bool first_time_install, *hash initial_schema_info, int verbose) {
            # this is where special logic would go for schema upgrades that cannot be performed completely automatically
        }

        postDataActions(Tables table_cache, bool first_time_install, *hash<auto> initial_schema_info, int verbose) {
            # fissue #3359: for mysql we have to commit the transaction here so that the sequence values will be in the table
            if (drv == "mysql") {
                ds.commit();
            }

            # insert logger info
            AbstractTable loggers = table_cache.get(ds, "loggers");

            if (first_time_install) {
                # db object is required for sequence handling - db.getNextSequenceValue()
                Database db(ds, SchemaOpts);

                # note: this is tricky. loggers are using seq_loggers for a PK.
                #       This means that we cannot use any kind of "ReferenceData"
                #       because we have to use the sequence's nextval.
                # So in this case we are rolling the seq to the max value
                # used in the loggers table. Just to be sure.
                hash<auto> sh = {
                    "columns": cop_as(cop_max("loggerid"), "maxid"),
                };
                softint maxid = loggers.selectRow(sh).maxid ?? 0;
                softint id = 0;
                do {
                    id = db.getNextSequenceValue("seq_loggers");
                } while (id < maxid);
                # end of seq rotation
            }

            if (verbose) {
                stdout.printf("Set default logger params...\n");
            }

            Database db(ds, SchemaOpts);
            foreach hash<auto> i in (DefaultLoggers.pairIterator()) {
                *hash<auto> logger_row = loggers.selectRow({"where": {"interface_table_name": i.key}});
                # only insert if there is no logger
                if (logger_row) {
                    continue;
                }

                logger_row = {
                    "loggerid": db.getNextSequenceValue("seq_loggers"),
                    "interface_table_name": i.key,
                    "params": i.value.params,
                };

                loggers.insert(logger_row);
            }

            # this is where special logic would go for schema upgrades that cannot be performed completely automatically
        }
    }
}

# content of this namespace is here only for a etc/remoteconnections to DB
# migration - Qorus 3.x -> Qorus 4.0
namespace RemoteconnectionMigration {

    # connection scanner
    list<auto> sub scan_conn_exp(string fname, *hash<auto> defines, string arg, int line = 1) {
        #printf("DBG se: %y\n", arg);

        list<auto> l = ();

        # active quote character
        *string quote;

        # active comment
        bool comment = False;

        int len = arg.length();

        # scanner start line
        int start_line = line;

        # define stack
        DefineStack ds(fname, defines);

        # character position in input
        int i = 0;

        # check for parse commands related to defines
        code checkdef = sub () {
            if (arg[i + 1] != '%')
                return;
            string str = arg.substr(i + 1, 100);
            if (str =~ /^%else\s*/) { #/){
                ds.doElse(line);
                i += 5;
            }
            else if (str =~ /^%ifdef\s+\w+/) {
                (string blnk, string def) = (str =~ x/^%ifdef(\s+)(\w+)/);
                ds.doIfdef(line, def);
                i += blnk.size() + def.size() + 6;
            }
            else if (str =~ /^%ifndef\s+\w+/) {
                (string blnk, string def) = (str =~ x/^%ifndef(\s+)(\w+)/);
                ds.doIfndef(line, def);
                i += blnk.size() + def.size() + 7;
            }
            else if (str =~ /^%endif\s*/) { #/){
                ds.doEndif(line);
                i += 6;
            }
        };

        code add = sub (int type, *string val) {
            #printf("active, adding %y: %y\n", EtMap{type}, val);
            l += ("type": type, "val": val, "start_line": start_line, "end_line": line);
            start_line = line;
        };

        string str;

        # we only recognize quotes and parens if we are not in a raw string with alphabetic characters
        # for backwards compatibility
        code quote_paren_ok = bool sub () {
            #printf("i %d arg: %y: %y\n", i, arg.substr(i + 1, 10), (arg.substr(i + 1) =~ /^\s*(#.*)?\n/));
            if (!l)
                return False;
            if (str.empty() || str =~ /^(\s|[0-9])+$/ || str =~ /\n\s*$/ || i == (len - 1))
                return True;
            *string ss = arg.substr(i + 1);
            if (ss =~ /^\s*(#.*)?(\n|$)/)
                return True;
            return False;
        };

        for (; i < len; ++i) {
            string c = arg[i];
            if (comment) {
                if (c == "\n") {
                    comment = False;
                    ++line;
                    checkdef();
                }
                continue;
            }
            if (c == "\n") {
                ++line;
                if (!quote) {
                    checkdef();
                }
            }
            else if (!ds.active())
                continue;
            else if (c == "\r")  # ignore CR chars
                continue;
            else if (c == ",") {
                if (!quote) {
                    #printf("DBG: got comma i:%d\n", i);
                    trim str;
                    if (str.val()) {
                        add(ET_RawString, str);
                        str = "";
                    }
                    add(ET_Comma);
                    continue;
                }
            }
            else if (c == "=") {
                if (!quote) {
                    trim str;
                    if (str.val()) {
                        add(ET_RawString, str);
                        str = "";
                    }
                    add(ET_Eq);
                    continue;
                }
            }
            else if (c == '"') {
                if (quote) {
                    if (c == quote) {
                        delete quote;
                        add(ET_QuotedString, str);
                        str = "";
                        continue;
                    }
                }
                else if (quote_paren_ok()) {
                    quote = c;
                    trim str;
                    if (str.val()) {
                        add(ET_RawString, str);
                        str = "";
                    }
                    continue;
                }
            }
            else if (quote) {
                # only process the backslash if not parsing a bracket expression
                # because these strings are parsed a second time later
                if (c == "\\") {
                    switch (arg[++i]) {
                        case "n": str += "\n"; break;
                        case "r": str += "\r"; break;
                        case "t": str += "\t"; break;
                        case "\$": str += "\\\$"; break;
                        default: str += arg[i]; break;
                    }
                    continue;
                }

            }
            else {
                if (c == "#") {
                    if (!comment)
                        comment = True;
                }
                else {
                    if (c == "(" && quote_paren_ok()) {
                        trim str;
                        if (str.val()) {
                            add(ET_RawString, str);
                            str = "";
                        }
                        add(ET_OpenParen);
                        continue;
                    }
                    else if (c == ")" && quote_paren_ok()) {
                        trim str;
                        if (str.val()) {
                            add(ET_RawString, str);
                            str = "";
                        }
                        add(ET_CloseParen);
                        continue;
                    }
                }
            }
            if (!comment)
                str += c;
        }

        trim str;
        if (str.val())
            add(ET_RawString, str);

        return l;
    }

    string sub replace_env_quoted(string str) {
        #printf("replace_env_quoted() str: %y\n", str);
        int start = 0;
        while (True) {
            start = str.find("\$", start);
            if (start == -1)
                break;
            # skip it if the $ is escaped
            if (start > 0 && str[start - 1] == "\\") {
                # replace backquote char
                splice str, start - 1, 1;
                continue;
            }
            string var;
            # find the end of the env var
            int end = start + 1;
            bool bracket = str[end] == "{";
            if (bracket)
                ++end;

            # find the end of the word
            while (True) {
                if (str[end] !~ /[[:word:]]/)
                    break;
                ++end;
            }

            # process end of env var word
            if (bracket) {
                if (str[end] == "}" && (end - start) > 2) {
                    var = str.substr(start + 2, end - start - 2);
                    ++end;
                }
                else {
                    # skip it: empty string or missing closing bracket
                    start = end;
                    continue;
                }
            }
            else {
                if ((end - start) > 1) {
                    var = str.substr(start + 1, end - start - 1);
                }
                else {
                    # skip it: empty string
                    start = end;
                    continue;
                }
            }

            string val = ENV{var} ?? "";
            #printf("GOT VAR: %y = %y (%d) (bracket: %y start: %d end: %d)\n", var, val, val.size(), bracket, start, end);

            # replace value in string
            splice str, start, (end - start), val;
            # start looking at next position
            start += val.size();
            #printf("new val: %y new start: %d\n", str, start);
        }
        return str;
    }

    const ET_RawString = 0;
    const ET_QuotedString = 1;
    const ET_Eq = 2;
    const ET_Comma = 3;
    const ET_OpenParen = 4;
    const ET_CloseParen = 5;
    const EtMap = (
        ET_RawString: "raw string",
        ET_QuotedString: "quoted string",
        ET_Eq: "=",
        ET_Comma: ",",
        ET_OpenParen: "(",
        ET_CloseParen: ")",
    );

    class DefineStack {
        public {}

        private {
            string fname;
            *hash<auto> defines;
            list<auto> ds = ();
        }

        constructor(string fname, *hash<auto> defines) {
            self.fname = fname;
            self.defines = defines;
        }

        destructor() {
            if (ds)
                throw "CONNECTION-ERROR", sprintf("%s: define block %y not closed with an %%endif", fname, ds.last().define);
        }

        doElse(int line) {
            if (!ds)
                throw "CONNECTION-ERROR", sprintf("%s:%d: \"%%else\" used without a corresponding %%ifdef or %%ifndef", fname, line);

            hash<auto> dh = ds.last();

            if (dh.block)
                throw "CONNECTION-ERROR", sprintf("%s:%d: \"%%else\" used without an %%endif in %y define", fname, line, dh.define);

            ds[ds.size() - 1] += (
                "block": 1,
                "active": !dh.active,
            );
        }

        doIfdef(int line, string def) {
            #printf("%s:%d ifdef %y: %y\n", fname, line, def, exists defines{def});
            hash<auto> dfh = {
                "define": def,
                "block": 0,
                "active": exists defines{def},
                #"parent_active": ds ? ds.last().active : True,
            };
            ds += dfh;
        }

        doIfndef(int line, string def) {
            #printf("%s:%d ifndef %y: %y\n", fname, line, def, exists defines{def});
            hash<auto> dfh = {
                "define": def,
                "block": 0,
                "active": !(exists defines{def}),
                #"parent_active": ds ? ds.last().active : True,
            };
            ds += dfh;
        }

        doEndif(int line) {
            if (!ds)
                throw "CONNECTION-ERROR", sprintf("%s:%d \"%%endif\" used without a corresponding %%ifdef or %%ifndef", fname, line);
            #printf("%s:%d endif %y: %y\n", fname, line, ds.last().define, ds.size() <= 1 || ds[ds.size() - 2].active);
            pop ds;
        }

        bool active() {
            return !ds || ds.last().active;
        }
    }

} # namespace RemoteconnectionMigration
